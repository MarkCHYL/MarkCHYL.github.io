[{"title":"FFmpeg 命令使用的自学文档","url":"/2024/12/31/FFmpeg-命令使用的自学文档/"},{"title":"网络状态自定义组件---自定义控件","url":"/2024/07/11/网络状态自定义组件-自定义控件/","content":"特点：独立性 + 可移植性\n所有的逻辑都在这个控件中，直接在布局中添加就可以\n技术点：协程CoroutineScope + 生命感知LifecycleOwner\n\n直接贴代码\n<!-- more -->\n```kotlin\nimport android.content.Context\nimport android.content.res.ColorStateList\nimport android.graphics.Color\nimport android.util.AttributeSet\nimport android.view.LayoutInflater\nimport android.widget.FrameLayout\nimport androidx.appcompat.widget.AppCompatTextView\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.LifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.OnLifecycleEvent\nimport com.yunda.android.framework.ui.YDLibApplication\nimport com.yunda.transportapp.base.BuildConfig\nimport com.yunda.transportapp.base.R\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\n\nclass NetworkStatusView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : FrameLayout(context, attrs, defStyleAttr), LifecycleObserver {\n\n    private val statusTextView: AppCompatTextView\n    private val coroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    private var monitoringJob: Job? = null\n\n    enum class NetworkStatus {\n        NO_NETWORK, BAD_NETWORK, WEAK_NETWORK, AVERAGE_NETWORK, GOOD_NETWORK\n    }\n\n    init {\n        val view = LayoutInflater.from(context).inflate(R.layout.network_status_view, this, true)\n        statusTextView = view.findViewById(R.id.statusTextView)\n\n        if (context is LifecycleOwner) {\n            (context as LifecycleOwner).lifecycle.addObserver(this)\n        }\n    }\n\n    private suspend fun updateStatus(newStatus: NetworkStatus) {\n        withContext(Dispatchers.Main){\n            when (newStatus) {\n                NetworkStatus.NO_NETWORK -> {\n                    updateNetworkUI(\n                        \"当前无法链接网络，请检查网络设置是否正常。\", \"#EC4444\",\n                        R.drawable.icon_net_fail\n                    )\n                }\n\n                NetworkStatus.BAD_NETWORK -> {\n                    updateNetworkUI(\n                        \"当前网络状态极差，请检查网络设置是否正常。\", \"#EC4444\",\n                        R.drawable.icon_net_fail\n                    )\n                }\n\n                NetworkStatus.WEAK_NETWORK -> {\n                    updateNetworkUI(\n                        \"当前网络状态较差，请小心驾驶。\", \"#F68B28\",\n                        R.drawable.icon_net_moderate\n                    )\n                }\n\n                NetworkStatus.AVERAGE_NETWORK -> {\n                    updateNetworkUI(\n                        \"当前网络状态良好，请小心驾驶。\", \"#14C97D\",\n                        R.drawable.icon_net_good\n                    )\n                }\n\n                NetworkStatus.GOOD_NETWORK -> {\n                    updateNetworkUI(\n                        \"当前网络状态极好，请小心驾驶。\", \"#3976F3\",\n                        R.drawable.icon_net_ok\n                    )\n                }\n            }\n        }\n    }\n\n    private fun updateNetworkUI(descStr: String, colorBg: String, iconResId: Int) {\n        try {\n            with(statusTextView) {\n                text = descStr\n                setCompoundDrawablesWithIntrinsicBounds(\n                    ContextCompat.getDrawable(YDLibApplication.INSTANCE, iconResId),\n                    null,\n                    null,\n                    null\n                )\n                backgroundTintList = ColorStateList.valueOf(Color.parseColor(colorBg))\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n\n    }\n\n    private suspend fun checkNetworkSpeed(): NetworkStatus {\n        return withContext(Dispatchers.IO) {\n            try {\n                val process = Runtime.getRuntime().exec(\"ping -c 1 www.baidu.com\")\n                val reader = BufferedReader(InputStreamReader(process.inputStream))\n                val output = reader.readLines()\n                reader.close()\n                val timeLine = output.find { it.contains(\"time=\") }\n                val timeValue =\n                    timeLine?.substringAfter(\"time=\")?.substringBefore(\" ms\")?.toDoubleOrNull()\n\n                if (BuildConfig.DEBUG) {\n                    println(\"Ping time: $timeValue ms\")\n                }\n                when {\n                    timeValue == null -> NetworkStatus.NO_NETWORK\n                    timeValue >= 0 && timeValue < 100 -> NetworkStatus.GOOD_NETWORK\n                    timeValue >= 100 && timeValue < 200 -> NetworkStatus.AVERAGE_NETWORK\n                    timeValue >= 200 && timeValue < 600 -> NetworkStatus.WEAK_NETWORK\n                    else -> NetworkStatus.BAD_NETWORK\n                }\n            } catch (e: Exception) {\n                e.printStackTrace()\n                NetworkStatus.NO_NETWORK\n            }\n        }\n\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun startMonitoring() {\n        monitoringJob = coroutineScope.launch {\n            while (isActive) {\n                val status = checkNetworkSpeed()\n                updateStatus(status)\n                delay(5000) // 每5秒检查一次网络状态\n            }\n        }\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun stopMonitoring() {\n        monitoringJob?.cancel()\n    }\n}\n```","tags":["自定义View"],"categories":["Android"]},{"title":"Node.js 版本管理工具:nvm","url":"/2024/06/13/Node-js-版本管理工具-nvm/","content":"[参考原文](https://blog.csdn.net/qq_41581588/article/details/139227504)\n\nnvm 是一款 Node.js 版本管理工具，允许用户通过命令行快速安装、切换和管理不同的 Node.js 版本。\n\n图片![](https://img-blog.csdnimg.cn/img_convert/49f67ddef04c0f95bf84de1a72a19853.png)\n（图片来自：github）\n\n>nvm 只适用于 macOS 和 Linux 用户的项目，如果是 Windows 用户，可以使用 nvm-windows 、nodist 或 nvs 替换。\n\n<!-- more -->\n\n### 安装方式\nmacOS 下载方式：\n\n```shell\n# 方式1 浏览器打开下面链接下载\nhttps://github.com/nvm-sh/nvm/blob/v0.39.7/install.sh\n# 下载完成后，通过命令安装\nsh install.sh\n \n# 方式2 推荐\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n \n# 方式3\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n```\n安装过程中如果遇到一些奇怪的问题，可以查看下 nvm 补充说明\n\n### 常用命令\n```shell\nnvm ls                # 查看版本安装所有版本\nnvm ls-remote         # 查看远程所有的 Node.js 版本\nnvm install 17.0.0    # 安装指定的 Node.js 版本\nnvm use 17.0.0        # 使用指定的 Node.js 版本\nnvm alias default 17.0.0  # 设置默认 Node.js 版本\nnvm alias dev 17.0.0  # 设置指定版本的别名，如将 17.0.0 版本别名设置为 dev\n```\n","tags":["环境"],"categories":["开发工具"]},{"title":"环境整理（pro、sit、uat、test、pre、dev、fat ）","url":"/2024/06/04/环境整理（pro、sit、uat、test、pre、dev、fat-）/","content":"\n[原文链接](https://blog.csdn.net/qq_15821487/article/details/129485750)\n\n**pro**（Production environment）：生产环境，面向外部用户的环境，正式环境，连接上互联网即可访问。\n\n**sit** (System Integration Test ): 系统集成测试，开发人员自己测试流程是否走通。\n\n**uat** (User Acceptance Test environment): 用户验收测试环境，用于生产环境下的软件测试者测试使用。\n\n**test**: 测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定。\n\n**pre** ：灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样，外部用户可以访问，版本发布初期，正式版本发布前。\n\n**dev**（Development environment） ： 开发环境，外部用户无法访问，开发人员使用，版本变动很大。\n\n**fat** (Feature Acceptance Test environment) : 功能验收测试环境，用于软件测试者测试使用","tags":["术语"],"categories":["Android"]},{"title":"mac上打开安卓项目 The C compiler identification is Clang 14.0.6","url":"/2024/06/04/mac上打开安卓项目-The-C-compiler-identification-is-Clang-14-0-6/","content":"这个错误信息通常出现在尝试在Mac上构建一个Android项目时，特别是使用CMake作为构建系统时。它表明C编译器识别为Clang版本14.0.6。\n\n解释：\n这个信息是CMake在尝试确定编译器标识和版本时输出的。通常，这个信息是正面的，表明CMake能够找到一个合适的C编译器。\n\n解决方法：\n\n确保你的系统已经安装了Clang 14.0.6或更高版本。如果没有，你可以通过Mac的包管理器Homebrew来安装它：\n\nbrew install llvm\n\n确保CMakeLists.txt文件中指定的编译器是Clang 14.0.6或兼容版本。\n\n如果你已经安装了正确版本的Clang，但是CMake仍然报告错误，可能需要指定CMake在构建时使用的C编译器路径。你可以通过CMake命令行参数来实现这一点：\n\ncmake -DCMAKE_C_COMPILER=/path/to/clang ..\n\n确保你的构建环境（例如Android NDK）与Clang 14.0.6版本兼容。\n\n如果你使用的是特定的IDE（如Android Studio），确保它配置了正确的编译器路径。\n\n如果上述步骤无法解决问题，请提供更多的错误信息和上下文，以便进一步诊断问题。","tags":["error"],"categories":["Android"]},{"title":"ubuntu中安装mysql","url":"/2023/09/08/ubuntu中安装mysql/","content":"要在Ubuntu中安装MySQL，可以按照以下步骤进行操作：\n\n1. 打开终端：你可以按下`Ctrl+Alt+T`组合键来打开终端。\n\n2. 更新包列表：首先，运行以下命令来确保你的系统上的包列表是最新的：\n\n   ```\n   sudo apt update\n   ```\n<!-- more -->\n3. 安装MySQL服务器：运行以下命令来安装MySQL服务器：\n\n   ```\n   sudo apt install mysql-server\n   ```\n\n   在安装过程中，系统会要求你设置MySQL root用户的密码。请务必选择一个强密码，并确保记住它。\n\n4. 启动MySQL服务：安装完成后，MySQL服务将会自动启动。你可以使用以下命令来检查MySQL服务状态：\n\n   ```\n   sudo systemctl status mysql\n   ```\n\n   如果MySQL没有自动启动，你可以使用以下命令手动启动它：\n\n   ```\n   sudo systemctl start mysql\n   ```\n\n5. 配置MySQL安全性：运行以下命令来配置MySQL的基本安全性：\n\n   ```\n   sudo mysql_secure_installation\n   ```\n\n   在这个过程中，你可以选择进行一些基本的安全设置，如删除匿名用户、禁止远程root登录等。按照提示进行操作即可。\n\n6. 连接到MySQL：安装完成后，你可以使用以下命令来连接到MySQL服务器：\n\n   ```\n   mysql -u root -p\n   ```\n\n   然后输入你之前设置的MySQL root密码。\n\n现在，你已经成功在Ubuntu上安装了MySQL数据库服务器。你可以使用命令行工具或图形界面工具（如phpMyAdmin）来管理MySQL数据库。如果需要更多详细信息或有其他问题，请随时提问。\n\n### 安装过程中没有要求我设置账号密码，我现在需要重新安装\n如果在安装MySQL过程中没有要求你设置账号密码，你可以尝试重新安装MySQL并确保按照以下步骤操作：\n\n1. 首先，确保你的系统处于最新状态，以获取最新的软件包信息：\n\n   ```\n   sudo apt update\n   ```\n\n2. 然后，安装MySQL服务器：\n\n   ```\n   sudo apt install mysql-server\n   ```\n\n3. 安装过程中，你应该会看到一个对话框，要求你设置MySQL root用户的密码。如果你没有看到这个对话框，可以尝试卸载MySQL并重新安装：\n\n   ```\n   sudo apt remove --purge mysql-server mysql-client mysql-common\n   sudo apt autoremove\n   sudo apt autoclean\n   ```\n\n4. 完成卸载后，再次安装MySQL服务器：\n\n   ```\n   sudo apt install mysql-server\n   ```\n\n5. 在重新安装MySQL时，确保注意看控制台上的任何提示，以设置MySQL root 用户的密码。遵循提示进行操作。\n\n6. 安装完成后，你可以使用以下命令来检查MySQL服务状态：\n\n   ```\n   sudo systemctl status mysql\n   ```\n### sudo apt install mysql-server执行后没有提示设置密码。默认密码是啥\n\n如果在安装MySQL时没有提示设置密码，并且没有默认密码，那么可能是因为MySQL版本或配置文件的不同。在某些MySQL安装中，默认情况下可能没有设置root密码。\n\n尝试使用以下步骤来设置root密码：\n\n1. 通过以下方式登录到MySQL服务器：\n\n   ```\n   sudo mysql\n   ```\n\n2. 在MySQL中，使用以下命令来更改root用户的密码（将`your_new_password`替换为你希望设置的新密码）：\n\n   ```\n   ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'your_new_password';\n   ```\n\n3. 刷新MySQL权限：\n\n   ```\n   FLUSH PRIVILEGES;\n   ```\n\n4. 退出MySQL：\n\n   ```\n   EXIT;\n   ```\n\n现在，你应该已经成功设置了MySQL root 用户的密码。你可以使用新密码来登录MySQL。\n\n### ERROR 1819 (HY000): Your password does not satisfy the current policy requirements\n这个错误是因为MySQL的密码策略要求密码必须符合一定的安全性要求。默认情况下，MySQL要求密码满足以下条件：\n\n1. 至少包含8个字符。\n2. 包含大写字母。\n3. 包含小写字母。\n4. 包含数字。\n5. 包含特殊字符（例如：!、@、#、$等）。\n\n如果你的密码不符合这些要求，你可以尝试以下方法来解决这个问题：\n\n1. **使用更强密码**：尝试创建一个更复杂的密码，满足上述要求。\n\n2. **修改密码策略**：如果你不想使用这些复杂的密码策略，可以修改MySQL的密码策略。但要注意，这可能会降低数据库的安全性。要修改密码策略，可以按照以下步骤：\n\n   - 编辑MySQL配置文件（通常是`/etc/mysql/mysql.conf.d/mysqld.cnf`）：\n\n     ```\n     sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf\n     ```\n\n   - 在配置文件中找到或添加以下行来禁用密码策略：\n\n     ```\n     skip-policy\n     ```\n\n   - 保存文件并退出编辑器。\n\n   - 重新启动MySQL服务：\n\n     ```\n     sudo systemctl restart mysql\n     ```\n\n3. **使用密码生成工具**：你还可以使用密码生成工具来创建一个符合要求的密码，然后将其用作MySQL的密码。例如：\n\n   ```\n   openssl rand -base64 12\n   ```\n\n   这将生成一个12个字符长的随机密码。\n\n无论你选择哪种方法，都需要确保你的MySQL密码足够安全，以保护数据库的安全性。如果你对密码策略和安全性有疑问，最好咨询数据库管理员或安全专家的建议。","tags":["mysql"],"categories":["ubuntu"]},{"title":"在Ubuntu上安装多个版本的Java JDK","url":"/2023/09/08/在Ubuntu上安装多个版本的Java-JDK/","content":"在Ubuntu上安装多个版本的Java JDK（Java Development Kit）是可行的，并且可以使用`update-alternatives`来管理不同版本之间的切换。以下是一个示例，演示如何在Ubuntu上安装和管理多个Java JDK版本。\n\n1. **检查系统上已安装的Java版本：**\n\n   在终端中运行以下命令，以查看系统上已安装的Java版本：\n\n   ```bash\n   update-java-alternatives -l\n   ```\n<!-- more -->\n   这将列出已安装的Java版本。\n\n2. **安装新的Java JDK版本：**\n\n   可以使用`apt`或手动下载并安装Java JDK。以下是使用`apt`来安装OpenJDK 8和OpenJDK 11的示例：\n\n   ```bash\n   # 安装OpenJDK 8\n   sudo apt update\n   sudo apt install openjdk-8-jdk\n\n   # 安装OpenJDK 11\n   sudo apt update\n   sudo apt install openjdk-11-jdk\n   ```\n\n   您可以根据需要安装其他版本的Java JDK。\n\n3. **使用`update-alternatives`选择默认版本：**\n\n   使用`update-alternatives`命令选择默认的Java版本。例如，选择OpenJDK 11作为默认版本：\n\n   ```bash\n   sudo update-alternatives --config java\n   ```\n\n   这将列出系统上已安装的Java版本，并要求您选择默认版本。按照提示进行选择。\n\n4. **验证默认版本：**\n\n   使用以下命令验证默认的Java版本：\n\n   ```bash\n   java -version\n   ```\n\n   这将显示当前默认的Java版本。\n\n5. **切换Java版本：**\n\n   如果需要切换到其他已安装的Java版本，可以随时使用`update-alternatives`命令进行更改。例如，要切换回OpenJDK 8：\n\n   ```bash\n   sudo update-alternatives --config java\n   ```\n\n   然后选择OpenJDK 8。\n\n通过这些步骤，您可以在Ubuntu上安装和管理多个Java JDK版本，并随时切换到需要的版本。","tags":["环境配置"],"categories":["ubuntu"]},{"title":"Spring Cache入门使用教程","url":"/2023/08/17/Spring-Cache入门使用教程/","content":"\n## Spring Cache入门使用教程\n\n### 什么是Spring Cache？\n\nSpring Cache是Spring框架提供的一个模块，用于在应用程序中实现缓存功能。它允许你将方法的结果缓存起来，以便在后续调用中重复使用，从而提高应用程序的性能。\n\n### 步骤 1：添加依赖\n\n在你的Spring项目中，首先需要添加Spring Cache的依赖。在Maven项目中，你可以在`pom.xml`文件中添加以下依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n```\n\n### 步骤 2：配置缓存管理器\n\n在Spring Boot应用程序中，默认情况下，会自动配置一个适合的缓存管理器。如果你需要自定义缓存管理器，你可以在配置类中添加如下配置：\n\n```java\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    // 配置其他缓存管理器的Bean，如Redis、Ehcache等\n}\n```\n\n### 步骤 3：在方法上添加缓存注解\n\n在你想要启用缓存的方法上添加缓存注解，如`@Cacheable`、`@CachePut`和`@CacheEvict`。\n\n- `@Cacheable`：用于标记方法的结果应该被缓存。如果有缓存可用，方法将不会被调用，而是直接从缓存中返回结果。\n- `@CachePut`：用于标记方法的结果应该被缓存，并且每次方法被调用时都会执行方法体，并将结果放入缓存。\n- `@CacheEvict`：用于标记方法执行后应该清除缓存。\n\n```java\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class MyService {\n\n    @Cacheable(\"myCache\")\n    public String getCachedData(String key) {\n        // 这里是实际方法逻辑\n        return \"Cached Data\";\n    }\n}\n```\n\n### 步骤 4：配置缓存参数\n\n你可以在`@Cacheable`、`@CachePut`和`@CacheEvict`注解中指定缓存的参数，如缓存的名称、键生成器等。例如：\n\n```java\n@Cacheable(value = \"myCache\", key = \"#key\")\npublic String getCachedData(String key) {\n    // ...\n}\n```\n\n### 步骤 5：运行和测试\n\n现在，你的Spring应用程序已经配置了缓存。你可以运行并测试你的方法，观察缓存的工作情况。\n\n### 小结\n\n通过遵循以上步骤，你就可以在Spring应用程序中开始使用缓存功能。记得根据你的应用程序需求和性能优化要求来选择适合的缓存管理器和注解。\n","tags":["Cache"],"categories":["Java"]},{"title":"Redis操作命令的使用","url":"/2023/08/11/Redis操作命令的使用/","content":"Redis操作命令的使用笔记，涵盖基本数据类型的常见操作。以下是这份笔记：\n\n---\n\n## Redis 操作命令使用指南\n\n### 1. 字符串（String）\n\n- 设置指定key的值: `SET key value`\n- 获取指定key的值: `GET key`\n- 设置指定key的值，并将 key 的过期时间设为 seconds 秒：`SETEX key seconds value`\n- 只有在 key 不存在时设置 key 的值: `SETNX key value`\n- 追加字符串：`APPEND key value`\n- 获取字符串长度：`STRLEN key`\n- 自增：`INCR key`\n- 自增指定值：`INCRBY key increment`\n- 自增浮点数：`INCRBYFLOAT key increment`\n- 设置并获取旧值：`GETSET key value`\n- 设置多个键值对：`MSET key1 value1 [key2 value2 ...]`\n- 获取多个键值：`MGET key1 [key2 ...]`\n- 设置键的过期时间：`EXPIRE key seconds`\n- 设置键的过期时间（毫秒）：`PEXPIRE key milliseconds`\n- 获取键的剩余生存时间：`TTL key`\n- 获取键的剩余生存时间（毫秒）：`PTTL key`\n- 移除键的过期时间：`PERSIST key`\t\n<!-- more -->\n\n### 2. 哈希（Hash）\n\n- 设置哈希字段值：`HSET key field value`\n- 获取哈希字段值：`HGET key field`\n- 获取整个哈希表：`HGETALL key`\n- 获取哈希表所有字段：`HKEYS key`\n- 获取哈希表所有值：`HVALS key`\n- 删除存储在哈希表中的指定字段: `HDEL key field\t`\n\n### 3. 列表（List）\n\n- 在列表头部插入元素：`LPUSH key value`\n- 在列表尾部插入元素：`RPUSH key value`\n- 弹出并返回列表头部元素：`LPOP key`\n- 弹出并返回列表尾部元素：`RPOP key`\n- 获取列表范围内的元素：`LRANGE key start stop`\n\n### 4. 集合（Set）\n\n- 向集合添加一个或多个成员：     `SADD key member1 [member2]`\n- 删除集合中一个或多个成员:     `SREM key member1 [member2]`\n- 获取集合所有成员：           `SMEMBERS key`\n- 判断元素是否在集合中：        `SISMEMBER key member`\n- 获取集合的成员数:            `SCARD key`\n- 返回给定所有集合的交集:       `SINTER key1 [key2]`\n- 返回所有给定集合的并集:       `SUNION key1 [key2] \t` \n\n### 5. 有序集合（Sorted Set）\n\n- 获取有序集合成员的分数：`ZSCORE key member`\n- 获取有序集合的排名：`ZRANK key member`\n- 向有序集合添加一个或多个成员: `ZADD key score1 member1 [score2 member2]`\n- 通过索引区间返回有序集合中指定区间内的成员: `ZRANGE key start stop [WITHSCORES]`\n- 获取有序集合范围内的元素：`ZRANGEBYSCORE key min max`\t\t\n- 有序集合中对指定成员的分数加上增量increment: `ZINCRBY key increment member`\t\t\t \n- 移除有序集合中的一个或多个成员:   `ZREM key member [member ...] `\t\t\t\n\n### Redis的通用命令是不分数据类型的，都可以使用的命令\n- 查找所有符合给定模式( pattern)的 key:  `KEYS pattern`\t\t\n- 检查给定 key 是否存在: `EXISTS key`\t\n- 返回 key 所储存的值的类型: `TYPE key`\n- 该命令用于在 key 存在是删除 key: `DEL key`\n\n### 其他操作\n\n- 发布消息：`PUBLISH channel message`\n- 订阅消息：`SUBSCRIBE channel`\n- 事务操作：`MULTI`、`EXEC`、`WATCH`\n- 执行 Lua 脚本：`EVAL`、`EVALSHA`\n\n\n---","tags":["Redis"],"categories":["中间件"]},{"title":"ubuntu20.04虚拟机安装redis-3.2.8","url":"/2023/08/11/ubuntu20-04虚拟机安装redis-3-2-8/","content":"安装 Redis-3.2.8 在 Ubuntu 20.04 虚拟机上可以按照以下步骤进行：\n\n## 安装\n\n1. 在终端中安装 `build-essential` 和 `tcl`：\n\n   ```\n   sqlCopy code\n   sudo apt-get update\n   sudo apt-get install build-essential tcl\n   ```\n<!-- more -->\n2. 下载 Redis-3.2.8 并解压缩：\n\n   ```\n   bashCopy code\n   wget http://download.redis.io/releases/redis-3.2.8.tar.gz\n   tar xzf redis-3.2.8.tar.gz\n   cd redis-3.2.8\n   ```\n\n3. 编译 Redis：\n\n   ```\n   goCopy code\n   make\n   ```\n\n4. 运行 Redis 测试：\n\n   ```\n   bashCopy code\n   make test\n   ```\n\n5. 安装 Redis：\n\n   ```\n   goCopy code\n   sudo make install\n   ```\n\n6. 创建 Redis 配置文件目录和配置文件：\n\n   ```\n   bashCopy code\n   sudo mkdir /etc/redis\n   sudo cp redis.conf /etc/redis\n   ```\n\n7. 修改 Redis 配置文件：\n\n   ```\n   bashCopy code\n   sudo nano /etc/redis/redis.conf\n   ```\n\n   找到 `bind` 行并将其注释掉，以允许远程访问 Redis：\n\n   ```\n   shellCopy code\n   # bind 127.0.0.1\n   ```\n\n   找到 `protected-mode` 行并将其改为 `no`，以允许远程访问 Redis：\n\n   ```\n   arduinoCopy code\n   protected-mode no\n   ```\n\n8. 启动 Redis 服务器：\n\n   ```\n   bashCopy code\n   redis-server /etc/redis/redis.conf\n   ```\n\n   如果出现错误，请查看 Redis 日志文件 `/var/log/redis.log`。\n\n现在你应该已经成功安装和启动了 Redis-3.2.8 服务器。你可以通过运行 `redis-cli` 命令来测试 Redis 是否可以正常工作。\n\n## 补充配置\n\n- 绑定ip：如果需要远程访问，可将此⾏注释，或绑定⼀个真实ip\n\n  > bind 127.0.0.1\n\n- 端⼝，默认为6379\n\n  > port 6379\n\n- 是否以守护进程运⾏\n\n  - 如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务\n  - 如果以⾮守护进程运⾏，则当前终端被阻塞\n  - 设置为yes表示守护进程，设置为no表示⾮守护进程\n  - 推荐设置为yes\n\n  > daemonize yes\n\n- 数据⽂件\n\n  > dbfilename dump.rdb\n\n- 数据⽂件存储路径\n\n  > dir /var/lib/redis\n\n- ⽇志⽂件\n\n  > logfile /var/log/redis/redis-server.log\n\n- 数据库，默认有16个\n\n  > database 16\n\n- 主从复制，类似于双机备份。\n\n  > slaveof\n\n## 加载配置启动时报错\n\n> 'logfile /var/log/redis/redis-server.log' Can't open the log file: Permission denied\n\n这个错误提示表明 Redis 没有权限在 `/var/log/redis/` 目录中创建日志文件。\n\n你可以按照以下步骤来解决这个问题：\n\n1. 确认 `/var/log/redis/` 目录是否存在，如果不存在，你可以通过以下命令创建它：\n\n   ```\n   bashCopy code\n   sudo mkdir /var/log/redis/\n   ```\n\n2. 确认 Redis 进程的运行用户是否有权限在该目录中创建文件。默认情况下，Redis 进程会使用 `redis` 用户来运行，而该用户通常没有权限在 `/var/log/redis/` 目录中创建文件。\n\n   如果你想让 `redis` 用户有权限在该目录中创建文件，可以通过以下命令更改该目录的所有者和组：\n\n   ```\n   bashCopy code\n   sudo chown redis:redis /var/log/redis/\n   ```\n\n   这将把 `/var/log/redis/` 目录的所有者和组都更改为 `redis`。\n\n   如果你不希望更改该目录的所有者和组，你可以考虑在 Redis 配置文件中指定其他的日志文件路径，例如 `/tmp/redis-server.log`：\n\n   ```\n   bashCopy code\n   logfile /tmp/redis-server.log\n   ```\n\n3. 如果你更改了 Redis 配置文件，记得重新启动 Redis 服务，以使更改生效：\n\n   ```\n   Copy code\n   sudo systemctl restart redis-server\n   ```\n\n如果你遇到了其他问题或错误，请查看 Redis 的日志文件和系统日志文件以获取更多信息。","tags":["Linux","Redis"],"categories":["中间件"]},{"title":"Mac安装Redis","url":"/2023/08/11/Mac安装Redis/","content":"要在Mac上安装`Redis`，请按照以下步骤进行操作：\n\n1. 打开终端应用程序\n\n2. 安装`Homebrew，Homebrew`是一个Mac上的包管理器。在终端中运行以下命令：\n\n   `/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"`\n<!-- more -->\n\n3. 安装`Redis`，运行以下命令：\n\n   `brew install redis`\n\n4. 启动`Redis`，运行以下命令：\n\n   `redis-server`\n\n5. （可选）如果您想在后台运行`Redis`，请使用以下命令：\n\n   `redis-server --daemonize yes`\n\n6. （可选）如果您想在每次启动Mac时自动启动`Redis`，请使用以下命令：\n\n   `brew services start redis`\n\n   `brew services stop redis `\n\n现在您已经成功地安装和启动了`Redis`。您可以在终端中使用`redis-cli`命令来连接到`Redis`服务器并进行交互式操作。","tags":["Redis","Mac"],"categories":["中间件"]},{"title":"实现公共字段的自动填充逻辑","url":"/2023/08/01/实现公共字段的自动填充逻辑/","content":"\n### 需要实现的效果\n公共字段自动填充\n* 问题分析\n* 实现思路\n* 代码开发\n* 功能测试\n\n### 问题分析\n多张业务表中的公共字段：\n\n**问题：代码冗余、不便于后期维护**\n<!-- more -->\n\n### 实现思路\n* 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法\n* 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值\n* 在 Mapper 的方法上加入 AutoFill 注解\n\n技术点：**枚举、注解、AOP、反射**\n\n### 代码开发\n* 自定义注解 AutoFill\n```Java\n/**\n * 自定义注解，用于标识需要进行公共字段的自动填充\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AutoFill {\n    // 数据操作类型 UPDATE、INSERT\n    OperationType value();\n}\n```\n\n* 自定义切面 AutoFillAspect\n```Java\n/**\n * 自定义切面，实现公共字段的自动填充逻辑\n */\n@Aspect\n@Component\n@Slf4j\npublic class AutoFillAspect {\n\n    /**\n     * 切入点\n     */\n    @Pointcut(\"execution(* com.sky.mapper.*.*(..))&& @annotation(com.sky.annotation.AutoFill)\")\n    public void autoFillPointCut() {\n    }\n\n    /**\n     * 前置通知，在通知中进行公共字段的赋值\n     */\n    @Before(\"autoFillPointCut()\")\n    public void autoFill(JoinPoint joinPoint) {\n        log.info(\"开始进行公共字段的自动填充。。。。。。\");\n    }\n\n}\n\n```\n\n* 完善自定义切面 AutoFillAspect 的 autoFill 方法\n```Java\nlog.info(\"开始进行公共字段的自动填充。。。。。。\");\n\n        // 获取到当前被拦截到的方法上的数据库操作类型\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法对象获取\n        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获取方法上的注解对象\n        OperationType operationType = autoFill.value();//获得数据库的操作类型\n\n        // 获取到当前被拦截方法的参数---实体对象\n        Object[] args = joinPoint.getArgs();\n        if (args == null || args.length == 0) {\n            return;\n        }\n        Object entity = args[0];\n\n        // 准备赋值的数据\n        LocalDateTime now = LocalDateTime.now();\n        Long currentId = BaseContext.getCurrentId();\n\n        // 根据当前不同的操作类型，为对应的属性通过反射来赋值\n        if (operationType == OperationType.INSERT) {\n            //为四个公共字段赋值\n            try {\n                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);\n                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);\n                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);\n                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);\n\n                //通过反射为对象属性赋值\n                setCreateTime.invoke(entity, now);\n                setCreateUser.invoke(entity, currentId);\n                setUpdateTime.invoke(entity, now);\n                setUpdateUser.invoke(entity, currentId);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        } else if (operationType == OperationType.UPDATE) {\n            //为二个公共字段赋值\n            try {\n                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);\n                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);\n\n                //通过反射为对象属性赋值\n                setUpdateTime.invoke(entity, now);\n                setUpdateUser.invoke(entity, currentId);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n```\n\n* 在Mapper接口的方法上加入 AutoFill 注解\n```Java\n /**\n     * 插入数据\n     *\n     * @param category\n     */\n    @Insert(\"insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)\" +\n            \" VALUES\" +\n            \" (#{type}, #{name}, #{sort}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})\")\n    @AutoFill(OperationType.INSERT)\n    void insert(Category category);\n\n/**\n     * 根据id修改分类\n     *\n     * @param category\n     */\n    @AutoFill(OperationType.UPDATE)\n    void update(Category category);\n```\n\n* 将业务层为公共字段赋值的代码注释掉\n\n### 功能测试\n通过观察控制台输出的SQL来确定公共字段填充是否完成","tags":["Spring Boot、AOP、注解"],"categories":["Java"]},{"title":"macbook上安装nginx和配置步骤","url":"/2023/07/27/macbook上安装nginx和配置步骤/","content":"\n## Nginx 笔记\n\n### 1. 安装 Homebrew\n\n在 Mac 上使用以下命令安装 Homebrew：\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n<!-- more -->\n### 2. 安装 Nginx\n\n在终端中运行以下命令来使用 Homebrew 安装 Nginx：\n\n```bash\nbrew install nginx\n```\n\n### 3. 查找 Nginx 配置文件路径\n\n```bash\nsudo find / -name \"nginx.conf\" 2>/dev/null\n```\n\n根据您的输出显示，Nginx 配置文件位于 `/opt/homebrew/etc/nginx/nginx.conf`。\n\n### 4. 查看 Nginx 配置文件\n\n```bash\nsudo cat /opt/homebrew/etc/nginx/nginx.conf\n```\n\n使用上述命令可以查看 Nginx 配置文件的内容，您可以在此文件中进行配置更改。\n\n### 5. 启动、停止和查看 Nginx 状态\n\n启动 Nginx 服务器：\n\n```bash\nsudo nginx\n```\n\n停止 Nginx 服务器：\n\n```bash\nsudo nginx -s stop\n```\n\n查看 Nginx 配置是否正确：\n\n```bash\nsudo nginx -t\n```\n\n查看 Nginx 运行状态：\n\n```bash\nsudo nginx -s status\n```\n\n### 6. 自动启动 Nginx\n\n如果希望 Nginx 在系统启动时自动运行，可以使用以下命令：\n\n```bash\nsudo brew services start nginx\n```\n\n### 7. 高级配置\n\nNginx 具有丰富的功能和选项，您可以根据需求进行高级配置。配置文件路径：`/opt/homebrew/etc/nginx/nginx.conf`\n\n以上是更新后的 Nginx 笔记，现在已经包含了 Homebrew 的安装记录。如果您有其他问题或需要进一步协助，请随时向我询问。\n\n### 8、html静态文件放在哪儿\n\n在使用 Homebrew 安装 Nginx 的情况下，Nginx 的默认根目录路径是 `/opt/homebrew/var/www` 而不是 `/usr/local/var/www`。因此，将 HTML 静态文件放置在正确的 Nginx 根目录下的步骤如下：\n\n1. 将您的 HTML 静态文件复制到 Nginx 根目录：\n\n```bash\ncp /path/to/your/html/files/* /opt/homebrew/var/www/\n```\n\n请将 `/path/to/your/html/files/` 替换为您实际存放 HTML 静态文件的路径。\n\n2. 在 `/opt/homebrew/etc/nginx/nginx.conf` 配置\n\n```bash\nlocation / {\n    root   /opt/homebrew/var/www/sky;\n    index  index.html index.htm;\n}\n````\n* `/opt/homebrew/var/www/` 静态文件配置路径\n* `sky`是我的项目\n\n3. 确认文件已成功复制到 Nginx 根目录：\n\n```bash\nls /opt/homebrew/var/www/\n```\n\n您应该能够看到您复制过来的 HTML 文件列表。\n\n4. 启动或重新加载 Nginx 以使更改生效：\n\n```bash\nsudo nginx -s stop  # 先停止 Nginx（如果已经运行）\nsudo nginx         # 再启动 Nginx\n```\n\n或者，您可以直接使用以下命令来重新加载 Nginx 配置：\n\n```bash\nsudo nginx -s reload\n```\n\n现在，您的 HTML 静态文件应该位于正确的 Nginx 根目录，可以通过 Nginx 服务器访问了。通过在浏览器中输入 `http://localhost`，您应该能够看到您的静态文件在浏览器中显示。\n\n请注意，如果您在 Nginx 配置中进行了自定义根目录设置，则根目录可能不是默认的 `/opt/homebrew/var/www`，而是您在配置中指定的目录。如果存在自定义根目录，请将 HTML 静态文件放置在自定义根目录下。","tags":["Nginx"],"categories":["服务器"]},{"title":"go的简介","url":"/2023/07/03/go的简介/","content":"### go的简介\nGo（也被称为Golang）是一种由Google开发的开源编程语言。Go的设计目标是提供简单、高效、可靠的编程体验，同时具备并发性和可扩展性。\n\n以下是Go语言的一些关键特点和优势：\n\n1. 简洁易学：Go语言采用了简洁的语法和设计，减少了冗余和复杂性，使其易于学习和上手。它拥有清晰的语法结构和直观的语义，使得编写和阅读代码变得简单。\n\n2. 并发编程：Go语言内置了轻量级的并发模型，通过goroutine和channel机制实现并发编程变得简单和高效。它使得编写并发代码变得容易，并能充分利用多核处理器的优势。\n<!-- more -->\n3. 高性能：Go语言通过优化编译器和运行时环境，以及并发原语的支持，提供了出色的性能。它具有低延迟、高吞吐量和高并发处理能力，适用于处理高负载和大规模应用。\n\n4. 内存安全：Go语言提供了垃圾回收机制，自动管理内存，减少了程序员的负担和错误。它还具有严格的类型安全性和内存安全性，有效地防止了一些常见的编程错误和安全漏洞。\n\n5. 跨平台：Go语言支持多种操作系统和架构，包括Windows、Linux、macOS等。你可以在不同的平台上编写一次代码，并在不需要修改的情况下进行编译和运行。\n\n6. 开发效率：Go语言的设计强调开发效率，提供了丰富的标准库和工具，使得开发人员能够快速构建可靠的应用程序。它还支持自动化测试、代码格式化和文档生成等功能，有助于提高团队的协作和代码质量。\n\n7. 开源生态系统：Go语言拥有活跃的开源社区和丰富的第三方库，你可以轻松地找到各种用于开发Web应用、数据库操作、网络编程、并发处理等方面的库和框架。\n\n由于上述特点和优势，Go语言在后端开发、云计算、容器技术、网络服务和分布式系统等领域得到了广泛的应用。它适合构建高性能、可扩展的应用程序，并在Google等大型科技公司以及许多初创企业中得到了广泛采用。\n\n### 能做什么世面上的岗位\nGo语言在世界上的工作市场上可以涵盖多个岗位和角色。以下是一些使用Go语言的常见岗位：\n\n1. 后端开发工程师：作为后端开发工程师，你可以使用Go语言构建高性能、可扩展的服务器端应用程序。你将负责设计和实现后端逻辑、处理数据存储和数据库操作，并与前端开发人员协作构建完整的应用。\n\n2. 分布式系统工程师：Go语言在构建分布式系统和微服务架构方面表现出色。作为分布式系统工程师，你可以使用Go语言开发和维护分布式应用程序、处理服务间通信和负载均衡等问题。\n\n3. DevOps工程师：Go语言具有强大的并发性和性能优势，因此在DevOps领域也有应用。作为DevOps工程师，你可以使用Go语言编写自动化脚本和工具，简化部署、监控和运维任务。\n\n4. 区块链开发工程师：Go语言在区块链开发领域也有广泛的应用。作为区块链开发工程师，你可以使用Go语言构建区块链节点、智能合约和分布式应用程序。\n\n5. 云原生工程师：Go语言在云原生技术中扮演重要角色。作为云原生工程师，你可以使用Go语言开发和管理容器化应用程序、使用云原生工具和框架，如Docker和Kubernetes。\n\n6. 系统工程师：Go语言的高性能和并发性使其成为开发系统级软件的理想选择。作为系统工程师，你可以使用Go语言构建操作系统组件、网络协议栈或高性能服务器。\n\n7. 后台服务开发工程师：许多公司和产品需要可靠的后台服务来支持业务逻辑和数据处理。作为后台服务开发工程师，你可以使用Go语言构建高吞吐量、低延迟的后台服务，处理请求和响应。\n\n这只是一些常见的岗位，使用Go语言的应用广泛。实际上，Go语言的简洁性、并发性和性能使其成为处理大规模应用和分布式系统的理想选择，因此在不同行业和领域中都有可能找到适合Go开发技能的岗位。","tags":["基础知识"],"categories":["Go"]},{"title":"ubuntu中安装的GoLAnd如何配置开发环境","url":"/2023/06/29/ubuntu中安装的GoLAnd如何配置开发环境/","content":"安装 GoLand IDE 并配置开发环境的步骤如下：\n\n1. 下载和安装 GoLand：前往 JetBrains 官方网站（https://www.jetbrains.com/go/）下载适用于 Linux 的 GoLand 安装包。解压下载的安装包，并进入解压后的目录。\n\n2. 启动 GoLand：在终端中进入 GoLand 安装目录的 `bin` 子目录，并运行以下命令启动 GoLand：\n\n   ```\n   ./goland.sh\n   ```\n<!-- more -->\n3. 配置 Go SDK：在首次启动 GoLand 时，它将提示您配置 Go SDK。选择 \"Configure\"，然后点击 \"Add SDK\" 按钮。\n\n   如果您尚未安装 Go SDK，可以选择 \"Download\" 选项自动下载并安装 Go SDK。或者，如果您已经手动安装了 Go SDK，请选择 \"Custom\" 选项并指定 Go SDK 的安装路径。\n\n4. 创建或导入项目：在 GoLand 中，您可以创建新的 Go 项目或导入现有的 Go 项目。根据您的需求选择适当的选项。\n\n5. 配置 GOPATH 和环境变量：在 GoLand 中打开 \"Settings\"（菜单栏中的 \"File\" -> \"Settings\"）。\n\n   在 \"Settings\" 对话框中，选择 \"Go\" -> \"Go Libraries\"。点击右上角的 \"+\" 按钮，添加您的项目目录作为 Go 项目的根目录。\n\n   接下来，选择 \"Go\" -> \"Go Modules\"，确保启用了 Go Modules 支持。如果您的项目使用 Go Modules，则可以手动初始化和下载依赖项。\n\n6. 运行和调试代码：在 GoLand 中，您可以使用内置的运行和调试工具来运行和调试您的 Go 代码。您可以使用菜单栏中的 \"Run\" 和 \"Debug\" 选项，或使用相应的快捷键来执行这些操作。\n\n这样，您就成功配置了 GoLand 的开发环境。您可以开始编写、运行和调试 Go 代码了。请注意，GoLand 是一款商业软件，您可能需要购买许可证才能使用其完整功能。您可以在 JetBrains 的网站上获取有关购买许可证的详细信息。\n","tags":["环境配置"],"categories":["Linux"]},{"title":"安装Go语言的集成开发环境（IDE）","url":"/2023/06/29/安装Go语言的集成开发环境（IDE）/","content":"\n要安装Go语言的集成开发环境（IDE），您可以考虑安装Visual Studio Code并使用Go插件来进行Go语言开发。以下是安装和配置步骤：\n\n1. 安装 Visual Studio Code：打开终端，运行以下命令以添加 Visual Studio Code 的官方存储库，并安装它：\n\n   ```\n   sudo apt update\n   sudo apt install code\n   ```\n<!-- more -->\n2. 打开 Visual Studio Code：在终端中运行以下命令来打开 Visual Studio Code：\n\n   ```\n   code\n   ```\n\n3. 安装 Go 插件：在 Visual Studio Code 中，点击左侧的扩展图标（四个方块组成的正方形），在搜索框中输入 \"Go\" 并找到 \"Go\" 插件。点击 \"安装\" 按钮安装该插件。\n\n4. 配置 Go 环境：为了在 Visual Studio Code 中正确地进行 Go 语言开发，您需要配置 Go 环境变量。打开终端，运行以下命令来编辑 `~/.bashrc` 文件：\n\n   ```\n   nano ~/.bashrc\n   ```\n\n   在文件末尾添加以下行，根据您的 Go 安装路径进行调整：\n\n   ```\n   export GOPATH=$HOME/go\n   export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin\n   ```\n\n   保存文件并关闭编辑器。然后运行以下命令使更改生效：\n\n   ```\n   source ~/.bashrc\n   ```\n\n5. 验证安装：重新启动 Visual Studio Code。在左侧的侧边栏中，点击扩展图标，找到 \"Go\" 插件并点击设置图标（齿轮图标）。在 \"Go: Gopath\" 选项中，选择您的 GOPATH 目录（默认为 `$HOME/go`）。\n\n   现在，您已经成功安装了 Visual Studio Code 和 Go 插件，并且可以在 Visual Studio Code 中进行 Go 语言开发。\n\n请注意，Visual Studio Code是一个通用的代码编辑器，可以支持多种编程语言和框架。通过安装适当的插件，您可以扩展其功能以支持其他编程语言和工具。","tags":["环境配置","go"],"categories":["Linux"]},{"title":"Ubuntu虚拟机中安装应用商店","url":"/2023/06/29/Ubuntu虚拟机中安装应用商店/","content":"如果您的Ubuntu虚拟机中没有应用商店，您可以尝试安装和使用其他的应用商店工具来获取和安装应用程序。以下是一些常见的应用商店工具：\n\n1. GNOME Software：GNOME Software是一个流行的图形化应用商店工具，适用于使用GNOME桌面环境的Ubuntu。打开终端，运行以下命令来安装GNOME Software：\n\n   ```\n   sudo apt update\n   sudo apt install gnome-software\n   ```\n\n   安装完成后，您可以在应用程序菜单中搜索并打开GNOME Software。通过GNOME Software，您可以浏览、搜索和安装各种应用程序。\n<!-- more -->\n2. Discover：Discover是KDE桌面环境的默认应用商店工具，适用于使用Kubuntu等基于KDE的Ubuntu变体。如果您使用的是KDE桌面环境，Discover可能已经预装在系统中。您可以在应用程序菜单中搜索并打开Discover。\n\n3. Deepin Software Center：Deepin Software Center是深度操作系统的默认应用商店工具，它也可以在其他Ubuntu发行版上使用。打开终端，运行以下命令来安装Deepin Software Center：\n\n   ```\n   sudo apt update\n   sudo apt install deepin-software-center\n   ```\n\n   安装完成后，您可以在应用程序菜单中搜索并打开Deepin Software Center。\n\n请注意，这些应用商店工具可能适用于特定的桌面环境或Ubuntu变体。根据您的系统和个人喜好，您可以选择安装适合您的应用商店工具。\n\n另外，您还可以尝试通过命令行来安装应用程序，如之前所述的使用`apt`命令或Snap来安装软件包。这些方法也可以帮助您获取和安装所需的应用程序。","tags":["环境配置"],"categories":["Linux"]},{"title":"ubuntu安装jdk1.8和jdk11","url":"/2023/06/29/ubuntu安装jdk1-8和jdk11/","content":"\n如果您需要在Ubuntu虚拟机上同时安装JDK 1.8和JDK 11，您可以按照以下步骤进行操作：\n\n1. 安装JDK 1.8：\n   打开终端，运行以下命令安装OpenJDK 8：\n\n   ```\n   sudo apt update\n   sudo apt install openjdk-8-jdk\n   ```\n\n   安装完成后，可以使用`java -version`命令验证安装的JDK版本。\n<!-- more -->\n2. 安装JDK 11：\n   打开终端，运行以下命令安装OpenJDK 11：\n\n   ```\n   sudo apt update\n   sudo apt install openjdk-11-jdk\n   ```\n\n   安装完成后，可以使用`java -version`命令验证安装的JDK版本。\n\n3. 配置默认JDK版本：\n   如果您需要将JDK 1.8或JDK 11设置为默认的Java版本，可以使用`update-alternatives`命令进行配置。运行以下命令选择默认的Java版本：\n\n   ```\n   sudo update-alternatives --config java\n   ```\n\n   系统将显示可用的Java版本列表，并要求您选择默认版本。根据提示输入相应的数字，然后按Enter键进行选择。\n\n现在，您的Ubuntu虚拟机已经同时安装了JDK 1.8和JDK 11，并且您可以根据需要选择默认的Java版本。","tags":["环境配置"],"categories":["Linux"]},{"title":"Error: CocoaPods's specs repository is too out-of-date to satisfy dependencies","url":"/2023/05/30/Error-CocoaPods-s-specs-repository-is-too-out-of-date-to-satisfy-dependencies/","content":"1. flutter clean\n2. delete /ios/Pods\n3. delete /ios/Podfile.lock\n4. flutter pub get\n5. from inside ios folder: pod install\n6. flutter run","tags":["Error"],"categories":["Flutter"]},{"title":"mac上已损坏，无法打开。 您应该将它移到废纸篓。解决方案","url":"/2023/04/14/mac上已损坏，无法打开。-您应该将它移到废纸篓。解决方案/","content":"\n* 1.首先先看你电脑的安全设置\n​\n如果没有设置任何来源，那把小锁打开，添加一下任何来源。在尝试安装\n*  2.如果还不行，在终端粘贴复制输入命令：“sudo xattr -r -d com.apple.quarantine ”（注意最后有一个空格），先不要按回车\n*  3.打开 “访达”（Finder）进入 “应用程序” 目录，找到该软件图标，将图标拖到刚才的终端窗口里面，会得到如下组合：“sudo xattr -r -d com.apple.quarantine /Applications/Bartender\\ 3.app”，回到终端窗口按回车，输入系统密码回车即可。\n完成","tags":["Error"],"categories":["工具"]},{"title":"mac下VMware安装Ubuntu设置允许在虚拟机与主机之间复制文字与文件","url":"/2023/04/03/mac下VMware安装Ubuntu设置允许在虚拟机与主机之间复制文字与文件/","content":"\n### 1、在终端执行如下三行命令\n```shell\nsudo apt-get autoremove open-vm-tools\nsudo apt-get install open-vm-tools\nsudo apt-get install open-vm-tools-desktop\n```\n### 2、重启 Ubuntu。","tags":["工具，虚拟机"],"categories":["Linux"]},{"title":"shell脚本提示 ll:command not found","url":"/2023/03/06/shell脚本提示-ll-command-not-found/","content":"shell脚本test.sh代码：\n\n```shell\n#!/bin/sh\n\n# 查看test目录下的文件列表\nll /test\n```\n执行报错：\n```shell\ntest.sh: line 3: ll: command not found\n```\n解决方法：\n```shell\n#!/bin/sh\n\n# 查看test目录下的文件列表\nls -l /test\n```","tags":["Error"],"categories":["Linux"]},{"title":"ImageView 中的 ScaleType 不起作用","url":"/2023/02/28/ImageView-中的-ScaleType-不起作用/","content":"我正在尝试使用 ViewPager展示Banner图片库。 viewpager 和图像检索一切正常。但是当我将位图放在 ImageView 中时，图像不会被拉伸以填充 ImageView 的大小。\n\n就是在设置imageview的scaleType属性的时候 无论怎么设置图片没有变化，后来猜想是图片的背景填充和src引用的区别 说白了就是background和src的关系，xml中或者是代码中设置图片的填充形式为background的话，那么imageview的scaletype是没有效果的。\n\n**设置了background了后，那么imageview的scaletype是没有效果的**\n\n","tags":["bug"],"categories":["Android"]},{"title":"Glide中Bug：宽度铺满高度自适应 & GIF加载之坑","url":"/2023/02/24/Glide中Bug：宽度铺满高度自适应-GIF加载之坑/","content":"## 一、前言：\nGlide圆角和centerCrop都是有问题的\n\n1. imageview自带的centerCrop是不管图片小于还是大于imageview的大小，都会等比例拉伸填充满，然后裁剪；\n2. 而Glide的centerCrop对于大图是裁剪，如果图片小于imageview，则是等比例全部显示在imageview里而不是填满裁剪;\n3. 而且如果imageview自己设置了centeCrop，这时候Glide再设置圆角，如果图片原图小于imageview，圆角是无效的\n\n**Glide 的基本使用**可以查看下面这些文章：\n\n[图片加载库Glide介绍](http://ocnyang.com/2016/08/09/GlideAbout/)\n\n[Glide图片加载库的使用](http://ocnyang.com/2016/08/17/GlideUse/)\n<!-- more -->\n\n*** \n\n## 二、Glide 实现 ImageView 宽度填满，高度自适应的效果\n先说一下大家在平时用到 ImageView 实现宽度填满，高度自适应的方法。\n\n> ImageView 宽度填满，高度自适应常用在：\n> 1. ListView 列表布局的条目中（RecycleView 同理），比如实现 item 中的图片充满屏幕，高度根据具体图片比例自适应，商品详情中常常用到。\n> 2. GridView 网格布局的条目中，假如 item 有两列，想让每一列的 item 中的图片占用屏幕的一半。\n> 3. 其他使用单独图片也想达到这种效果的场景。\n\n这里提供两种实现方法:\n### 1、重写 onMeasure 方法\n```java\n@SuppressLint(\"AppCompatCustomView\")\npublic class ResizableImageView extends ImageView {\n\n    private int value=0;\n\n    public ResizableImageView(Context context) {\n        super(context);\n    }\n\n    public ResizableImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){\n        Drawable d = getDrawable();\n        if(d!=null){\n            int width = MeasureSpec.getSize(widthMeasureSpec);\n            int height = width;\n            //高度根据使得图片的宽度充满屏幕计算而得（这个是默认计算）\n            //  int height = (int) Math.ceil((float) width * (float) d.getIntrinsicHeight() / (float) d.getIntrinsicWidth());\n            if (value==1){\n                 height = (int) Math.ceil((float) (width*4/3));\n            }\n            setMeasuredDimension(width, height);\n        }else{\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n\n    //根据传过来的值，1是宽度3：4，其它值是1：1\n    public void  setMeasure(int value){\n        this.value= value;\n    }\n}\n```\n### 2、设置 ImageView 的属性\n```java\n<ImageView\n        android:id=\"@+id/iv_ocnyang\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:adjustViewBounds=\"true\"\n        android:scaleType=\"fitXY\"\n        />\n```\n> `fitXY` 这种图片的显示方式的效果是：根据 `ImageView` 设置的大小拉伸图片以填充满空间，（单独设置此属性时）图片会变形。\n> \n>`adjustViewBounds` 是限制图片在显示时保持原图比例。（和 `fitXY` 显示方式合用能到达自适应的效果）\n***\n**通过这上面两种方式显示图片一般都能够宽度充满高度自适应的效果，可是当你用 Glide 请求显示网络图片的时候，你会很失望的发现上面的设置失效了同时图片也变形了。**\n***\n\n那么这时候是哪里出了问题了呢？（下面只做一个笼统的分析，具体可以看这个链接： [Glide使用及注意的地方](https://github.com/clarkehe/Android/wiki/Coding(7):-Glide%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9)）\n\n其实如果你熟知 Glide 的话，可能你还记得，Glide 在加载图片的时候，加载的大小会和 ImageView 的大小保持一致。也就是 ImageView 的大小决定了 Glide 加载图片的尺寸。而这里我们的 ImageView 设置的高度是 wrap_content，Glide 就无法准确的加载图片的大小了。\n\n那这个时候怎么才能保证按原图的比例来自适应高度显示呢？\n这里有两种方式：\n1. 你已经知道图片（或其他方式提前知道）图片的比例，然后在用 Glide 请求图片时限制图片的加载大小，即设置 override(int width, int height) 。这时候加载到的图片是原图比例，显示的时候虽然有拉伸/压缩但都会保存原比例的。这种方式适用于你加载的图片大小都比较规范固定的时候。\n\n2. 当然，你请求的图片源并不一定大小都一致。那这时候就可以使用下面这种方式了。这种方式的原理是，先使用 Glide 把图片的原图请求加载过来，然后再按原图来显示图片。\n```java\n    Glide.with(mContext)\n    .load(url)\n    .asBitmap()\n    .into(new SimpleTarget<Bitmap>() {\n    @Override\n    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap> glideAnimation) {\n    ivOcnyang.setImageBitmap(resource);\n    }\n    });\n````\n>这两种方法中，其实更加提倡的是第一种方式，因为这种方式不会造成任何负面的影响。但第二种方式，由于Glide加载图片时是以全分辨率加载的，当加载图片过大且图片很多时，可能造成 OOM。同时第二种方式使用在列表上复用时会造成条目错乱错位。\n***\n\n## 三、Glide 加载 Gif 图片的那些坑\n![](https://upload-images.jianshu.io/upload_images/2625875-9a044086b7de0a45.gif)\n\n###  1、加载 Gif 图片慢或者显示不出来\n\n这是一个公认的问题了，在 Glide 的 issue 上有人提出过，并且作者也给出了解决方案。\n加载 GIF 时需要调用 asGif() 方法，同时设置特别的缓存策略，调用 diskCacheStrategy() 将缓存策略设置为 SOURCE（缓存原图） 或者 NONE（不做缓存）。\n\n>Glide 在加载 GIF 时不调用 asGif() 方法也是能正常显示动画的。但建议调用 asGif()。\n\n```java\nif (imgUrl.toUpperCase().endsWith(\".GIF\")) {\n            Glide.with(mContext)\n                    .load(imgUrl)\n                    .asGif()\n                    .override(width, height)\n                    .placeholder(placeholderImg)\n                    .error(errorImg)\n                    .dontAnimate() //去掉显示动画\n                    .centerCrop()\n                    .diskCacheStrategy(DiskCacheStrategy.SOURCE) //DiskCacheStrategy.NONE\n                    .into(ivOcnyang);\n        } else {\n            Glide.with(mContext)\n                    .load(imgUrl)\n                    .override(width, height)\n                    .placeholder(placeholderImg)\n                    .error(errorImg)\n                    .crossFade()\n                    .centerCrop()\n                    .into(ivOcnyang);\n        }\n```\n[原文查看更多](http://events.jianshu.io/p/f05798900e3e)","tags":["bug"],"categories":["Android"]},{"title":"MacOS13 python3 报错 mach-o file, but is an incompatible architecture (have ‘arm64‘, need ‘x86_64‘)","url":"/2023/02/21/MacOS13-python3-报错-mach-o-file-but-is-an-incompatible-architecture-have-‘arm64‘-need-‘x86-64‘/","content":"\n解决方案：\n前面加上​​​arch -x86_64​​​ 例如：\n​​arch -x86_64 pip3 install Pillow​​​​arch -x86_64 pip3 install numpy​​\n","tags":["Error"],"categories":["Python"]},{"title":"Android开发中的常见错误：Duplicate class","url":"/2023/02/21/Android开发中的常见错误：Duplicate-class/","content":"\n## android开发Duplicate class编译出现类重复问题的定位以及解决方法\n\n>Task :app:checkReleaseDuplicateClasses FAILED\n\n>Duplicate class com.google.common.util.concurrent.ListenableFuture found in modules jetified-guava-20.0 (com.google.guava:guava:20.0) and jetified-listenablefuture-1.0 (com.google.guava:listenablefuture:1.0)\n```\n\n### 解决方法：\n\n    1. Navigation -> Search Everywhere，勾选Include non-project items进行全局搜索\n    2. 比如搜索com.google.guava就可以搜索出所有的有关的依赖库\n    3. ./gradlew app:dependencies查看找出依赖库之间的关系(在gradle中执行)\n    4. 找到有关的依赖库xxx:xx:x\n    ```\n        implementation(\"xxx:xx:x\") {\n            exclude group: 'com.google.guava'\n        }\n        或者android配置区域配置全部库排查如下：\n        configurations.all {\n            exclude group: 'com.google.guava', module:'listenablefuture'\n        }\n    ```\n\n### zsh: permission denied: ./gradlew\n```\n运行: chmod +x gradlew\n```","tags":["bug"],"categories":["Android"]},{"title":"LinuxDeploy下ping命令无法运行,提示socket:权限不足","url":"/2022/10/30/LinuxDeploy下ping命令无法运行-提示socket-权限不足/","content":"```vim\nping命令需要SUID权限的\n检查以下它的权限位是否是-rwsr-xr-x，并且owner是root\n如果没有那个s，\n# chmod u+s /bin/ping\n如果owner不是root\n# chown root /bin/ping\n```","tags":["命令","Linux"],"categories":["网络"]},{"title":"Python资料地址收集","url":"/2022/10/23/Python资料地址收集/","content":"\n### 基础\n\n#### 基础学习地址\n* [Python中文版风格规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/)","tags":["基础"],"categories":["Python"]},{"title":"OkHttp和retrofit网络框架实现架构基础原理","url":"/2022/09/26/OkHttp和retrofit网络框架实现架构基础原理/","content":"\n![](https://markchyl.cn/img/WechatIMG54.jpeg)","tags":["网络编程"],"categories":["Android"]},{"title":"线程与线程池开发核心技术","url":"/2022/09/16/线程与线程池开发核心技术/","content":"## 线程与线程池开发核心技术\n[TOC]\n\n[印象笔记链接](https://app.yinxiang.com/shard/s50/nl/22109192/3ae4db9a-df06-457f-966f-da2bd19bdeed/)\n\n\n### 线程与进程\n\n* 一个进程至少一个线程 \n* 进程可以包含多个线程 \n* 进程在执行过程中拥有独立的内存空间，而线程运行在进程内\n\n<!-- more -->\n### 线程的几种创建方式\n\n* `new Thread`：可复写`Thread#run`方法。也可传递`Runnable`对象，\n    * 更加灵活。 \n    * 缺点：缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或`oom`\n\n```java\n//传递Runnable对象 \n1.new Thread(new Runnable(){\n    .....\n}).start()\n\n//复写Thread#run方法\n2.class MyThread extends Thread{ \n        public void run(){ \n                .... \n        }\n  }\n  new MyThread().start()\n```\n* AysncTask,轻量级的异步任务工具类,提供任务执行的进度回调给UI线程\n    -  场景：需要知晓任务执行的进度,多个任务串行执行 \n    -  缺点：生命周期和宿主的生命周期不同步,有可能发生内存泄漏,默认情况所有任务串行执行\n    \n```java\n    class MyAsyncTask extends AsyncTask {\n    private static final String TAG = \"MyAsyncTask\"; \n    \n    @Override \n    protected String doInBackground(String... params) { \n        for (int i = 0; i < 10; i++) {\n            publishProgress(i * 10); \n        }\n        return params[0];\n    } \n    \n    @Override \n    protected void onPostExecute(String result) {\n            Log.e(TAG, \"result: \" + result); \n    } \n    \n    @Override\n    protected void onProgressUpdate(Integer... values) {\n            Log.e(TAG, \"onProgressUpdate: \" + values[0].intValue()); \n    } \n } \n // #1 子类复写方法 \n AsyncTask asyncTask = new MyAsyncTask(); \n //AsyncTask所有任务默认串行执行 \n asyncTask.execute(\"execute MyAsyncTask\"); \n or \n asyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,\"execute MyAsyncTask\") // #2 使用#execute方法，同样串行执行 \n AsyncTask.execute(new Runnable() {\n        @Override public void run() {\n            ...... \n         }\n  });\n  // #3 使用内置THREAD_POOL_EXECUTOR线程池 并发执行 \n  AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() { \n            @Override public void run() {\n            } \n  });\n ```\n    \n* HandlerThread,适用于主线程需要和工作线程通信,适用于持续性任务,比如轮训的场景，所有任务串行执行 \n* 缺点:不会像普通线程一样主动销毁资源，会一直运行着，所以可能会造成内存泄漏\n\n````java\nHandlerThread thread = new HandlerThread(\"concurrent-thread\"); \nthread.start(); \nThreadHandler handler = new ThreadHandler(thread.getLooper()) { \n    @Override \n    public void handleMessage(@NonNull Message msg) { \n        switch (msg.what) {\n            case MSG_WHAT_FLAG_1: \n                break;\n            }\n         } \n     }; \nhandler.sendEmptyMessage(MSG_WHAT_FLAG_1); \nhread.quitSafely();\n\n//定义成静态,防止内存泄漏 \nstatic class ThreadHandler extends Handler{ \n    public ThreadHandler(Looper looper){ \n        super(looper)\n    } \n}\n````\n* IntentService,适用于我们的任务需要跨页面读取任务执行的进度，结果。比如后台上传图片，批量操作数据库等。任务执行完成功后，就会自我结束，所以不需要手动stopservice,这是他跟service的区分 \n\n\n```java\nclass MyIntentService extends IntentService{ \n@Override protected void onHandleIntent(@Nullable Intent intent) { int command = intent.getInt(\"command\") ...... } } context.startService(new Intent())\n```\n\n\n* ✨ThreadPoolExecutor:适用快速处理大量耗时较短的任务场景 \n```java\nExecutors.newCachedThreadPool();//线程可复用线程池\nExecutors.newFixedThreadPool();//固定线程数量的线程池 \nExecutors.newScheduledThreadPool();//可指定定时任务的线程池 \nExecutors.newSingleThreadExecutor();//线程数量为1的线程池\n```","tags":["Android","线程"],"categories":["Android"]},{"title":"Android如何进行技术选型（案列：Navigation组件和ARouter为例）","url":"/2022/09/16/Android如何进行技术选型（案列：Navigation组件和ARouter为例）/","content":"## 案列：Navigation组件和ARouter为例\n[TOC]\n\n[我的Demo：](https://gitee.com/markshow/hirouter)涵盖了两大路由的基础使用\n\n### 如何做好技术选型？\n\n![](https://markchyl.cn/img/OPlayer_2022-07-12_18-19-20.jpg)\n### 什么是路由？\n* 页面间跳转关系映射，可以通过字符串、别名等方式实现跳转\n### 为什么介入路由？Intent不好吗？\n\n**Intent**\n\n* 跳转过程无法控制，一旦调用了startActivity(Intent)便交由系统执行，中间过程无法插手\n* 跳转失败无法捕获、降级，出现问题直接抛出异常\n* 显示Intent\n    显示Intent中因为存在直接的类依赖关系，导致耦合严重\n* 隐式Intent\n隐式Intent中会出现规则集中式的管理，导致协作困难，都需要在Manifest中进行配置，导致扩展性比较差\n### 对比两大路由组件的功能对照表\n\n|  | Navigation | ARouter |\n| --- | --- | --- |\n| 跳转行为 | 通过页面的action跳转，支持Activity，Fragment，Dialog |  支持标准URL跳转|\n| 模块间通信 | 不支持，需要将所有页面定义在一个资源文件里 | @Route注解配置，根据Path获取对应的接口实现 |\n| 路由节点注册 | 统一在navigation_mobile.xml中注册 | @Route注解 |\n| 路由节点的生成方式 | 加载navigation_mobile.xml生成NavGraph导航视图 | 按照组划分 |\n| 拦截器 | 不支持 | 支持全部定义拦截器，可以自定义拦截顺序 |\n| 转场动画 | 支持 | 支持 |\n| 降级策略 | 不支持 | 支持全局降级和局部降级 |\n| 参数自动注入 | 不支持 | @Autowired注解实现 |\n| 外部跳转控制（h5打开app页面） | deeplink页面直达 | 需要配置入口Activity，支持的uri需要在Manifest中配置|\n\n### 总结\n**ARouter主要是用于Activity路由的框架，采用的是APT技术，可用于组件化改造。而Navigation主要是用于Fragment路由导航的框架。**\n> 可以说，这两个虽然都是用于路由导航，但是用途是不一样。如果你的应用主要以Acticity为主的话，建议使用ARouter；如果你的页面主要以Fragment为主，Activity只是作为容器的话，那么建议你使用Navigation。当然，你也可以两个都用，这完全取决于你的项目实际情况，不冲突的。\n \n[Android中APT技术介绍](https://app.yinxiang.com/shard/s50/nl/22109192/56fe3693-8eb4-4574-a55b-a42851e4e89c/)","tags":["Android","架构师"],"categories":["Android"]},{"title":"Android中APT技术介绍","url":"/2022/09/16/Android中APT技术介绍/","content":"## Android中APT技术介绍\n[TOC]\n### APT是什么\n`APT` 全称 ```Annotation Processing Tool```，即注解处理器，是javac的一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，并根据注解自动生成代码，帮助开发者减少了很多重复代码的编写。\n### 例子\n很多著名的框架用到APT的思想，通过注解编译期间自动生成代码，简化使用\n\n1. `Butterknife`\n2. `Dragger`\n3. `Room`\n\n另外，还有是运行时注解，例如\n1. `Retrofit`\n\n### APT有什么用 （好处）\n可以在编译时生成额外的.java文件，在程序运行的时候调用相关方法，可以达到减少重复代码的效果。它的好处：提高开发效率，使得项目更容易维护和扩展，同时几乎不影响性能。\n### APT原理 （为什么）\n通过APT（Annotation Processing Tool）技术，即注解处理器，在编译时扫描并处理注解，注解处理器最终生成处理注解逻辑的.java文件。\n### APT实践 （怎么做）\n1. 创建自定义注解@interface；\n2. 创建并注册注解处理器AbstractProcesso，生成处理注解逻辑的.java文件；\n3. 封装一个供外部调用的API，用的是反射技术，具体来说就是调用第二步中生成的代码中的方法；\n4. 在业务代码中使用，比如Activity、Fragment、Adapter\n\n#### 参考\n1. [Android编译时注解–入门篇（AbstractProcessor、APT）](https://www.jianshu.com/p/b5be6b896a1a)\n2. [你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解](https://blog.csdn.net/xx326664162/article/details/68490059)\n3. [Android 注解系列之APT工具](https://juejin.cn/post/6844903701283340301)\n4. [Android 利用 APT 技术在编译期生成代码](https://blog.csdn.net/hb707934728/article/details/52213086)\n5. [Android注解处理器APT技术简介](https://blog.csdn.net/biaozhiyuan/article/details/117045125)","tags":["Android","APT"],"categories":["Android"]},{"title":"实战：基于ARouter实现登陆拦截&全局降级策略","url":"/2022/09/16/实战：基于ARouter实现登陆拦截-全局降级策略/","content":"##  实战：基于ARouter实现登陆拦截&全局降级策略\n\n* 需求分析\n* 成果展示\n* 疑难点分析\n* Coding实现\n### 需求分析\n  \n\n* * *\n\n\n  * 利用ARouter拦截页面跳转，实现全局页面降级\n<!-- more -->\n### Coding\n1、引入Arouter组件到项目中\n````\n\nandroid {\n    defaultConfig {\n        ...\n        javaCompileOptions {\n            annotationProcessorOptions {\n                arguments = [AROUTER_MODULE_NAME: project.getName()]\n            }\n        }\n    }\n}\n\n\n\ndependencies {\n    // 替换成最新版本, 需要注意的是api\n    // 要与compiler匹配使用，均使用最新版可以保证兼容\n    compile 'com.alibaba:arouter-api:x.x.x'\n    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'\n    ...\n}\n// 旧版本gradle插件(< 2.2)，可以使用apt插件，配置方法见文末'其他#4'// Kotlin配置参考文末'其他#5'\n\n```\n\n\n### 一、功能介绍\n\n1. 支持直接解析标准URL进行跳转，并自动注入参数到目标页面中\n2. 支持多模块工程使用\n3. 支持添加多个拦截器，自定义拦截顺序\n4. 支持依赖注入，可单独作为依赖注入框架使用\n5. 支持InstantRun\n6. 支持MultiDex(Google方案)\n7. 映射关系按组分类、多级管理，按需初始化\n8. 支持用户指定全局降级与局部降级策略页面、拦截器、服务等组件均自动注册到框架\n9. 支持多种方式配置转场动画\n10. 支持获取Fragment\n11. 完全支持Kotlin以及混编(配置见文末 其他#5)\n12. 支持第三方 App 加固(使用 arouter-register 实现自动注册)\n13. 支持生成路由文档\n14. 提供 IDE 插件便捷的关联路径和目标类支持增量编译(开启文档生成后无法增量编译)\n15. 支持动态注册路由信息\n\n### 二、典型应用\n1. 从外部URL映射到内部页面，以及参数传递与解析\n2. 跨模块页面跳转，模块间解耦拦\n3. 截跳转过程，处理登陆、埋点等逻辑\n4. 跨模块API调用，通过控制反转来做组件解耦","tags":["Android","实战"],"categories":["Android"]},{"title":"implementation、api、compileOnly区别","url":"/2022/09/16/implementation、api、compileOnly区别/","content":"### 2.x和3.x版本依赖方式比较\n|2.x|3.x|\n|-|-|\n|compile|implementation、api|\n|provided|compile only|\n|apk|runtime only|\n|api|api|\n\n### 替代关系：\n* compile依赖关系已被弃⽤，被implementation和api替代;\n* provided被compile only替代;\n* apk被runtime only替代;\n* api：跟2.x版本的 compile完全相同。\n  \n<!-- more -->\n### implementation和api区别：\n> implementation：只能在内部使⽤此模块，⽐如我在⼀个libiary中使⽤implementation依赖了gson库，然后我的主项⽬依赖了libiary，那么，我的主项⽬就⽆法访问gson库中的⽅法。这样的好处是编译速度会加快，推荐使⽤implementation的⽅式去依赖，如果你需要提供给外部访问，那么就使⽤api依赖即可\n\n### provided（compileOnly）作⽤：\n> 只在编译时有效，不会参与打包可以在⾃⼰的moudle中使⽤该⽅式依赖⼀些⽐如com.android.support，gson这些使⽤者常⽤的库，避免冲突。\n\n### apk（runtimeOnly）作⽤：\n> 只在⽣成apk的时候参与打包，编译时不会参与，很少⽤。\n\n### testCompile（testImplementation）作⽤：\n > testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。\n\n### debugCompile（debugImplementation）作⽤：\n> debugCompile 只在debug模式的编译和最终的debug apk打包时有效\n\n### releaseCompile（releaseImplementation）作⽤：\n> Release compile 仅仅针对Release 模式的编译和最终的Release apk打包。\n","tags":["Android"],"categories":["Android"]},{"title":"Android studio开启阿里巴巴资源仓库代理","url":"/2022/09/16/Android-studio开启阿里巴巴资源仓库代理/","content":"```java\nrepositories {\n    maven {\n        //解决 gradle.build 仓库更换为阿里云仓库后报错\n        allowInsecureProtocol = true\n        //阿里云仓库\n        url 'http://maven.aliyun.com/nexus/content/groups/public/'\n    }\n   。。。。。。\n}\n```","tags":["Android"],"categories":["Android"]},{"title":"实现本地资源包统一管理nexus","url":"/2022/09/16/实现本地资源包统一管理nexus/","content":"通过终端命令 cd /Users/xxx/Downloads/nexus-3.14.0-04-mac/nexus-3.14.0-04/bin进入bin目录下，执行\n./nexus start\n./nexus status\n\n\n上传示例：\n\napply plugin: 'maven'\n\n//打包main目录下代码和资源的task\ntask androidSourcesJar(type: Jar) {\n    classifier = 'sources'\n    from android.sourceSets.main.java.srcDirs\n}\n//配置需要上传到maven仓库的文件\nartifacts {\n    archives androidSourcesJar\n}\n//上传到Maven仓库的task\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            //指定maven仓库url\n            repository(url: \"http://127.0.0.1:8081/nexus/content/repositories/releases/\") {\n                //nexus登录默认用户名和密码\n                authentication(userName: \"admin\", password: \"admin123\")\n            }\n            pom.groupId = \"com.example.as.custom\"// 唯一标识（通常为模块包名，也可以任意）\n            pom.artifactId = \"CustomWidget\" // 项目名称（通常为类库模块名称，也可以任意）\n            pom.version = \"1.1.0\" // 版本号\n        }\n    }\n}\n\n3.使用：\n和使用本地仓库依赖一样，我们告诉gradle依赖包仓库的位置，在项目根目录下build.gradle中添加：\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        maven { url 'http://127.0.0.1:8081/nexus/content/repositories/releases/' }\n    }\n}\n\n然后在app模块build.gradle中添加依赖编译运行成功：","tags":["Android"],"categories":["Android"]},{"title":"Java 面试题","url":"/2022/07/23/Java-面试题/","content":"[TOC]\n### 2、`List`和`Set`的区别\n  **List和Set都是继承自Collection接口**\n  *  List特点：元素有放入顺序，元素可重复。和数组类似，List可以动态增长，查找元素效率高，但是插入和删除元素的效率低\n  *  Set特点： 元素无放入顺序，元素不可以重复，重复元素会被覆盖掉。查找检索元素效率低，但是删除和插入效率高\n\n### 3、HashSet是如何保证元素不重复的？\n向`HashSet`中`add()`元素时，判断元素是否存在的依据，不仅要比较`hash`值，同时还要结合`equeals`方法比较。\n`HashSet`中的`add()`方法会使用`HashMap`的`add()`方法。\n```java\n  private static final Object PRESENT = new Object();\n  private transient HashMap<E,Object> map;\n  public HashSet(){\n    map = new HashMap<E, Object>();\n  }\n  public boolean add(E e){\n    return map.put(e,PRESENT)==null;\n  }\n```","tags":["基础，面试题"],"categories":["Java"]},{"title":"Mac安装mysql-8.0.27","url":"/2021/11/03/Mac安装mysql-8-0-27/","content":"### 我的环境：\n*  MacOs Big Sur 版本11.6\n*  mysql-8.0.27-macos11-x86_64.dmg\n\n### 下载安装\n\n版本一定要下对，我踩过坑，\n\n![](https://markchyl.cn/img/20180123204406478.png)\n\n如图所示来查找对应系统安装版本，\n[官网下载地址是](https://dev.mysql.com/downloads/mysql/)\n\n### 配置环境变量\n打开终端\n输入：cd /usr/local/mysql，回车执行\n然后输入：sudo vim .bash_profile，回车执行\n```\n<!-- more -->\n#mysql环境变量\nexport MYSQL_HOME=/usr/local/mysql\nexport PATH=${MYSQL_HOME}/bin:$PATH\n```\n记得`source ~/.bash_profile`让环境变量生效。\n\n最后使用输入mysql命令`mysql -u root -p`，即可使用。","tags":["mysql"],"categories":["数据库"]},{"title":"从Mac系统中卸载MySql","url":"/2021/11/03/从Mac系统中卸载MySql/","content":"[原文](https://blog.csdn.net/lancegentry/article/details/79144131)\n\n```\nsudo rm /usr/local/mysql\nsudo rm -rf /usr/local/mysql*\nsudo rm -rf /Library/StartupItems/MySQLCOM\nsudo rm -rf /Library/PreferencePanes/MySQL*\nsudo rm -rf ~/Library/PreferencePanes/MySQL*\nsudo rm -rf /Library/Receipts/mysql*\nsudo rm -rf /Library/Receipts/MySQL*\n```\n最后删除/etc/hostconfig文件中的  MYSQLCOM=-YES-\n\n这个选项有些用户有，有些没有\n\n最后如果系统偏好设置中没有了MySql证明卸载成功","tags":["mysql"],"categories":["数据库"]},{"title":"Mac安装和配置Tomcat的教程","url":"/2021/11/02/Mac安装和配置Tomcat的教程/","content":"[原文](https://blog.csdn.net/dongzhensong/article/details/87807378)\n### 我的配置\n* MacBook Pro\n* jdk1.8\n### 1.下载\n前往[ApacheTomcat](https://tomcat.apache.org/download-80.cgi)官网下载Tomcat：\n![](https://img-blog.csdnimg.cn/20190220165426253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rvbmd6aGVuc29uZw==,size_16,color_FFFFFF,t_70)\n首先选择相应的版本（以Tomcat 8为例）：\n下载右边Core下的第一个资源zip。\n下载后解压下来重名名为ApacheTomcat，并放到磁盘的/usr/local下\n![](https://img-blog.csdnimg.cn/20190220165752464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rvbmd6aGVuc29uZw==,size_16,color_FFFFFF,t_70)\n<!-- more -->\n### 2.启动服务\n打开终端.app，切换路径到ApacheTomcat的bin目录下并执行启动文件：\n```\nmark@localhost bin % cd /usr/local/tomcat/bin\nmark@localhost bin % ./startup.sh \n```\n如果提示Permission denied:那是因为没有.sh的权限。\n```\nchmod u+x *.sh\n```\n再次执行 startup.sh 即可启动服务\n```\nmark@localhost bin % ./startup.sh \nUsing CATALINA_BASE:   /usr/local/tomcat\nUsing CATALINA_HOME:   /usr/local/tomcat\nUsing CATALINA_TMPDIR: /usr/local/tomcat/temp\nUsing JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home\nUsing CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar\nUsing CATALINA_OPTS:   \nTomcat started.\n```\n在浏览器中访问 http://localhost:8080 即可看到提示：\n### 3. 修改使用的端口号\n如果使用的端口号8080不能使用，可通过修改conf文件下的server.xml配置文件来使用其他端口：\n![](https://img-blog.csdnimg.cn/20190220171236981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rvbmd6aGVuc29uZw==,size_16,color_FFFFFF,t_70)\n**重新启动服务**\n```\n$ ./shutdown.sh\n\n$ ./startup.sh\n```\n### 4. 配置Tomcat应用管理GUI用户\n打开conf文件夹下的tomcat-users.xml 添加一个用户：\n```\n<role rolename=\"manager-gui\"/>\n<user username=\"tomcat\" password=\"s3cret\" roles=\"manager-gui\"/>\n```\n![](https://img-blog.csdnimg.cn/20190220174027195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rvbmd6aGVuc29uZw==,size_16,color_FFFFFF,t_70)\n重新启动服务，访问 http://localhost:8090 , 点击Manager App：\n用户名与密码即刚设置的 tomcat 与 s3cret\n![](https://img-blog.csdnimg.cn/20190220174431882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rvbmd6aGVuc29uZw==,size_16,color_FFFFFF,t_70)","tags":["Tomcat"],"categories":["JavaWeb"]},{"title":"Mac中终端关机命令","url":"/2021/11/02/Mac中终端关机命令/","content":"\n[原文来自](https://blog.51cto.com/59465168/1837538)\n1.立即关机命令 \n        sudo halt \n    或者 \n        sudo shutdown -h now \n \n2. 10分钟后关机 \n   sudo shutdown -h +10 \n \n3. 晚上8点关机 \nsudo shutdown -h 20:00 \n \n4. 立即重启 \n    sudo reboot  \n    或者 \n    sudo shutdown -r now\n\n5.设定时间为2012年7月12日15：00分关机,命令为：\n    sudo shutdown -h 1207121500 \n同理： \n    2014年7月11日15：00分重启,命令：\n    sudo shutdown -r 1407111500 \n 命令的主体位：shutdown（关闭） \n     h/r/s -->分别代表：关机/重启/睡眠。 \n 最后加上时间就可行了。","tags":["运维"],"categories":["Mac"]},{"title":"mac上使用svn(subversion)","url":"/2021/10/09/mac上使用svn-subversion/","content":"[原文：Wanna_1314](https://www.jianshu.com/p/79116c6f8f72)\n### 简介\n在Windows中，我们常用TortoiseSVN这个软件来进行搭建SVN环境，那么在macOS中，我们应当如何去搭建SVN环境呢？在以前的老版本的macOS中，macOS中Xcode已经为我们提供了SVN的服务端和客户端。但是在如今的新版本当中，已经没有SVN了，我们可以使用Homebrew进行安装SVN。\n\n### 1.安装\n如何安装呢？我们使用Homebrew进行安装，关于Homebrew的安装，可以从参考我往期的文章，下面直接讲述安装之后的安装命令\n```\nbrew install subversion\n```\n我们使用如下的命令进行检查是否安装了这个软件\n```\nbrew list\n```\n得到如下的结果\n![](https://upload-images.jianshu.io/upload_images/24412352-77bcc086d7bbdce9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1170/format/webp)\n使用\n```\nsvn help\n```\n命令查看svn是否可以全局访问，如图所示，则安装成功！\n![](https://upload-images.jianshu.io/upload_images/24412352-e47e3ebfa90a4882.png?imageMogr2/auto-orient/strip|imageView2/2/w/1158/format/webp)\n\n### 2.安装之后的配置\n使用如下命令创建一个SVN的代码仓库（目录改成你想要创建的目录）\n```\nsvnadmin create /Users/wanna/Desktop/Code/SVN\n```\n**当然我的电脑上自动给我创建了**\n`/Users/mark/.subversion`\n以下不多赘述，结合原文查看。","tags":["工具使用"],"categories":["工具使用"]},{"title":"mac 安装homebrew","url":"/2021/10/09/mac-安装homebrew/","content":"问题：macOS安装Homebrew时总是报错（Failed to connect to raw.githubusercontent.com port 443: Connection refused）\n\n原因：由于某些你懂的因素，导致GitHub的raw.githubusercontent.com域名解析被污染了。\n\n解决办法：通过修改hosts解决此问题。\n查询真实IP\n\n在https://www.ipaddress.com/查询raw.githubusercontent.com的真实IP。\n![](https://imgconvert.csdnimg.cn/aHR0cDovL29zY2ltZy5vc2NoaW5hLm5ldC9vc2NuZXQvdXAtNzMwZGI4MDg5OGIzYmI5NzU2NDdlOTk1NzViZTEyZWY4N2EucG5n?x-oss-process=image/format,png)\n修改hosts\n```linux\nsudo vim /etc/hosts\n```\n添加如下内容：\n```\n199.232.28.133 raw.githubusercontent.com\n```\n可以使用国内源啦\n```\n/bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\"\n```","tags":["工具使用"],"categories":["工具使用"]},{"title":"Centos7 配置ssh免密登陆以及遇到的问题","url":"/2021/09/17/Centos7-配置ssh免密登陆以及遇到的问题/","content":"假设用户名为**u**：\n* 1.确认已经连接上互联网，然后输入命令：\n  `sudo apt-get install ssh`\n* 2.配置为可以免密码登录本机。首先查看在u用户下是否存在.ssh文件夹（注意ssh前面有“.”，这是一个隐藏文件夹），输入命令：\n    `ls –a /home/u`\n\n    >一般来说，安装SSH时会自动在当前用户下创建这个隐藏文件夹，如果没有，可以手动创建一个。\n\n* 3.接下来，输入命令（注意下面命令中不是双引号，是两个单引号）：\n`ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa`\n\n>解释一下，ssh-keygen代表生成密钥；-t（注意区分大小写）表示指定生成的密钥类型；dsa是dsa密钥认证的意思，即密钥类型；-P用于提供密语；-f指定生成的密钥文件。\n\n>在Linux系统中，~代表当前用户文件夹，此处即/home/u。\n\n>这个命令会在.ssh文件夹下创建id_dsa及id_dsa.pub两个文件，这是SSH的一对私钥和公钥，类似于钥匙和锁，把id_dsa.pub（公钥）追加到授权的key中去。\n输入命令:\n\n`cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys`\n\n这条命令的功能是把公钥加到用于认证的公钥文件中，这里的authorized_keys是用于认证的公钥文件。\n\n至此免密码登录本机已配置完毕。\n\n* 4.验证SSH是否已安装成功，以及是否可以免密码登录本机。\n输入命令：\n\nssh –version\n\n显示结果：\n\nOpenSSH_5.8p1 Debian-7ubuntu1, OpenSSL 1.0.0e 6 Sep 2011\n\nBad escape character 'rsion'.\n\n显示SSH已经安装成功了。\n\n输入命令：\n`ssh localhost`\n会有如下显示：\n```\nThe authenticity of host 'localhost (::1)' can't be established.\nRSA key fingerprint is 8b:c3:51:a5:2a:31:b7:74:06:9d:62:04:4f:84:f8:77.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added 'localhost' (RSA) to the list of known hosts.\nLinux master 2.6.31-14-generic #48-Ubuntu SMP Fri Oct 16 14:04:26 UTC 2011 i686\nTo access official Ubuntu documentation, please visit:\nhttp://help.ubuntu.com/\nLast login: Sat Feb 18 17:12:40 2012 from master\n```\n第一次登录时会询问是否继续链接，输入yes即可进入。","tags":["网络配置"],"categories":["Linux"]},{"title":"mac下安装rz sz","url":"/2021/09/17/mac下安装rz-sz/","content":"我们在linux上部署代码的时候经常需要上传文件到linux，有时候也需要从linux上下载文件到本地，大部分人都直接借助于ftp工具，\n然而其实我们可以直接通过rz和sz上传下载文件，但是rz和sz命令不是linux默认自带的命令，需要我们自己安装，那么如何安装呢\n\n### 手动安装\n* 下载lrzsz安装包\n`wget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz `\n* 解压并切换到lrzsz-0.12.20目录下面\n`tar zxvf lrzsz-0.12.20.tar.gz && cd lrzsz-0.12.20`\n* 编译\n  切换到文件解压目录下，在终端中执行如下命令编译\n  `./configure && make && make install`\n* 上面安装过程默认把lsz和lrz安装到了/usr/local/bin/目录下，现在我们并不能直接使用，下面创建软链接，并命名为rz/sz：\n    ```\n    cd /usr/bin\n    ln -s /usr/local/bin/lrz rz\n    ln -s /usr/local/bin/lsz sz\n    ```\n### yum命令安装\n    yum -y install lrzsz\n\n### 使用：\n    sz -y 下载\n    rz -y 上传","tags":["工具"],"categories":["Linux"]},{"title":"Linux下删除文件名带有空格的文件","url":"/2021/09/16/Linux下删除文件名带有空格的文件/","content":"1.使用单引号将文件名括起来进行操作；\n\n`rm '2018-08-07 17-29-48.png'`","tags":["Error"],"categories":["Linux"]},{"title":"Android面试知识点汇总（一）","url":"/2021/09/06/Android面试知识点汇总（一）/","content":"### 一、Activity启动模式\n* 1、standard 标准模式\n* 2、singleTop 栈顶复用模式 （例如：推送点击消息页面）\n* 3、singleTask 栈内复用模式 （例如： 首页）\n* 4、singleInstance 单例模式 （单独位于一个任务栈中，例如：拨打电话页面）\n* 5. singleInstancePerTask android12的时候新加入\n\n### 二、序列化 Serializable 和 Parcelable\n\n* Serializable： Java 序列化方式，适用于存储和网络传输，serializableUID 用于确定反序列化和类版本是否一致，不一致时反序列化失败\n* Parcelable: Android 序列化方式，适用于组件通信数据传输，性能高\n\nJava中的序列化方式Serializable效率比较低，重要是以下原因：\n* 1、Serializable在序列化过程中会创建大量的临时变量，这样会造成大量的GC\n* 2、Serializable使用了大量的反射，而反射操作耗时\n* 3、Serializable使用了大量的IO操作，也影响耗时\n\n所以Android重新设计了一种序列化的方式，结合Binder的方式，对上述三点进行了优化，一定程度上提高了序列化和返序列化的效率。\n\n### 三、进程知识点\n#### **IPC进程通信**\n\n  * Intent、Bundle：要求传输数据能被序列化，实现 Parcelable、 Serializable，适用于四大组件通信\n  * 文件共享：适用于交换简单的数据实时性不高的场景\n  * AIDL：AIDL 接口实质上是系统提供给我们可以方便实现Binder的工具\n  * Messenger：基于 AIDL 实现，服务端的串行处理，主要用于传递消息，适用于低并发一对多的通信\n  * ContentProvider： 基于 Binder 实现，适用于一对多的进程间的数据共享。（通讯录、短信等）\n  * Socket：TCP、UDP，适用于网络数据交换\n\n#### **进程保活**\n  进程被杀的原因：\n  * 切换到后台内存不足时被杀\n  * 切换到后台厂商省电机制杀死\n  * 用户主动清理\n\n  保活方式：\n  * 1、 Activity提权：挂一个 1像素 Activity将进程优先级提高到前台进程\n  * 2、 Service提权： 启动一个前台服务，（API>18会有正在运行的通知栏）\n  * 3、 广播拉活。（监听 开机 等系统广播）\n  * 4、 Service拉活\n  * 5、 JobScheduler 定时任务拉活。（Android 高版本不行）\n  * 6、 双进程保活\n  * 7、 监听其他大厂广播 （如tx baidu 全家桶互相拉活）\n\n### 4、内存泄露\n* 构造单列的时候尽量别用Activity的引用；\n* 静态引用时注意应用对象的置空或者少用静态引用；\n* 使用静态内部类+软引用代替非静态内部类；\n* 即使取消广播或者观察者注册、耗时任务、属性动画在Activity销毁时记得cancel；\n* 文件流、Cursor等资源操作即使关闭；\n* Activity销毁时WebView的移除和销毁。\n\n### 5、Android进程间的通信\n* bundle：由于Activity、service、receiver都是可以通过 Intent 来携带Bundle数据传输的，所以我们在一个进程中通过Intent将携带数据的Bundle发送到另一个进程的组件；（bundle只能传输三种数据类型，一是键值对的形式，二是键为String的类型，三是值为Parcelable类型）\n* ContentProvider： contentprovicer是安卓四大组件之一，以表格 的形式来存储数据，提供给外界，及ContentProvider 可以跨进程访问其他应用程序中的数据。\n* 文件：两个进程可以到同一个文件去交流数据，我们不仅可以保存文本文件，还可以将对象持久化到文件中，从另一个文件恢复。要注意的是，当并发读/写时可能出现并发的问题。\n* Broadcast：Broadcast可以想Android系统中所有的应用程序发送广播，需要跨进程通信的应用程序可以监听这些广播。\n* AIDL： AIDL通过定义服务端暴露的接口，以提供给客户端来通用，AIDL使用服务器可以并行处理。\n* Messenger：Messenger封装了AIDL之后只能串行运行，所以Messenger一般作用消息传递\n* Socket：\n\n### 6、Android 线程通信\n>Handler 和 AsyncTask （AsyncTask：异步任务，内部封装了Handler）\n\nHandler线程间通信\n作用：\n>线程之间的消息通信\n\n流程：\n\n>主线程默认实现了Looper （调用loop.prepare方法 向sThreadLocal中set一个新的looper对象， looper构造方法中又创建了MsgQueue） 手动创建Handler ，调用 sendMessage 或者 post (runable) 发送Message 到 msgQueue ，如果没有Msg 这添加到表头，有数据则判断when时间 循环next 放到合适的 msg的next 后。Looper.loop不断轮训Msg，将msg取出 并分发到Handler 或者 post提交的 Runable 中处理，并重置Msg 状态位。回到主线程中 重写 Handler 的 handlerMessage 回调的msg 进行主线程绘制逻辑。\n\n问题：\n\n1、Handler 同步屏障机制：通过发送异步消息，在msg.next 中会优先处理异步消息，达到优先级的作用。\n\n2、Looper.loop 为什么不会卡死：为了app不挂掉，就要保证主线程一直运行存在，使用死循环代码阻塞在msgQueue.next()中的nativePollOnce()方法里 ，主线程就会挂起休眠释放cpu，线程就不会退出。Looper死循环之前，在ActivityThread.main()中就会创建一个 Binder 线程（ApplicationThread），接收系统服务AMS发送来的事件。当系统有消息产生（其实系统每 16ms 会发送一个刷新 UI 消息唤醒）会通过epoll机制 向pipe管道写端写入数据 就会发送消息给 looper 接收到消息后处理事件，保证主线程的一直存活。只有在主线程中处理超时才会让app崩溃 也就是ANR。\n\n3、Messaage复用：将使用完的Message清除附带的数据后, 添加到复用池中 ,当我们需要使用它时,直接在复用池中取出对象使用,而不需要重新new创建对象。复用池本质还是Message 为node 的单链表结构。所以推荐使用Message.obation获取 对象。\n\n\n[剩余链接](https://mp.weixin.qq.com/s/dyCEnsdUo-AGhqeCzN0E5w)","tags":["面试"],"categories":["面试"]},{"title":"Android 架构MVC MVP MVVM","url":"/2021/09/01/Mark的架构学习笔记— Android_MVVM/","content":"## MVVM是什么\n>是 Model-View-ViewModel 的简写。MVVM与MVP的结构还是很相似的，就是将Presenter升级为ViewModel。在MVVM中，View层和Model层进行了双向绑定(即Data Binding)，所以Model数据的更改会表现在View上，反之亦然。ViewModel就是用来根据具体情况处理View或Model的变化。\n### Android中的MVVM含义\n* **Model**：实体类(数据的获取、存储、数据状态变化)。\n* **View**：布局文件+Activity。\n* **ViewModel**： 关联层，将Model和View进行绑定，Model或View更改时，实时刷新对方。\n  \n工作原理\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cb68983949e49fe93a6d31aa8c2bcd9~tplv-k3u1fbpfcp-watermark.awebp)\n\n* 1.View 接收用户交互请求\n* 2.View 将请求转交给ViewModel\n* 3.ViewModel 操作Model数据更新\n* 4.Model 更新完数据，通知ViewModel数据发生变化\n* 5.ViewModel 更新View数据\n\n### MVVM的优点\n* 1.提高可维护性。Data Binding可以实现双向的交互，使得视图和控制层之间的耦合程度进一步降低，分离更为彻底，同时减轻了Activity的压力。\n* 2.简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。\n* 3.ViewModle易于单元测试。\n\n### MVVM的缺点\n* 1.对于简单的项目，使用MVVM有点大材小用。\n* 2.对于过大的项目，数据绑定会导致内存开销大，影响性能。\n* 3.ViewModel和View的绑定，使页面异常追踪变得不方便。有可能是View出错，也有可能是ViewModel的业务逻辑有问题，也有可能是Model的数据出错。\n\n## MVP和MVC的最大区别\n>在MVP中View并不直接使用Model，它们之间的通信是通过Presenter 来进行的，所有的交互都发生在Presenter内部，而在MVC中View直接从Model中读取数据而不是通过 Controller。\n\n## 如何选取框架\n适合自己的才是最好的","tags":["Android","架构"],"categories":["Android"]},{"title":"Java设计模式学习——观察者模式","url":"/2021/08/18/Java设计模式学习——观察者模式/","content":"[原文链接](http://c.biancheng.net/view/1390.html)\n## 观察者模式\n>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。\n\n****\n### 介绍\n* **优点**\n  * 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。\n  * 目标与观察者之间建立了一套触发机制。\n* **缺点**\n  * 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。\n  * 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。\n* **使用场景**\n  * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n  * 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n  * 一个对象必须通知其他对象，而并不知道这些对象是谁。\n  * 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n\n* ### 注意事项\n  * 1、JAVA 中已经有了对观察者模式的支持类。 \n  * 2、避免循环引用。 \n  * 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n  ***\n\n### 实现\n>观察者模式的主要角色如下。\n* 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。\n* 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。\n* 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。\n* 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。\n\n观察者模式的实现代码如下：\n```\npublic class ObserverPattern {\n    public static void main(String[] args) {\n        Subject subject = new ConcreteSubject();\n        Observer obs1 = new ConcreteObserver1();\n        Observer obs2 = new ConcreteObserver2();\n        subject.add(obs1);\n        subject.add(obs2);\n        subject.notifyObserver();\n    }\n}\n\n//抽象目标\nabstract class Subject {\n    protected List<Observer> observers = new ArrayList<Observer>();\n\n    //增加观察者方法\n    public void add(Observer observer) {\n        observers.add(observer);\n    }\n\n    //删除观察者方法\n    public void remove(Observer observer) {\n        observers.remove(observer);\n    }\n\n    public abstract void notifyObserver(); //通知观察者方法\n}\n\n//具体目标\nclass ConcreteSubject extends Subject {\n    public void notifyObserver() {\n        System.out.println(\"具体目标发生改变...\");\n        System.out.println(\"--------------\");\n\n        for (Object obs : observers) {\n            ((Observer) obs).response();\n        }\n\n    }\n}\n\n//抽象观察者\ninterface Observer {\n    void response(); //反应\n}\n\n//具体观察者1\nclass ConcreteObserver1 implements Observer {\n    public void response() {\n        System.out.println(\"具体观察者1作出反应！\");\n    }\n}\n\n//具体观察者1\nclass ConcreteObserver2 implements Observer {\n    public void response() {\n        System.out.println(\"具体观察者2作出反应！\");\n    }\n}\n```","tags":["设计模式"],"categories":["Java"]},{"title":"Java设计模式学习——建造者模式","url":"/2021/08/09/Java设计模式学习——建造者模式/","content":"## 建造者模式\n>建造者模式（Builder Pattern）使用多个简单的对象构建一个复杂的对象，这种类型的设计模式就属于创建型模式，它提供了一种创建对象的最佳方式。\n一个建造者（Builder）类会一步一步构造最终的对象，该 Builder 类是独立于其他的对象的\n<!-- more -->\n****\n### 介绍\n* **优点**\n  * 建造者独立，易扩展\n  * 便于控制细节风险\n* **缺点**\n  * 产品有其共同点，范围有限制\n  * 如内部变化复杂，会有很多的建造者\n* **使用场景**\n  * 需要生产的对象具有复杂的内部结构，\n  * 需要生成的对象内部属性本身相互依赖\n* ### 注意事项\n  * 与工厂模式的区别L建造者模式更加关注与零件装配的顺序\n  ***\n### 实现\n我们以肯德基套餐为例\n我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。\n\n#### **步骤一**\n  创建一个表示食物条目和食物包装的接口\n  * 食物条目接口\n  ```\n  /**\n   * 一个表示食物条目\n   */\n  public interface Item {\n    public String name();\n    public Packing packing();\n    public float price();\n  }\n  ```\n  * 食物包装接口\n  ```\n  /**\n   * 食物包装的接口\n   */\n  public interface Packing {\n    public String pack();\n  }\n  ```\n#### **步骤二**\n  创建实现 **Packing** 接口实体类\n  * Wrapper（包装纸） \n  ```\n  public class Wrapper implements Packing {\n\n    @Override\n    public String pack() {\n        return \"Wrapper\";\n    }\n  }\n  ```\n  * Bottle（瓶子）\n  ```\n  public class Bottle implements Packing {\n    @Override\n    public String pack() {\n        return \"Bottle\";\n    }\n  }\n  ```\n#### **步骤三**\n  创建实现**Item**接口的抽象类，该类提供默认的功能\n  * Burger (汉堡）\n   ```\n   public abstract class Burger implements Item {\n\n      @Override\n       public Packing packing() {\n        return new Wrapper();\n      }\n\n      public abstract float price() ;\n   }\n   ```\n  * ColdDrink （冷饮）\n  ```\n  public abstract class ColdDrink implements Item {\n\n    @Override\n    public Packing packing() {\n        return new Bottle();\n    }\n\n    public abstract float price();\n  }\n  ```\n***\n#### 步骤四\n创建扩展了 Burger 和 ColdDrink 的实体类\n  * VegBurger （蔬菜汉堡）\n  ```\n  public class VegBurger extends Burger{\n    @Override\n    public String name() {\n        return \"Veg Burger\";\n    }\n\n    @Override\n    public float price() {\n        return 25.0f;\n    }\n  }\n  ```\n***\n  *  ChickenBurger (鸡肉汉堡)\n  ```\n  public class ChickenBurger extends Burger{\n    @Override\n    public String name() {\n        return \"Chicken Burger\";\n    }\n\n    @Override\n    public float price() {\n        return 50.5f;\n    }\n  }\n  ```\n\n  * Coke ( 可口可乐)\n  ```\n  public class Coke extends ColdDrink{\n    @Override\n    public String name() {\n        return \"Coke\";\n    }\n\n    @Override\n    public float price() {\n        return 30.0f;\n    }\n  }\n  ```\n\n  * Pepsi (百事可乐)\n  ```\n  public class Pepsi extends ColdDrink{\n    @Override\n    public String name() {\n        return \"Pepsi\";\n    }\n\n    @Override\n    public float price() {\n        return 35.0f;\n    }\n  }\n  ```\n#### 步骤五\n创建一个套餐**meal**类，带有上面定义的**Item**对象\n```\npublic class Meal {\n    private List<Item> items = new ArrayList<>();\n\n    public void addItem(Item item) {\n        items.add(item);\n    }\n\n    public float getCost() {\n        float cost = 0.0f;\n        for (Item item : items) {\n            cost += item.price();\n        }\n        return cost;\n    }\n\n    public void showItems() {\n        for (Item item : items) {\n            System.out.println(\"Item : \" + item.name() + \", Packing : \" + item.packing().pack() + \", Price : \" + item.price());\n        }\n    }\n}\n```\n#### 步骤六\n创建一个构造者**MealBuilder**类，实例化`builde`类负责创建的**Meal**套餐对象\n```\npublic class MealBuilder {\n    public Meal prepareVegMeal(){\n        Meal meal = new Meal();\n        meal.addItem(new VegBurger());\n        meal.addItem(new Coke());\n        return meal;\n    }\n\n    public Meal prepareNonVegMeal(){\n        Meal meal = new Meal();\n        meal.addItem(new ChickenBurger());\n        meal.addItem(new Pepsi());\n        return meal;\n    }\n}\n```\n#### 步骤七\n使用**MealBuilder**演示构建者模式（Builder Pattern）\n```\npublic class Test {\n    public static void main(String[] args) {\n        MealBuilder mealBuilder = new MealBuilder();\n\n        Meal vegMeal = mealBuilder.prepareVegMeal();\n        System.out.println(\"Veg Meal\");\n        vegMeal.showItems();\n        System.out.println(\"Toast Cost:\"+vegMeal.getCost());\n\n        Meal nonVegMeal = mealBuilder.prepareNonVegMeal();\n        System.out.println(\"Non-veg Meal\");\n        nonVegMeal.showItems();\n        System.out.println(\"Toast Cost: \"+nonVegMeal.getCost());\n    }\n}\n```\n#### 步骤八\n执行程序输出结果\n>Veg Meal\nItem : Veg Burger, Packing : Wrapper, Price : 25.0\nItem : Coke, Packing : Bottle, Price : 30.0\nToast Cost:55.0\nNon-veg Meal\nItem : Chicken Burger, Packing : Wrapper, Price : 50.5\nItem : Pepsi, Packing : Bottle, Price : 35.0\nToast Cost: 85.5\n\n","tags":["设计模式"],"categories":["Java"]},{"title":"安卓页面跳转，多次点击会重复页面","url":"/2021/06/04/安卓页面跳转，多次点击会重复页面/","content":"\n场景描述：产品故意整事，狂点一个页面跳转按钮，然而那个页面的展示时需要初始化一个第三方的SDK，导致一个启动模式为 ``` android:launchMode=\"singleTop\"```的页面Activity重复新建了多次。\n\n### 1、解决思路查看源码：`startActivity(intent);`\n<!-- more -->\n发现是调用了\n```\n @Override\n    public void startActivity(Intent intent, @Nullable Bundle options) {\n        if (options != null) {\n            startActivityForResult(intent, -1, options);\n        } else {\n            // Note we want to go through this call for compatibility with\n            // applications that may have overridden the method.\n            startActivityForResult(intent, -1);\n        }\n    }\n```\n也就是说我这边只要重写 `startActivityForResult()`方法就好\n### 2、重写 `startActivityForResult()`\n```\n /**\n     * 每次启动activity都会调用此方法\n     */\n    @SuppressLint(\"RestrictedApi\")\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {\n        if (!isFastClick()) {\n            super.startActivityForResult(intent, requestCode, options);\n        }\n    }\n```\n可能注意到了`if (!isFastClick()) {}`,就是在这做判断\n### 3、判断是否快速点击 `isFastClick()`\n```\n  /**\n     * 检查是否重复跳转，不需要则重写方法并返回true\n     */\n    // 两次点击间隔不能少于1000ms\n    private static final int FAST_CLICK_DELAY_TIME = 1000;\n    private static long lastClickTime;\n\n    public static boolean isFastClick() {\n        boolean flag = true;\n        long currentClickTime = System.currentTimeMillis();\n        if ((currentClickTime - lastClickTime) >= FAST_CLICK_DELAY_TIME ) {\n            flag = false;\n        }\n        lastClickTime = currentClickTime;\n        return flag;\n    }\n```\n","tags":["bug"],"categories":["Android"]},{"title":"JDBC学习-事物提交模式和隔离级别","url":"/2021/05/21/JDBC学习-事物提交模式和隔离级别/","tags":["JDBC"],"categories":["JavaWeb"]},{"title":"JDBC学习--ConnectinnFactory","url":"/2021/05/13/JDBC学习-ConnectinnFactory/","content":"[toc]\n### ConnectionFactory的作用\n\n* 利用工厂模式提升代码的额重要性\n* 封装注册数据库的驱动和获得数据库的连接\n* 利用配置文件减少硬编码，便于维护\n\n### ConnectionFactory的开发\n\n* 配置文件 `jdbcinfo.properties`\n\n  ```java\n  oracle.driver=oracle.jdbc.driver.OracleDriver  //数据库驱动\n  oracle.url=jdbc:oracle:thin:@localhost:1521:helowin //数据库地址 helowin:数据库的名字\n  oracle.user=mark  //管理账户\n  oracle.password=chenyunlin  //密码\n  ```\n<!-- more -->\n- 配置文件信息的获取\n\n  ```java\n  static {\n          Properties props = new Properties();\n          // 加载配置文件中的数据\n          InputStream is =\n                  ConnectionFactory.class.getClassLoader().getResourceAsStream(\"jdbcinfo.properties\");\n          try {\n              props.load(is);\n              DRIVER = props.getProperty(\"oracle.driver\");\n              URL = props.getProperty(\"oracle.url\");\n              USER = props.getProperty(\"oracle.user\");\n              PASSWORD = props.getProperty(\"oracle.password\");\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n      }\n  ```\n\n- 数据库连接Connection的获取\n\n     * ```java\n       public static connection getConnection(){\n       \n       Connection conn = null;\n               try {\n                   Class.forName(DRIVER);\n                   conn = DriverManager.getConnection(URL, USER, PASSWORD);\n               } catch (ClassNotFoundException | SQLException e) {\n                   e.printStackTrace();\n               }\n               return conn;\n       \n       }\n       ```\n       > 调用getConnection()方法后，\n       Console输出：`oracle.jdbc.driver.T4CConnection@f8c1ddd`  表示数据连接成功","tags":["JDBC"],"categories":["JavaWeb"]},{"title":"JDBC学习--Statement","url":"/2021/05/13/JDBC学习-Statement/","content":"###  JDBC的API结构和使用流程\n\n```mermaid\ngraph TB\n    A0[DriverManager] --> B0[Driver]\n    A0[DriverManager] --> B1[Driver] \n    B0[Driver] --> C0[Connection]\n    B1[Driver] -->C1[Connection]\n    B1[Driver] -->C2[Connection]\n    C0[Connection]-->D0[Statement]\n    C0[Connection]-->D1[Statement]-->E0[ResultSet]\n    C0[Connection]-->D2[Statement]-->E1[ResultSet]\n    C1[Connection]-->D3[Statement]-->E2[ResultSet]\n```\n<!-- more -->\n### 创建Statement的方式\n\n* `Statement  stmt = Connection.createStatement(......);`\n\n  * 执行不带参数的简单SQL语句\n\n* `PreparedStatement  pstmt = Connection.prepareStatement(......);`\n\n  * 执行带参数或不带参数的SQL语句\n  \n* `CallableStatement   cstmt  =  Connection.prepareCall(...);`\n  * 执行对数据库已存储的PL/SQL程序的调用\n***\n### 执行SQL语句\n* `executeQuery()`：执行查询语句，返回查询结果集 `ResultSet`\n  返回结果集 `rs.getFetchSize()`记录着当前返回数量的大小：`10`\n* `executeUpdate()`: 执行DML和DDL 语句，返回int类型\n* `execute()`: 执行任何SQL语句，返回boolean类型，指示是否有ResultSet返回\n  ","tags":["JDBC"],"categories":["JavaWeb"]},{"title":"Mac电脑maven安装与配置","url":"/2021/05/13/Mac电脑maven安装与配置/","content":"[原文地址：大自然的流风](https://www.cnblogs.com/zdz8207/p/mac-java-maven.html)\n***\n### Mac电脑maven安装与配置\n1. 下载：http://maven.apache.org/download.cgi\n2. 安装：解压下载好的maven的文件，解压到你想要的文件夹下。\n3. 配置：打开终端输入命令 sudo vim ~/.bash_profile （编辑环境变量配置文件）\n   ```\n   export MAVEN_HOME=maven文件夹路径\n   export PATH=$PATH:$MAVEN_HOME/bin\n   ```\n   **小技巧**\n   >复制文件夹路径方法：点击文件夹，然后使用组合快捷键：command + option + c 就会把路径复制到粘贴板了。\n或者把文件夹拖放到控制台也可以显示出来\n让mac文件夹显示文件夹和文件路径，执行命令：defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n\n4. `:wq`退出并保存当前文件,`source .bash_profile`，按下Enter键使bash_profile生效。\n   `mvn -v`查看是否成功\n```\n@Markxiansheng ~ % mvn -v\nApache Maven 3.8.1 (05c21c65bdfed0f71a2f2ada8b84da59348c4c5d)\nMaven home: /Users/mark/Library/maven/apache-maven-3.8.1\nJava version: 11.0.11, vendor: Amazon.com Inc., runtime: /Users/mark/Library/Java/JavaVirtualMachines/corretto-11.0.11/Contents/Home\nDefault locale: zh_CN_#Hans, platform encoding: UTF-8\nOS name: \"mac os x\", version: \"10.15.7\", arch: \"x86_64\", family: \"mac\"\n```","tags":["Maven"],"categories":["环境配置"]},{"title":"Mac连接京瓷打印机Fs-1030MFP/DP","url":"/2021/05/13/Mac连接京瓷打印机Fs-1030MFP-DP/","content":"```mermaid\ngraph TB\n    A0[进入系统偏好设置] --> B0[打印机与扫描仪] --> C0[添加打印机] -->  D0[选择IP]\n    D0[选择IP]  --> E0[ 输入IP地址,协议选择行式打印机监控程序-LPD,使用那选择普通PCL打印机,然后系统会自动添加打印机驱动]  --> F0[OK开始打印吧] \n```\n1. 进入系统偏好设置。\n2. 打印机与扫描仪\n3. 添加打印机\n4. 选择IP\n5. 输入IP地址，协议选择“行式打印机监控程序-LPD”，使用那选择“普通PCL打印机”，然后系统会自动添加打印机驱动。\n6. OK开始打印吧\n***\n就是这么简单","tags":["工具搭建"],"categories":["工具使用"]},{"title":"Kotlin中可变参数","url":"/2021/04/26/Kotlin中可变参数/","content":"[原文简书](https://www.jianshu.com/p/174c0e254713)\n***\n### 对比 Java 中的可变参数\n先看下 Java 的可变参数，用我们最熟悉的 main 函数\n```Java\npublic static void main(String... args) {\n}\n```\n从 Java5 开始引入了可变参数（varargs）\n对应的 Kotlin 的代码，参数为可变参数：\n```Kotlin\nfun main(vararg args: String) {\n}\n```\n<!-- more -->\nJava代码中参数应该是数组：\n```Java\npublic static void main(String[] args) {\n}\n```\n对应的 Kotlin 的代码，也是两种方式，参数为数组：\n```Kotlin\nfun main(args: Array<String>){\n\n}\n```\n***\n### 可变参数的本质\n```Kotlin\nfun main() {\n    foo(\"1\", \"2\", \"3\")\n}\n\nfun foo(vararg args: String) {\n    println(args::class)\n    println(args.contentToString())\n    for (i in args.indices) {\n        println(args[i])\n    }\n}\n```\n打印：\n```Kotlin\nclass kotlin.Array\nval kotlin.reflect.KClass<T>.java: java.lang.Class<T>\n[1, 2, 3]\n1\n2\n3\n```\n我们可以清晰的看到 args 的类型为数组类型，并且可以直接调用数组的方法。\n> 如果你的第一行打印结果是：\n> \n> class [Ljava.lang.String; (Kotlin reflection is not available)\n> \n> 需要在 build.gradle 中添加依赖：\n> \n> implementation \"org.jetbrains.kotlin:kotlin-reflect:$kotlin_version\"\n\n****\n\n****准确的说 args 的类型是 Array<out String> 类型:****\n```Kotlin\nfun main() {\n    foo(\"1\", \"2\", \"3\")\n}\n\nfun foo(vararg args: String) {\n    bar(args)\n}\n\nfun bar(args: Array<out String>) {\n    println(args.contentToString())\n}\n```\n*** \n\n### 可变参数的传参\n我们再来改造一下 bar 函数的参数类型，看下可变参数的传参：\n```Kotlin\nfun main() {\n    foo(\"1\", \"2\", \"3\")\n}\n\nfun foo(vararg args: String) {\n    bar(args)\n}\n\nfun bar(vararg args: String) {\n    println(args.contentToString())\n}\n```\n编译器提示类型不匹配，需要一个 String 类型的参数，而传入了数组类型。\n然而在 Java 中可变参数是可以直接传递，并且可以和数组相互转换传递：\n```Java\npublic static void main(String[] args) {\n    foo(\"1\", \"2\", \"3\");\n}\n\nprivate static void foo(String... args) {\n    bar1(args);\n    bar2(args);\n}\n\nprivate static void bar1(String... args) {\n    System.out.println(Arrays.toString(args));\n}\n\nprivate static void bar2(String[] args) {\n    bar1(args);\n}\n```\n在 Kotlin 中如果想将数组类型传入到可变参数，就需要使用一个特定的符号 `* `：\n```Kotlin\nfun main() {\n    foo(\"1\", \"2\", \"3\")\n}\n\nfun foo(vararg args: String) {\n    bar1(*args)\n    bar2(args)\n}\n\nfun bar1(vararg args: String) {\n    println(args.contentToString())\n}\n\nfun bar2(args: Array<out String>) {\n    bar1(*args)\n}\n```\n### 总结\n我对 Kotlin 中d可变参数的理解是：\n1. 可变参数会在函数体中，自动转变为数组类型\n2. 数组类型不能作为参数，直接传递给可变参数\n3. 在数组类型前面添加 * ，可以传递给可变参数\n   \n最后，我们可以反编译看下 Kotlin 中的 foo 函数，看看 * 到底做了什么：\n```Kotlin\npublic static final void foo(@NotNull String... args) {\n    bar1((String[]) Arrays.copyOf(args, args.length));\n    bar2(args);\n}\n```\n就是一个复制数组的操作，相比 Kotlin 还是 Java 做的更便捷，可以在数组和可变参数之间直接自由转换。\n\n","tags":["Kotlin基础"],"categories":["Kotlin"]},{"title":"如何修改表结构：ALERT语句","url":"/2021/04/19/如何修改表结构：ALERT语句/","content":"应用场景：当我们的业务需要对已经存在的表进行表结构修改时，我们需要使用 ALERT 语句进行修改。\n### 增加表列:\n```\nALERT TABLE tablenamme ADD\n(\n    column dataType [DEFAULT expr][NOT NULL],\n    column dataType [DEFAULT expr][NOT NULL],\n    ....\n);\n```\n### 修改表列:\n```\nALERT TABLE tablenamme MODIFY\n(\n    column dataType [DEFAULT expr][NOT NULL],\n    column dataType [DEFAULT expr][NOT NULL],\n    ....\n);\n```\n**注意事项**：\n* 修改表列时，可以增加 `NOT NULL`及默认值约束，不能增加其他约束\n* 增加的默认值只会影响到后来插入的值\n* 若是要缩小列的宽度时，只有表中该列为空后者表里没有记录\n* 如若这列有空值，则不能添加非空约束\n* 若是改变该列的类型，只有表中该列为空后者表里没有记录\n\n### 删除表中的列\n```ALERT TABLE tablenamme DROP column col_name;```\n### 增加约束\n```\nALERT TABLE tablenamme \nADD [CONSTRAINT constraint] type (column);\n```\n* 增加 `NOT NULL`约束只能在增加列和修改列的时候添加","tags":["Oracle"],"categories":["数据库"]},{"title":"MAC使用APKTool反编译apk修改版本号后重新打包","url":"/2021/04/14/MAC使用APKTool反编译apk修改版本号后重新打包/","content":"现在业务上出现客户要求如若生产环境出现紧急事件，需要版本回退的情况下，我这边的代码又没做版本分之处理，那么只能更改之前的版本号来实现。\n[不敢夺他人之功，原文在此处](https://blog.csdn.net/weixin_40998254/article/details/110474885)\n\n[我之前的文章：android反编译apktool---dex2jar---jdgui](https://markchyl.cn/2020/12/14/android%E5%8F%8D%E7%BC%96%E8%AF%91apktool-dex2jar-jdgui/)\n\n### 一、反编译apk并修改版本号\n在apk所在目录控制台输入下面指令，即可将文件名为source的apk反编译到outDir目录\n* 开始反编译apk\n  \n  ```apktool d -o outDir source.apk```\n  或者\n  ```apktool d source.apk -o outDir```\n\n### 二、修改版本号\n打开输入目录outDir找到apktool.yml文件，编辑修改versionCode\n\n### 三、重新打包\n通过以下命令就可以将目录outDir中的文件重新打包为no_sign_result.apk\n* ```apktool b -o no_sign_result.apk outDir```\n\n或者\n\n* ```apktool b outDir -o  no_sign_result.apk ```\n  \n### 四、重新签名\n使用如下命令进行签名\n```jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore demostore.jks -signedjar result-signed.apk no_sign_result.apk yourkey```\n注：\n* demostore.jks为签名文件\n* no_sign_result.apk为要签名的源文件\n* result-signed.apk为签名后的目标文件\n* yourkey为签名的key\n\n","tags":["反编译","工具搭建"],"categories":["Android"]},{"title":"Log日志工具类(一)","url":"/2021/04/07/Log日志工具类-一/","content":"实现的效果能将json字符串以格式化的方式显示\n```\n/**\n * $desc$ Log日志工具类\n *\n * @Author mark\n * @Date 2018/11/26\n */\npublic class LogUtils {\n    //是否Debug\n    public static final boolean isMarkDebug = true;\n\n    public static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n    public static void printLog(String name,String strContent){\n        if (isMarkDebug){\n            Log.d(name,strContent);\n        }\n    }\n    public static void printLine(String tag, boolean isTop) {\n        if (isTop) {\n            Log.d(tag, \"╔═══════════════════════════════════════════════════════════════════════════════════════\");\n        } else {\n            Log.d(tag, \"╚═══════════════════════════════════════════════════════════════════════════════════════\");\n        }\n    }\n    public static void printJson(String tag, String msg, String headString) {\n\n        String message;\n\n        try {\n            if (msg.startsWith(\"{\")) {\n                JSONObject jsonObject = new JSONObject(msg);\n                message = jsonObject.toString(4);//最重要的方法，就一行，返回格式化的json字符串，其中的数字4是缩进字符数\n            } else if (msg.startsWith(\"[\")) {\n                JSONArray jsonArray = new JSONArray(msg);\n                message = jsonArray.toString(4);\n            } else {\n                message = msg;\n            }\n        } catch (JSONException e) {\n            message = msg;\n        }\n\n        printLine(tag, true);\n        message = headString + LINE_SEPARATOR + message;\n        String[] lines = message.split(LINE_SEPARATOR);\n        for (String line : lines) {\n            Log.d(tag, \"║ \" + line);\n        }\n        printLine(tag, false);\n    }\n}\n\n```\n","tags":["Utils"],"categories":["Android"]},{"title":"Android根据字符串加载Activity和res目录下图片","url":"/2021/01/15/Android根据字符串加载Activity和res目录下图片/","content":"### 根据传入的字符串跳转Activity\n```\nIntent intent = new Intent(context,Class.forName(\"com.packname.Activity\"));\nstartActivity(intent);\n```\n### 根据传入的字符加载资源\n```\nint icon = getResources().getIdentifier(“imageid”, \"drawable\",getPackageName());\n```\n优化：\n```\npublic static int getDrawableId(Context context, String var) {\n\n        try {\n            int imageId = context.getResources().getIdentifier(var, \"drawable\", context.getPackageName());\n            return imageId;\n        } catch (Exception e) {\n            return 0;\n        }\n    }\n```\n**getIdentifier的函数签名如下：**\n```\npublic int getIdentifier (String name, String defType, String defPackage)\n```","tags":["Android"],"categories":["Android"]},{"title":"Android 的事件分发机制","url":"/2020/12/30/Android-的事件分发机制/","content":"Android 事件分发总是遵循 Activity => ViewGroup => View 的传递顺序；\n从按下开始依次从Activity开始处理，然后向下分发到ViewGroup，再到最下面的View。\n\n一般情况下，事件列都是从用户按下（ACTION_DOWN）的那一刻产生的，\n负责对事件进行分发的方法主要有三个，分别是：\n* dispatchTouchEvent()\n* onTouchEvent()\n* onInterceptTouchEvent()\n  \n事件：事件就是Event\n事件类型分为四种\n* DOWN是按下\n* UP是抬起\n* MOVE是滑动\n* CANCEL是取消事件\n\n它们并不存在于所有负责分发的组件中，其具体情况总结于下面的表格中：\ndispatchTouchEvent,onTouchEvent方法存在于上文的三个组件中。而onInterceptTouchEvent为ViewGroup独有。\nViewGroup类中，实际是没有onTouchEvent方法的，但是由于ViewGroup继承自View，而View拥有onTouchEvent方法，故ViewGroup的对象也是可以调用onTouchEvent方法的。\n","tags":["基础理论"],"categories":["Android"]},{"title":"Android事件分发机制完全解,从源码的角度分析理解","url":"/2020/12/30/Android事件分发机制完全解-从源码的角度分析理解/","tags":["基础理论"],"categories":["Android"]},{"title":"使用 Gradle 工具检查此项目的依赖","url":"/2020/12/18/使用-Gradle-工具检查此项目的依赖/","content":"使用 Gradle 工具检查此项目的依赖，进入项目目录，执行如下指令进行依赖检查：\n```\ncd app\ngradle dependencies\n\n```\n打印出如下图所示的依赖树，依赖树显示了你 build 脚本声明的顶级依赖和它们的传递依赖：\n```\n+--- androidx.test.ext:junit:1.1.1\n|    +--- junit:junit:4.12\n|    |    \\--- org.hamcrest:hamcrest-core:1.3\n|    +--- androidx.test:core:1.2.0\n|    |    +--- androidx.annotation:annotation:1.0.0 -> 1.1.0\n|    |    +--- androidx.test:monitor:1.2.0\n|    |    |    \\--- androidx.annotation:annotation:1.0.0 -> 1.1.0\n|    |    \\--- androidx.lifecycle:lifecycle-common:2.0.0 -> 2.1.0\n|    |         \\--- androidx.annotation:annotation:1.1.0\n|    +--- androidx.test:monitor:1.2.0 (*)\n\n```","tags":["Android","Gradle"],"categories":["Android"]},{"title":"android反编译apktool---dex2jar---jdgui","url":"/2020/12/14/android反编译apktool-dex2jar-jdgui/","content":"\n## 反编译的工具（MAC环境下）\n下载地址：\n  * [apkTool：一款用于反编译apk资源文件](https://ibotpeaches.github.io/Apktool/install/)\n  * [dex2jar：是用于将class.dex 转换成classes-dex2jar.jar的工具](https://sourceforge.net/projects/dex2jar/files/)\n  * [jdgui：这个用于查看classes-dex2jar.jar 源码工具](http://java-decompiler.github.io/)\n  \n  <!-- more -->\n\n## apktool下载安装使用\n1、下载\n\n![](https://img-blog.csdnimg.cn/20191226175801984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n\n * 将你下载的apkttool工具放到/usr/local/bin\n  ![](https://img-blog.csdnimg.cn/20191226185054248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n * 指向对应的文件夹cd /usr/local/bin\n  ![](https://img-blog.csdnimg.cn/20191226185223643.png)\n * 给apktool权限：输入以下两个命令行给予这两个文件夹权限\n    * chmod a+x apktool.jar\n    * chmod a+x apktool\n * 验证是否成功\n  终端输入`apktool -version`\n  \n2、使用反编译命令行 apktool d xxxx.apk\n反编译之后的文件夹中的文件介绍\n![](https://img-blog.csdnimg.cn/20191226190211334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n![](https://img-blog.csdnimg.cn/20191226190234935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n假如只需要获取app的xml或者图片资源，则到这一步则完成啦！\n\n\n如果要获取到java的代码，那么我们还要进行回编译，这样，我们就能获取到classex.dex文件了\n\n在终端执行命令 `apktool b app反编译的文件夹名称` ，执行完毕后，我们就可以在刚刚的文件夹里面多了一个` build `文件夹了，里面的 `classess.dex `则是我们想要获取到的源码文件\n\n## dex2jar操作流程\n下载\n![](https://img-blog.csdnimg.cn/20191226190424255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n下载完成解压文件后，再终端执行 `chmod +x d2j-dex2jar.sh `和 `chmod +x d2j_invoke.sh` 添加运行权限：\n * 拿出里面的`classe.dex`，放入到`dex2jar`文件夹中\n * 使用命令行 `sh d2j-dex2jar.sh classes.dex`,就可以转换成`classes-dex2jar.jar `\n![](https://img-blog.csdnimg.cn/20191226190907884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n\n## jd-gui反编译class文件查看java代码\n下载文件放入自己的安装目录，解压即可使用\n然后把刚刚我们获取到的`classes-dex2jar.jar`拖进去打开文件即可。","tags":["反编译","工具搭建"],"categories":["Android"]},{"title":"如何爬取一个网站的图片分组到指定的文件夹","url":"/2020/12/09/如何爬取一个网站的图片分组到指定的文件夹/","content":"\n\n###  开发工具：\n\n* Mac电脑    \n\n* PyCharm\n\n* Python3.7\n\n* 工具包 **bs4、os、requests**\n\n#### 网页信息\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicr8QmibfJePDfkanj24gu7Qjka5LEicltPQbZIKt7XSb94t43vG22UJxtw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n<!-- more -->\n\n*从上面这张图我们可以看出，一页有多套图，这个时候我们就要想怎么把每一套图分开存放（后边具体解释）*\n通过分析，所有信息在页面中都可以拿到，我们就不考虑异步加载，那么要考虑的就是分页问题了，通过点击不同的页面，很容易看清楚分页规则\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicroN6T3CN0vmAKkOdPIZ6GsL2LxAicSXDROH4NGvlssb2iaV7vT3I9PZgQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n*很容易明白分页URL的构造，图片链接都在源码中，就不做具体说明了明白了这个之后就可以去写代码抓图片了*\n\n#### 存图片的思路\n\n因为要把每一套图存入一个文件夹中（os模块），文件夹的命名我就以每一套图的URL的最后的几位数字命名，然后文件从文件路径分隔出最后一个字段命名,具体看下边的截图。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicrs1YO4cw4sWDegXqZ54ujz7VZ1fZds5TRIlUicRZqpJ0OzzPceeW71ng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicrR89T7BTesr71ibH0iaYWZU7XnXEpcu4FdzmamOPib0ZefkEsUv8Ykx9pg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n这些搞明白之后，接下来就是代码了（可以参考我的解析思路，只获取了30页作为测试）**全部源码**,下面的源码有原文中的有点不一样。\n\n```python\n# -*- coding:utf-8 -*-\nfrom bs4 import BeautifulSoup\nimport os\nimport requests\n\n\nclass doutuSpider(object):\n    headers = {\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36\"}\n\n    def get_url(self, url):\n        data = requests.get(url, headers=self.headers)\n        soup = BeautifulSoup(data.content, 'lxml')\n        totals = soup.findAll(\"a\", {\"class\": \"list-group-item\"})\n        for one in totals:\n            sub_url = one.get('href')\n            global path\n            path = \"/Users/mark/Desktop/Mark/doutu/\" + sub_url.split('/')[-1]\n            os.makedirs(path, exist_ok=True)\n            try:\n                self.get_img_url(sub_url)\n            except:\n                pass\n\n    def get_img_url(self, url):\n        data = requests.get(url, headers=self.headers)\n        soup = BeautifulSoup(data.content, 'lxml')\n        totals = soup.find_all('div', {'class': 'artile_des'})\n        for one in totals:\n            img = one.find('img')\n            try:\n                sub_url = img.get('src')\n            except:\n                pass\n            finally:\n                # http://ww1.sinaimg.cn/large/9150e4e5gy1g59ef4u9edg206o06ogni.gif\n                print(sub_url)\n                try:\n                    self.get_img(sub_url)\n                except:\n                    pass\n\n    def get_img(self, url):\n        filename = url.split('/')[-1]\n        global path\n        img_path = path + '/' + filename\n        print('正在下载----', url)\n        print('存储地址为----', img_path)\n        try:\n            img = requests.get(url, headers=self.headers)\n            with open(img_path, 'wb') as f:\n                f.write(img.content)\n                f.close()\n        except requests.RequestException:\n            print('请求图片出错', url)\n\n    def create(self):\n        for count in range(1, 2):\n            url = 'https://www.doutula.com/article/list/?page={}'.format(count)\n            print('开始下载第{}页'.format(count))\n            self.get_url(url)\n\n\nif __name__ == '__main__':\n    doutu = doutuSpider()\n    doutu.create()\n\n```\n\n#### 结果\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicrTamKCbHGDr8Z4sGGZbnLOUGMOGickw2Raa1HVowjrgKDib0wwXmqKQmw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicrhzHDdct4Y6FZ4melwBj3NdY5lKUicvrk9ib5ZNFdN140PicmQiaSBxRMwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/WGyNiboAjLV7cHtVA3p3bYOrDpxiaSCGicrMWzicYkDdR1nC7viaw97CTmzynWs7JJexuF297FWdChrJNNAn25lNSAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n#### 总结 \n\n总的来说，这个网站结构相对来说不是很复杂，大家可以参考一下，爬一些有趣的\n\n原创作者：loading_miracle，原文链接:\nhttps://www.jianshu.com/p/88098728aafd","tags":["爬虫","Python3.7"],"categories":["Python"]},{"title":"Mac用Docker安装Oracle11g并连接Navicat","url":"/2020/12/01/Mac用Docker安装Oracle11g并连接Navicat/","content":"[原文转载自大佬笑等茶凉](https://www.cnblogs.com/lihanqing/p/12329480.html)\n### 1.下载并安装Docker\n\n官方下载地址：https://download.docker.com/mac/stable/Docker.dmg\n\n### 2.用docker下载镜像，在终端输入：\n\n>docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g\n\n### 3.启动oracle镜像作为容器：\n\n>docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g\n\n### 4.进入镜像配置\n\n>docker exec -it oracle11g bash\n<!-- more -->\n\n### 5.配置环境变量\n\n```\nexport ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2\nexport ORACLE_SID=helowin\nexport PATH=$ORACLE_HOME/bin:$PATH\n```\n### 6.修改密码\n>sqlplus /nolog\n\n>SQL> conn /as sysdba;\nSQL> alter user system identified by oracle;\nSQL> conn system/oracle;\n那样便修改了账号为system密码为oracle的账号.\n\n**系统权限管理 :**\n  \n  * 系统权限分类：\n  DBA: 拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构。\nRESOURCE:拥有Resource权限的用户只可以创建实体，不可以创建数据库结构。\nCONNECT:拥有Connect权限的用户只可以登录Oracle，不可以创建实体，不可以创建数据库结构。\n对于普通用户：授予connect, resource权限。\n对于DBA管理用户：授予connect，resource, dba权限。\n****\n  * 系统权限授权命令：\n  系统权限只能由DBA用户授出：sys, system(最开始只能是这两个用户)\n授权命令：SQL> grant connect, resource, dba to 用户名1 [,用户名2]…;\n注:普通用户通过授权可以具有与system相同的用户权限，但永远不能达到与sys用户相同的权限，system用户的权限也可以被回收。\n\n### 7.创建用户\n>SQL> create user mark identified by chenyunlin;\n\n用sysdba赋予该用户所有权限：\n>SQL> grant all privileges to mark;\n\n连接新创建的用户：\n>SQL> conn mark/chenyunlin;\n\n创建表：\n>SQL> create table test2(name varchar2(20), city varchar2(20));\n\n比如在此你拥有自动化创建数据表的脚本的话\n`## 执行sql脚本文件\n@/Users/mark/Desktop/iotek_oracle.sql;`\n\n### 8.使用Navicat连接oracle\n\n图片借用哈\n![](https://img2018.cnblogs.com/blog/1384393/202002/1384393-20200219000941495-1048166820.png )\n\n注意：服务名helowin是镜像地址中的\n\n**常用的一些命令：**\n\n`docker ps`是查看当前运行的容器\n\n`docker ps -a `是查看所有容器（包括停止的）\n\n`docker images`查看所有镜像\n\n`docker run -h \"oracle\" --name \"oracle\" -d -p 49160:22 -p 49161:1521 -p 49162:8080 alexeiled/docker-oracle-xe-11g`\n​ -h \"oracle\"：指定容器的hostname为oracle\n\n　　--name \"oracle\"：将容器命名为oracle\n\n　　-d：在后台运行\n\n　　-p: 端口映射，格式为：主机(宿主)端口:容器端口\n\n**启动或停止oracle服务：**\n\n`docker start oracle11g`\n\n`docker stop oracle11g`\n\n### 9.后续操作命令\n删除容器：\n>docker rm [containerId]\n删除镜像：\n>docker rmi [imageId]\n\n### 10.使用终端打开sqlplus \n由于本人电脑的配置原因，\n*  docker exec -it oracle11g bash\n```\nexport ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2\nexport ORACLE_SID=helowin\nexport PATH=$ORACLE_HOME/bin:$PATH\nsqlplus /nolog\n\nSQL*Plus: Release 11.2.0.1.0 Production on Fri Dec 4 15:03:36 2020\n\nCopyright (c) 1982, 2009, Oracle.  All rights reserved.\n\nSQL> \n```\n","tags":["环境搭建","Oracle"],"categories":["数据库"]},{"title":"Android混淆","url":"/2020/11/07/Android混淆/","content":">代码混淆（Obfuscated code）亦称花指令，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。\n\n> 为什么要加代码混淆?\n> 不想开源应用，为了加大反编译的成本,但是并不能彻底防止反编译\n\n### 开启混淆\n* 通常我们需要找到项目路径下app目录下的build.gradle文件\n* 找到minifyEnabled这个配置,然后设置为true即可.\n```\n release{\n            minifyEnabled true//是否启动混淆 ture:打开   false:关闭\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n```\nproguard-rules.pro文件的作用\n* 只要在工程应用目录的gradle文件中设置minifyEnabled:true即可。然后我们就可以到proguard-rules.pro文件中加入我们的混淆规则了\n  <!-- more -->\n### proguard是什么?\n* Proguard是一个集文件压缩,优化,混淆和校验等功能的工具\n* 它检测并删除无用的类,变量,方法和属性\n* 它优化字节码并删除无用的指令.\n* 它通过将类名,变量名和方法名重命名为无意义的名称实现混淆效果.\n* 最后它还校验处理后的代码\n\n### 混淆的常见配置\n* Proguard关键字\n\n| Proguard关键字 | 描述 |\n|--|----|\n| dontwarn| dontwarn是一个和keep可以说是形影不离,尤其是处理引入的library时. |\n| keep| 保留类和类中的成员，防止被混淆或移除 |\n| keepnames| 保留类和类中的成员，防止被混淆，成员没有被引用会被移除|\n| keepclassmembers| 只保留类中的成员，防止被混淆或移除|\n| keepclassmembernames| 只保留类中的成员，防止被混淆，成员没有引用会被移除 |\n| keepclasseswithmembers| 保留类和类中的成员，防止被混淆或移除，保留指明的成员|\n| keepclasseswithmembernames| 保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除|\n\n如：\n(1)保留某个包下面的类以及子包\n`-keep public class com.droidyue.com.widget.**`\n\n(2)保留所有类中使用otto的public方法\n```\n# Otto\n-keepclassmembers class ** {\n    @com.squareup.otto.Subscribe public *;\n    @com.squareup.otto.Produce public *;\n}\n```\n\n(3)保留Contants类的BOOK_NAME属性\n```\n-keepclassmembers class com.example.admin.proguardsample.Constants {\n     public static java.lang.String BOOK_NAME;\n}\n```\n\n(4)dontwarn：\n引入的library可能存在一些无法找到的引用和其他问题,在build时可能会发出警告,如果我们不进行处理,通常会导致build中止.因此为了保证build继续,我们需要使用dontwarn处理这些我们无法解决的library的警告.\n```\n#比如关闭Twitter sdk的警告,我们可以这样做\n-dontwarn com.twitter.sdk.**\n```\n* Proguard通配符\n  \n| Proguard通配符 | 描述 |\n|--|----|\n| `<field>` | 匹配类中的所有字段|\n| `<method>` | 匹配类中所有的方法 |\n| `<init>` | 匹配类中所有的构造函数|\n| * | 匹配任意长度字符，不包含包名分隔符(.)|\n| **| 匹配任意长度字符，包含包名分隔符(.)|\n| ***| 匹配任意参数类型|\n| ...| ...|","tags":["混淆"],"categories":["Android"]},{"title":"RxJava学习笔记一","url":"/2020/10/19/RxJava学习笔记一/","content":"### Hello World!\n* RxJava1.1.7.jar\n代码演示：\n```\npublic static void main(String[] args) {\n\t\t//第一步、创建被观察者\n\t\tObservable<String> mObservable = Observable.create(new OnSubscribe<String>(){\n\t\t\t@Override\n\t\t\tpublic void call(Subscriber<? super String> subscriber) {\n\t\t\t\tsubscriber.onNext(\"Hello World!\");\n\t\t\t\tsubscriber.onCompleted();\n\t\t\t}\n\t\t});\n\t\t\n\t\t//第二步、创建观察者\n\t\tSubscriber<String> mSubscriber = new Subscriber<String>() {\n\n\t\t\t@Override\n\t\t\tpublic void onCompleted() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tSystem.out.println(\"onCompleted\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onError(Throwable arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tSystem.out.println(\"onError\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNext(String arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tSystem.out.println(\"OnNext:\"+arg0);\n\t\t\t\t\n\t\t\t}\n\t\t};\n\t\t\n\t\t//第三步、订阅事件\n\t\tmObservable.subscribe(mSubscriber);\n\t}\n```\n> 例如代码中所演示的，RxJava的使用就是那么简单，通过订阅事件将被观察者和观察者进行绑定。\n<!-- more -->\n### 响应式编程：\n在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。\n\n响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。\n\n今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。\n>本章节中部分概念摘自《RxJava Essentials》一书\n\n### RxJava简介：\nRxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。\n\nRx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。\n从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。\n![](https://pic1.zhimg.com/80/ca736fe59de94c221875cb428d7eaff0_1440w.png)\n\n### RxJava好在哪\n* 供了AsyncTask,Handler等用来做异步操作的类库了AsyncTask,Handler等用来做异步操作的类库\n* 非常简洁的代码逻辑来解决复杂问题","tags":["RxJava"],"categories":["RxJava"]},{"title":"Android消息传递机制总结(五)","url":"/2020/10/19/Android消息传递机制总结-五/","content":"长连接推送 ——— WebSocket，XMPP等。\n### 5.长连接推送\nWebsocket\n支持客户端和服务器端的双向通信，而且协议的头部又没有HTTP的Header那么大，于是，Websocket就诞生了！\n<!-- more -->\n\nWebsocket是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。\n\nWebsocket的数据传输是frame形式传输的，比如会将一条消息分为几个frame，按照先后顺序传输出去。这样做会有几个好处：\n\n1 大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。\n\n2 和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。\n\nXMPP中定义了三个角色，客户端，服务器，网关。通信能够在这三者的任意两个之间双向发生。服务器同时承担了客户端信息记录，连接管理和信息的路由功能。网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS（短信），MSN，ICQ等。基本的网络形式是单客户端通过TCP/IP连接到单服务器，然后在之上传输XML。\n\nQQ是使用类似XMPP协议的UDP协议进行发送和接收消息的。当你的机器安装了QQ以后，实际上，你既是服务端（Server），又是客户端（Client）。当你登录QQ时，你的QQ作为Client连接到腾讯公司的主服务器上，当你看谁在线时，你的QQ又一次作为Client从QQ Server上读取在线网友名单。当你和你的QQ伙伴进行聊天时，如果你和对方的连接比较稳定，你和他的聊天内容都是以UDP的形式，在计算机之间传 送。如果你和对方的连接不是很稳定，QQ服务器将为你们的聊天内容进行中转。其他的即时通信软件原理与此大同小异。\n\n所以基于WebSocke和XMPP都可以开发出IM社交聊天类的app","tags":["消息通信"],"categories":["Android"]},{"title":"Android消息传递机制总结(四)","url":"/2020/10/12/Android消息传递机制总结-四/","content":"进程间通信 ——— Content Provider ，Broadcast ，AIDL等。\n### 4.进程间通信\n#### Content Provider\nAndroid应用程序可以使用文件或SqlLite数据库来存储数据。Content Provider提供了一种在多个应用程序之间数据共享的方式（跨进程共享数据）。应用程序可以利用Content Provider完成下面的工作\n1. 查询数据\n2. 修改数据\n3. 添加数据\n4. 删除数据\n<!-- more -->\n虽然Content Provider也可以在同一个应用程序中被访问，但这么做并没有什么意义。Content Provider存在的目的向其他应用程序共享数据和允许其他应用程序对数据进行增、删、改操作。\nAndroid系统本身提供了很多Content Provider，例如，音频、视频、联系人信息等等。我们可以通过这些Content Provider获得相关信息的列表。这些列表数据将以Cursor对象返回。因此，从Content Provider返回的数据是二维表的形式。\n#### 广播（Broadcast）\n广播是一种被动跨进程通讯的方式。当某个程序向系统发送广播时，其他的应用程序只能被动地接收广播数据。这就象电台进行广播一样，听众只能被动地收听，而不能主动与电台进行沟通。\n在应用程序中发送广播比较简单。只需要调用sendBroadcast方法即可。该方法需要一个Intent对象。通过Intent对象可以发送需要广播的数据。\n#### AIDL Service\n这是我个人比较推崇的方式，因为它相比Broadcast而言，虽然实现上稍微麻烦了一点，但是它的优势就是不会像广播那样在手机中的广播较多时会有明显的时延，甚至有广播发送不成功的情况出现。\n注意普通的Service并不能实现跨进程操作，实际上普通的Service和它所在的应用处于同一个进程中，而且它也不会专门开一条新的线程，因此如果在普通的Service中实现在耗时的任务，需要新开线程。\n要实现跨进程通信，需要借助AIDL(Android Interface Definition Language)。Android中的跨进程服务其实是采用C/S的架构，因而AIDL的目的就是实现通信接口。\n[AIDL具体使用可参考](http://www.jianshu.com/p/d1fac6ccee98)\n\n### 什么是AIDL？\nAIDL:Android Interface Definition Language,即Android接口定义语言。\n\nAndroid系统中的进程之间不能共享内存，因此，需要提供一些机制在不同进程之间进行数据通信。为了使其他的应用程序也可以访问本应用程序提供的服务，Android系统采用了远程过程调用（Remote Procedure Call，RPC）方式来实现。与很多其他的基于RPC的解决方案一样，Android使用一种接口定义语言（Interface Definition Language，IDL）来公开服务的接口。我们知道4个Android应用程序组件中的3个（Activity、BroadcastReceiver和ContentProvider）都可以进行跨进程访问，另外一个Android应用程序组件Service同样可以。因此，可以将这种可以跨进程访问的服务称为AIDL（Android Interface Definition Language）服务。\n### AIDL的使用\n因为是两个APP交互么，所以当然要两个APP啦，我们在第一个工程目录右键\n![](https://upload-images.jianshu.io/upload_images/2099385-d68440c5786c6047.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/659/format/webp)\n输入名称后，sutido就帮我们创建了一个AIDL文件。\n```\n// IMyAidlInterface.aidl\npackage cc.abto.demo;\n\n// Declare any non-default types here with import statements\n\ninterface IMyAidlInterface {\n    /**\n     * Demonstrates some basic types that you can use as parameters\n     * and return values in AIDL.\n     */\n    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,\n            double aDouble, String aString);\n}\n```\n上面就是studio帮我生成的aidl文件。basicTypes这个方法可以无视，看注解知道这个方法只是告诉你在AIDL中你可以使用的基本类型（int, long, boolean, float, double, String），因为这里是要跨进程通讯的，所以不是随便你自己定义的一个类型就可以在AIDL使用的，这些后面会说。我们在AIDL文件中定义一个我们要提供给第二个APP使用的接口。\n```\ninterface IMyAidlInterface {\n   String getName();\n}\n```\n定义好之后，就可以sycn project一下，然后新建一个service。在service里面创建一个内部类，继承你刚才创建的AIDL的名称里的Stub类,并实现接口方法,在onBind返回内部类的实例。\n```\npublic class MyService extends Service\n{\n\n    public MyService()\n    {\n\n    }\n\n    @Override\n    public IBinder onBind(Intent intent)\n    {\n        return new MyBinder();\n    }\n\n    class MyBinder extends IMyAidlInterface.Stub\n    {\n\n        @Override\n        public String getName() throws RemoteException\n        {\n            return \"test\";\n        }\n    }\n}\n```\n接下来，将我们的AIDL文件拷贝到第二个项目，然后sycn project一下工程。\n![](https://upload-images.jianshu.io/upload_images/2099385-585fbc5fb15906e8.png?imageMogr2/auto-orient/strip|imageView2/2/w/314/format/webp)\n**这边的包名要跟第一个项目的一样哦，这之后在Activity中绑定服务。**\n```\n\npublic class MainActivity extends AppCompatActivity {\n\n    private IMyAidlInterface iMyAidlInterface;\n    ServiceConnection conn;\n    private static final String TAG = \"MainActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Intent intent = new Intent();\n        intent.setAction(\"com.mark.aidldemo1\");\n        intent.setPackage(\"com.mark.aidldemo1\");\n\n        conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n\n            }\n        };\n        bindService(intent, conn, BIND_AUTO_CREATE);\n    }\n\n    @Override\n    protected void onStop() {\n        unbindService(conn);\n        super.onStop();\n    }\n\n    public void doTest(View view) {\n        try {\n            if (iMyAidlInterface!=null) {\n                Toast.makeText(this, iMyAidlInterface.getName(), Toast.LENGTH_SHORT).show();\n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n这边我们通过隐式意图来绑定service，在onServiceConnected方法中通过IMyAidlInterface.Stub.asInterface(service)获取iMyAidlInterface对象，然后在onClick中调用iMyAidlInterface.getName()。\n![](https://upload-images.jianshu.io/upload_images/2099385-0bc46eaf6923f712.png?imageMogr2/auto-orient/strip|imageView2/2/w/564/format/webp)\n\n### 自定义类型\n如果我要在AIDL中使用自定义的类型，要怎么做呢。首先我们的自定义类型要实现Parcelable接口，下面的代码中创建了一个User类并实现Parcelable接口。这边就不对Parcelable进行介绍了，不熟悉的童鞋自行查找资料，总之我们这边可以借助studio的Show Intention Action（也就是Eclipse中的Quick Fix，默认是alt+enter键）帮我们快速实现Parcelable接口。\n![](https://upload-images.jianshu.io/upload_images/2099385-575c252bdc2790f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/615/format/webp)\n\n接下新建一个aidl文件，名称为我们自定义类型的名称，这边是User.aidl。在User.aidl申明我们的自定义类型和它的完整包名，注意这边parcelable是小写的，不是Parcelable接口，一个自定类型需要一个这样同名的AIDL文件。\n```\npackage com.mark.aidldemo1;\nparcelable User;\n```\n然后再在我们的AIDL接口中导入我们的AIDL类型。\n```\nimport com.mark.aidldemo1.User;\n\n// Declare any non-default types here with import statements\n\ninterface IMyAidlInterface {\n   String getName();\n   User getUserName();\n}\n```\n然后定义接口方法，sycn project后就可以在service中做具体实现了。\n```\n  class MyBinder extends IMyAidlInterface.Stub\n    {\n\n       ........\n\n        @Override\n        public User getUserName() throws RemoteException {\n            return new User(\"Mark\");\n        }\n    }\n```\n最后将我们的AIDL文件和自定义类型的java一并拷贝到第二个项目，注意包名都要一样哦\n\n![](https://upload-images.jianshu.io/upload_images/2099385-63e992963f1bd552.png?imageMogr2/auto-orient/strip|imageView2/2/w/246/format/webp)\n然后就可以在Activity中使用该自定义类型的AIDL接口了\n```\npublic class MainActivity extends AppCompatActivity\n{\n    //...\n    public void onClick(View view)\n    {\n        try\n        {\n            Toast.makeText(MainActivity.this, iMyAidlInterface.getUserName().getName(), Toast.LENGTH_SHORT).show();\n        }\n        catch (RemoteException e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n```\nAIDL只是Android中众多进程间通讯方式中的一种方式,[我的代码](https://gitee.com/markshow/msg-ipc)\n\n### [下一章长链接推送](http://markchyl.cn/2020/10/19/Android%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93-%E4%BA%94/)","tags":["消息通信","AIDL"],"categories":["Android"]},{"title":"Android消息传递机制总结(三)","url":"/2020/10/10/Android消息传递机制总结三/","content":"第三方通信 ——— EventBus，rxBus\n### 3. 第三方通信\n\nEventBus主要角色:\n> Event 传递的事件对象\n Subscriber  事件的订阅者 \n Publisher  事件的发布者\n ThreadMode 定义函数在何种线程中执行\n<!-- more -->\n定义一个事件类型\n```\npublic class DataEvent {\n    private int count;\n\n    public int getCount() {\n        return count;\n    }\n\n    public void setCount(int count) {\n        this.count = count;\n    }\n}\n```\n```\n//订阅\n\nEventBus.getDefault().register(this);//订阅\n\n //解除订阅\n\nEventBus.getDefault().unregister(this);//解除订阅\n\n//发布事件\n\nEventBus.getDefault().post(new DataEvent());\n\n//订阅事件处理\n\n    @Subscribe(threadMode = ThreadMode.MAIN) //在ui线程执行\n    public void onDataEvent(DataEvent event) {\n        Log.e(TAG, \"event---->\" + event.getCount());\n    }\n```\n#### ThreadMode总共四个：\n```\nNAIN UI主线程\nBACKGROUND 后台线程\nPOSTING 和发布者处在同一个线程\nASYNC 异步线程\n```\n#### 事件的优先级类似广播的优先级，优先级越高优先获得消息\n ```\n @Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100\n    public void onDataEvent(DataEvent event) {\n        Log.e(TAG, \"event---->\" + event.getCount());\n    }\n```\n\n#### 终止事件往下传递\n发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能\n```\n EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递\n ```\n#### EventBus黏性事件\n何为黏性事件呢？简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。\n\n本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加sticky = true\n\n```\n  @Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行\n    public void onDataEvent(DataEvent event) {\n        Log.e(TAG, \"event---->\" + event.getCount());\n    }\n\n//发送粘性事件\n\n  EventBus.getDefault().postSticky(new DataEvent());\n\n//对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除\n\n  EventBus.getDefault().removeStickyEvent(new DataEvent());\n\n//或者调用移除所有粘性事件\n\n  EventBus.getDefault().removeAllStickyEvents();\n\n\n```\nRXBus：如果项目中用了rxjava的话可以参考https://github.com/AndroidKnife/RxBus 自己封装一个。\n\n### [下一章长链接推送](http://markchyl.cn/2020/10/12/Android%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93-%E5%9B%9B/)","tags":["消息通信"],"categories":["Android"]},{"title":"Android消息传递机制总结(二)","url":"/2020/10/10/Android消息传递机制总结二/","content":"组件间通信 ——— BroadcastReceiver，接口回调等。\n### 2.组件间通信\nBroadcastReceiver广播就不再介绍， 广播传递本身是有安全隐患的，需要设置权限，每一个Activity都要定义、注册，解注册广播无形中加大了工作量和维护成本。已经不适应用在组件间通信。\n<!-- more -->\n接口回调： 和观察者模式大致一样。\n实例：\n```\n\npublic class DataSynManager {\n    //监听集合\n    private LinkedList<IDataSynListener> autoListeners = new LinkedList<>();\n    //单例引用\n    private static DataSynManager mInstance;\n\n    /**\n     * 获取单例引用\n     *\n     * @return\n     */\n    public static DataSynManager getInstance() {\n        if (mInstance == null) {\n            synchronized (DataSynManager.class) {\n                if (mInstance == null) {\n                    mInstance = new DataSynManager();\n                }\n            }\n        }\n        return mInstance;\n    }\n\n    /**\n     * 添加同步数据监听\n     *\n     * @param listener\n     */\n    public void registerDataSynListener(IDataSynListener listener) {\n        if (autoListeners == null) {\n            autoListeners = new LinkedList<>();\n        }\n        if (!autoListeners.contains(listener)) {\n            autoListeners.add(listener);\n        }\n    }\n\n    /**\n     * 移除同步数据监听\n     *\n     * @param listener\n     */\n    public void unRegisterSynListener(IDataSynListener listener) {\n        if (autoListeners == null) {\n            return;\n        }\n        if (autoListeners.contains(listener)) {\n            autoListeners.remove(listener);\n        }\n    }\n\n    /**\n     * 执行数据同步\n     *\n     * @param count\n     */\n    public void doDataSyn(final int count) {\n        if (autoListeners == null) {\n            autoListeners = new LinkedList<>();\n        }\n        new Handler().post(new Runnable() {\n            @Override\n            public void run() {\n                for (IDataSynListener dataSynListener :\n                        autoListeners) {\n                    dataSynListener.onDataSyn(count);\n                }\n            }\n        });\n    }\n\n    /**\n     * 清除所有监听者\n     */\n    public void release() {\n        if (autoListeners != null) {\n            autoListeners.clear();\n            autoListeners = null;\n        }\n    }\n\n    public interface IDataSynListener {\n        void onDataSyn(int count);\n    }\n}\n\n```\n使用：\n```\n//添加监听\nDataSynManager.getInstance().registerDataSynListener(dataSynListener);\n//移除监听\nDataSynManager.getInstance().unRegisterDataSynListener(dataSynListener//个监听);\n\n\nDataSynManager.IDataSynListener dataSynListener=new DataSynManager.IDataSynListener() {\n        @Override\n        public void onDataSyn(int count) {\n            //接下来执行同步操作\n        }\n      }\n\n   };\n//发送事件\nDataSynManager.getInstance().doDa(5);\n```\n[3. 第三方通信 ——— EventBus，rxBus](http://markchyl.cn/2020/10/10/Android%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%E4%B8%89/)","tags":["消息通信"],"categories":["Android"]},{"title":"Android消息传递机制总结(一)","url":"/2020/10/09/Android消息传递机制总结(一）/","content":"#### 安卓业务层的核心灵魂就是层层的消息传递，今天就来总结一下andorid的应用层的各种消息传递。\n\n1.线程间通讯 ——— Handler，HandlerThread等。\n2.组件间通信 ——— BroadcastReceiver，接口回调等。\n3. 第三方通信 ——— EventBus，rxBus\n4.进程间通信 ——— Content Provider ，Broadcast ，AIDL等。\n5.长连接推送 ——— WebSocket，XMPP等。\n### 1.线程间通信\nAndroid通过Handler消息机制来实现线程之间的通讯。\n<!-- more -->\n\n#### Handler机制主要角色\n```\nMessage：消息，其中包含了消息ID，消息处理对象以及处理的数据等，由MessageQueue统一列队，终由Handler处理。 \nHandler：处理者，负责Message的发送及处理。使用Handler时，需要实现handleMessage(Message msg)方法来对特定的Message进行处理，例如更新UI等。 \nMessageQueue：消息队列，用来存放Handler发送过来的消息，并按照FIFO规则执行。当然，存放Message并非实际意义的保存，而是将Message以链表的方式串联起来的，等待Looper的抽取。 \nLooper：消息泵，不断地从MessageQueue中抽取Message执行。因此，一个MessageQueue需要一个Looper。\nThread：线程，负责调度整个消息循环，即消息循环的执行场所。\n```\n#### Handler机制主要运用\n```\nsendEmptyMessage(int);//发送一个空的消息\nsendMessage(Message);//发送消息，消息中可以携带参数\nsendMessageAtTime(Message, long);//未来某一时间点发送消息\nsendMessageDelayed(Message, long);//延时Nms发送消息\n\npost(Runnable);//提交计划任务马上执行\npostAtTime(Runnable, long);//提交计划任务在未来的时间点执行\npostDelayed(Runnable, long);//提交计划任务延时Nms执行\n```\n#### 主进程定义Handler\n```\n private Handler mHandler = new Handler() {\n\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what) {\n                case 0:\n                    //完成主界面更新,拿到数据\n                    String data = (String) msg.obj;\n                    tvTest.setText(data);\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n```\n#### 子线程执行耗时操作然后发消息，通知Handler完成UI更新\n```\nprivate void getDataFromNet() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n              //需要数据传递，用下面方法；\n                Message msg = new Message();\n                msg.obj = \"网络数据\";//可以是基本类型，可以是对象，可以是List、map等；\n                mHandler.sendMessage(msg);\n            }\n        }).start();\n    }\n```\nHandler机制扩展：\n\nActivity.runOnUiThread(Runnable)\nView.post(Runnable)\n以上也可以从子线程切换到主线程。\n```\n runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                tvTest2.setText(\"runOnUiThread\");\n            }\n        });\n```\n\n#### HandlerThread：\nHandlerThread本质上就是一个普通Thread,只不过内部建立了Looper.\nHandlerThread用法实例\n```\n //创建一个线程,线程名字：handler-thread\n        mHThread = new HandlerThread(\"handler-thread\");\n        //开启一个线程\n        mHThread.start();\n        //在这个线程中创建一个handler对象 主要这个handler是在子线程中循环接受消息的\n        handler = new Handler(mHThread.getLooper()) {\n            @Override\n            public void handleMessage(@NonNull Message msg) {\n                super.handleMessage(msg);\n                //这个方法是运行在 handler-thread 线程中的 ，可以执行耗时操作\n                Log.d(\"handler \", \"消息： \" + msg.what + \"  线程： \" + Thread.currentThread().getName());\n            }\n        };\n\n        //在主线程给handler发送消息\n        handler.sendEmptyMessage(1);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //在子线程给handler发送数据\n                handler.sendEmptyMessage(2);\n            }\n        }).start();\n\n\n        @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        //释放资源\n        mHThread.quit();\n    }\n```\n\n#### Looper的quit方法或quitSafely方法\n相同点：\n将不在接受新的事件加入消息队列。\n\n不同点\n当我们调用Looper的quit方法时，实际上执行了MessageQueue中的removeAllMessagesLocked方法，该方法的作用是把MessageQueue消息池中所有的消息全部清空，无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息。\n\n当我们调用Looper的quitSafely方法时，实际上执行了MessageQueue中的removeAllFutureMessagesLocked方法，通过名字就可以看出，该方法只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理，quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。\n\n无论是调用了quit方法还是quitSafely方法只会，Looper就不再接收新的消息。即在调用了Looper的quit或quitSafely方法之后，消息循环就终结了，这时候再通过Handler调用sendMessage或post等方法发送消息时均返回false，表示消息没有成功放入消息队列MessageQueue中，因为消息队列已经退出了。\n\n需要注意的是Looper的quit方法从API Level 1就存在了，但是Looper的quitSafely方法从API Level 18才添加进来。\n\n我在直播推流中应用了HandlerThread，每编码组装出来一帧视频就发送一个handler消息，然后HandlerThread线程接收消息数据并用libRtmp推倒服务器。此时可以监控队列中有多少消息在循环，可以监听进出队列的比例，如果超出一定的范围说明网络不好，需要执行丢帧策略。\n\n### Handler 面试八问\n* 为什么主线程不会因为 `Looper.loop()` 里的循环卡死？\n    >主线程确实是通过`Looper.loop()` 进入了循环状态，因为这样主线程才不会像我们一般创建的线程一样，当可执行代码执行完后，线程生命周期就终止了。\n    在主线程的`MessageQueue` 没有消息时，便阻塞在`MeqsageQueue.next()` 中的`nativePollOnce()`方法里，此时主线程会释放 `CPU`资源进入休眠状态，直到新消息达到。所以主线程大多数时候都是处于休眠状态，并不会消耗大量`CPU`资源。\n    这里采用的`linux`的`epoll` 机制，是一种 `IO` 多路复用机制，可以同时监控多个文件描述符，当某个文件描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作拿到最新的消息，进而唤醒等待的线程。\n\n* `post`和`sendMessage`两类发送消息的方法有什么区别?\n    >`post`一类的方法发送的是 `Runnable`对象，但是其最后还是会被封装成`Message` 对象，将`Runnable` 对象赋值给 `Message` 对象中的`callback`变量，然后交由 `sendMessageAtTime() `方法发送出去。在处理消息时，会在`dispatchMessage()`方法里首先被`handleCallback(msg)`方法执行，实际上就是执行 `Message` 对象里面的 `Runnable` 对象的run 方法。\n    而`sendMessage` 一类的方法发送的直接是`Message`对象，处理消息时，在 `dispatchMessage`里优先级会低于`handleCallback(msg)`方法，是通过自己重写的`handleMessage(msg)` 方法执行。\n\n* 为什么要通过 `Message.obtain()` 方法获取 Message 对象?\n    >`obtain `方法可以从全局消息池中得到一个空的` Message`对象，这样可以有效节省系统资源。同时，通过各种`obtain`重载方法还可以得到一些`Message`的拷贝，或对`Message`对象进行一些初始化。\n\n* Handler实现发送延迟消息的原理是什么?\n    > 我们常用`postDelayed()`与`sendMessageDelayed()` 来发送延迟消息，其实最终都是将延迟时间转为确定时间，然后通过`sendMessageAtTime()` -> `enqueueMessage` ->\n    `queue.enqueueMessage`这一系列方法将消息插入到`MessageQueue`中。所以并不是先延迟再发送消息，而是直接发送消息，再借助`MessageQueue`的设计来实现消息的延迟处理。\n    消息延迟处理的原理涉及`MessageQueue`的两个静态方法 `MessageQueue.next()`和\n    `MessageQueue.enqueueMessage()`。通过`Native`方法阻塞线程一定时间，等到消息的执行时间到后再取出消息执行。\n\n* 同步屏障 `SyncBarrier`是什么?有什么作用?\n    >在一般情况下，同步和异步消息处理起来没有什么不同。只有在设置了同步屏障后才会有差异。同步屏障从代码层面上看是一个`Message` 对象，但是其`target`属性为`null`，用以区分普通消息。在`MessageQueue.next()`中如果当前消息是一个同步屏障，则跳过后面所有的同步消息，找到第一个异步消息来处理。\n    但是开发者调用不了。在`ViewRootlmpl`的UI测绘流程有体现\n\n* `IdleHandler` 是什么?有什么作用?\n    >当消息队列没有消息时调用或者如果队列中仍有待处理的消息，但都未到执行时间时，也会调用此方法。用以监听主线程空闲状态。\n\n* 为什么非静态类的`Handler`导致内存泄漏?如何解决?\n    > 首先，非静态的内部类、匿名内部类、局部内部类都会隐式的持有其外部类的引用。也就是说在 `Activity`中创建的,Handler会因此持有`Activity`的引用。\n    当我们在主线程使用`Handler`的时候，Handler会默认绑定这个线程的`Looper`对象，并关联其`MessageQueue，Handler`发出的所有消息都会加入到这个`MessageQueue`中。`Looper`对象的生命周期贯穿整个主线程的生命周期，所以当Looper对象中的MessageQueue里还有未处理完的` Message`时，因为每个`Message`都持有`Handler`的引用，所以`Handler`无法被回收，自然其持有引用的外部类` Activity `也无法回收，造成泄漏。\n    **使用静态内部类+弱引用的方式**\n\n* 如何让在子线程中弹出toast\n    >调用`Looper.prepare`以及`Looperloop()`，但是切记线程任务执行完，需要手动调用`Looper.quitSafely()`否则线程不会结束。\n\n\n\n[下一章: 组件间通信](http://markchyl.cn/2020/10/10/Android%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%E4%BA%8C/)","tags":["消息通信"],"categories":["Android"]},{"title":"dynamic、var、Object三者的区别","url":"/2020/09/23/dynamic、var、Object三者的区别/","content":"### dynamic：\n是所有Dart对象的基础类型， 在大多数情况下，通常不直接使用它，\n通过它定义的变量会关闭类型检查，这意味着 \n`dynamic x = 'hal';x.foo();`\n这段代码静态类型检查不会报错，但是运行时会crash，因为x并没有foo()方法，所以建议大家在编程时不要直接使用dynamic；\n### var：\n是一个关键字，意思是“我不关心这里的类型是什么。”，系统会自动推断类型runtimeType；\n### Object：\n是Dart对象的基类，当你定义：Object o=xxx；时这时候系统会认为o是个对象，你可以调用o的toString()和hashCode()方法\n因为Object提供了这些方法，但是如果你尝试调用o.foo()时，静态类型检查会进行报错；\n\n### 总结：\n综上不难看出dynamic与Object的最大的区别是在静态类型检查上；","tags":["dart"],"categories":["flutter"]},{"title":"阿里、腾讯、百度、华为、京东、搜狗和滴滴最新面试题汇集","url":"/2020/09/03/阿里、腾讯、百度、华为、京东、搜狗和滴滴最新面试题汇集/","content":"\n[原文链接  程序员小乐](https://mp.weixin.qq.com/s/IN30Gc1o23fJ8wYEpp8AMQ)\n\n以下是（2016、2017 、阿里、腾讯、百度、华为、京东、搜狗和滴滴面试题汇集）\n\n## Android基础\n### 1、什么是ANR 如何避免它？\nANR 就是一个无响应的对话框,主要原因就是在主线程做了耗时操作。\n>全称为Application Not Responding。在Android 中，如果你的应用程序有一段时间没有响应，系统会向用户显示一个对话框，这个对话框称作应用程序无响应对话框。\n不同的组件发生ANR 的时间不一样，\n* 主线程（Activity）是5 秒;\n* BroadCastReceiver 是10 秒;\n* Service：20 秒（均为前台）,Service 在20 秒内无法处理完成。\n\n**解决方案：**\n* 将所有耗时操作，比如访问网络，Socket 通信，查询大量SQL 语句，复杂逻辑计算等都放在子线程中去，然后通过handler.sendMessage、runonUITread、AsyncTask 等方式更新UI，以确保用户界面操作的流畅度.\n* 如果耗时操作需要让用户等待，那么可以在界面上显示进度条。\n* 避免在activity里面做耗时操作，oncreate & onresume\n* 避免在onReceiver里面做过多操作\n* 避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。\n\n### 2、View的绘制流程；自定义View如何考虑机型适配；自定义View的事件\n>View的绘制流程：OnMeasure()——>OnLayout()——>OnDraw()\n组合控件、继承原有的控件、继承原有的控件\n* 第一步：OnMeasure()：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。\n* 第二步：OnLayout()：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。\n* 第三步：OnDraw()：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：绘制视图的背景、保存画布的图层(Layer)、绘制View的内容、绘制View子视图、还原图层(Layer)、绘制滚动条（如果没有就不用）;\n\n### 3、分发机制；View和ViewGroup分别有哪些事件分发相关的回调方法；自定义View如何提供获取View属性的接口；\n> 基本会遵从 Activity => ViewGroup => View 的顺序进行事件分发，然后通过调用 onTouchEvent() 方法进行事件的处理。我们在项目中一般会对 MotionEvent.ACTION_DOWN，MotionEvent.ACTION_UP，MotionEvent.ACTION_MOVE，MotionEvent.ACTION_CANCEL 分情况进行操作。\n\n\n<!-- more -->\n\n4、Art和Dalvik对比；虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)；JVM内存模型及类加载机制；内存对象的循环引用及避免；\n\n### 4、ddms 和 traceView；\n* 1， ddms：是android开发环境中的dalvik虚拟机调试监控服务；\nddms能够提供，测试设备截屏，针对特定的进程查看正在运行的线程以及堆信息，Logcat，广播状态信息，模拟电话呼叫，接收sms，虚拟地理坐标等。\n\n* 2，traceView是android平台配备的性能分析的工具；它可以通过图形化让我们了解要跟踪的程序的性能，并且能具体到方法。\n\n区别：ddms是一个程序执行查看器，在里面可以看见线程和堆栈等信息，traceView是程序性能分析器。\n\n### 5、内存回收机制与GC算法(各种算法的优缺点以及应用场景)；GC原理时机以及GC对象；内存泄露场景及解决方法；\ngc是java的垃圾回收机制\n\n引用计数法（Reference Counting Collector）:使用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。\n\n标记算法（Tracing Collector):使用了根集的概念，基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象。\n\n整理算法（Compacting Collecotr）：该算法会将所有的对象移到堆的一端。能解决堆碎片的问题。\n\n复制算法：将内存分为两个区域（from space 和 to space）。所有的对象都分配到from space。清理时先将所有标为活动对象copy到to space，然后清除from space空间。然后互换from space和to apce的身份，每次清理都重复上述过程。\ngc收集器：\n\nserial收集器：单线程，工作时必须暂停其他工作线程，多用于client机器上，使用复制算法。\n\nParNew收集器：serial的多线程版本，server模式下jvm首选的新生代收集器。复制算法。\n\nParallel Scavenge收集器：可控制吞吐量的收集器，吞吐量指有效运行时间。复制算法。\n\nSerial Old收集器：serial的老年代版本，使用整理算法。\n\nParallel Old收集器：Parallel Scavenge收集器的老版本，多线程，标记整理。\n\nCMS收集器：整理算法。最短回收停顿时间，缺点是产生碎片。\n\nGI收集器：基本思想是化整为零，将堆分为多个Region，优先回收价值最大的Region。并行并发，分代收集，空间整合。整理算法。\n\n6、四大组件及生命周期；ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)；Activity的四种启动模式对比；Activity状态保存于恢复；\n\n### 7、什么是AIDL 以及如何使用；\n>AIDL是Android Interface Definition Language的简写，即Android接口定义语言。\n当一个应用想要访问另一个应用的数据或调用其方法，就要用到Android系统提供的IPC机制。而AIDL就是Android实现IPC机制的方式之一。\nAIDL是使用bind机制来工作。\nAIDL:android interface definition language的缩写。\nAIDL是用来实现进程间通信的，可以帮我们实现发布以及调用远程服务。\n使用：\n1）服务端：创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将服务端暴露给客户端的接口在这个文件中声明，最后在Service中实现这个AIDL接口。\n2）客户端：首先绑定服务端的Service，绑定成功后将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法。\n\n### 8、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系；\n>简单的说，Handler 获取当前线程中的 Looper 对象，Looper 用来从存放 Message 的MessageQueue 中取出 Message，再交由 Handler 进行 Message 的分发和处理。\n\n9、Fragment生命周期；Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用应该如何解耦；\n\n10、AsyncTask原理及不足；intentService原理；\n\n### 11、Activity 怎么和Service 绑定，怎么在Activity 中启动自己对应的Service；\n>Activity 通过 bindService(Intent service, ServiceConnection conn, int flags)跟 Service 进行绑定，当绑定成功的时候 Service 会将代理对象通过回调的形式传给 conn，这样我们就拿到了 Service 提供的服务代理对象。\n在 Activity 中可以通过 startService 和 bindService 方法启动 Service。\n\n>一般情况下如果想获取 Service 的服务对象那么肯定需要通过bindService（）方法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么可以使用 startService（）方法。\n\n\n### 12、请描述一下Service 的生命周期；\n>启动Service时可调用startService和bindService()方法来启动，用这两种方法启动的Service的生命周期是不同的。\n\n启动服务的生命周期 onCreate->onStartCommand()->onDestroy()\n绑定服务的生命周期 onCreate()->onBind()->onUnBind()->onDestroy()\n途径一：\n调用Context.startService()启动Service，调用Context.stopService()或Service.stopSelf()或Service.stopSelfResult()关闭Service的调用。\n生命周期顺序为：onCreate()->onStart()->onDestroy()\n\n途径二：\n调用Context.bindService()进行初始化绑定，使用Context.unbindService()取消绑定，由于Service和Context是绑定关系，当Context退出或被销毁时，Service也会相应退出。\n生命周期顺序为：onCreate->onBind(只一次，不可多次绑定)->onUnbind->onDestroy()\n\nBroadcastReceiver只能通过startService启动Service，因为广播本身生命周期很短，bind的话没有意义,通过bindService创建的服务（但仍然通过bindService得到了服务对象），就可能unbindService后还在运行，否则应该是结束掉了。\n\n13、AstncTask+HttpClient与AsyncHttpClient有什么区别；\n\n### 14、如何保证一个后台服务不被杀死；比较省电的方式是什么；\nAndroid中通过Service实现后台任务。\n* 方法一：\n通过将Service绑定到Notification，成为一个前提服务，可以提高存活率\n在Service中创建一个Notification，再调用Service.startForeground(int id,Notification notification)方法运行在前台即可。这个方式使用360等如阿健管家可以杀死。\n\n* 方法二：\n通过定时警报来不断启动Service，这样就算Service被杀死，也能再启动。同时也可以监听网络切换，开锁屏等广播启动Service。\n参考：\nIntent intent = new Intent（mContext，MyService.class）；\nPendingIntent sender = PendingIntent.getService(mContext,0,intent,0);\nAlarmManager alarm = (AlarmManager)getSystemService(ALARM_SERVICE);\nalarm.setRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),5*10000,sender);\n这种方式不断启动的逻辑处理起来很麻烦。\n\n* 方法三：\n通过jni调用c，在c语音中启动一个进程fork（）。 可以保证360等手机管家不会清理。但是带来了jni交互，稍微有点麻烦。\n  \n[android如何保证service不被杀死](http://www.voidcn.com/article/p-vaqywkec-go.html)\n\n15、如何通过广播拦截和abort一条短信；广播是否可以请求网络；广播引起anr的时间限制；\n\n16、进程间通信，AIDL；\n\n### 17、事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？\n**区别：**\n>onTouch方法优先级比onTouchEvent高，会先触发。假如onTouch方法返回false，会接着触发onTouchEvent，反之onTouchEvent方法不会被调用。内置诸如click事件的实现等等都基于onTouchEvent，假如onTouch返回true，这些事件将不会被触发。\n\n**使用：**\n * 1、onTouch()方法：\n> onTouch方式是View的OnTouchListener接口中定义的方法。当一个View绑定了OnTouchListener后，当有Touch事件触发时，就会调用onTouch方法。\n * 2、onTouchEvent()方法：\n> onTouchEvent方法时重载的Activity的方法 重写了Acitivity的onTouchEvent方法后，当屏幕有Touch事件时，此方法就会被调用。\n\n18、说说ContentProvider、ContentResolver、ContentObserver 之间的关系；\n\n### 19、请介绍下ContentProvider 是如何实现数据共享的；\nAndroid提供了ContentProvider，一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvicer是以类似数据库中表的方式将数据暴露。也就是说ContentProvider就像一个“数据库”。那么外界获取其提供的数据，也就应该与从数据库中获取数据的操作基本一样，只不过是采用URI来表示外界需要访问的“数据库”。外部访问通过ContentResolver去访问并操作这些被暴露的数据。\n\n### 20、Handler机制及底层实现；\nHandler包括四个角色：\n* Handler：负责发送消息处理消息。\n* Message：消息实体对象，handler通过sendMessage将实体放到消息队列中。\n* MessageQueQue:存放消息的队列。\n* Looper：消息轮询器，不停的从消息队列中取出消息交给handler处理。\n  \n在主线程创建Handler，在需要发送消息的地方创建一个Message，通过handler发送。这个消息存到MessageQueQue中，然后Looper会将这个消息取出交给handler处理。\n\n### 21、Binder机制及底层实现；\nBinder包含四个角色：\n* Server 服务器\n* Client 客户终端 ，获得实名Binder的引用。Server向ServiceManger注册了Binder实体及名字后，Client就可以通过名字获得该Binder的引用。例如我们申请获得名字叫张三的Binder的引用，ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字。再找到该名字对应的条目，从条目中取出Binder的引用。将该引用作为回复发送给发起请求的Client。\n* ServiceManager 域名服务器（DNS），负责将字符形式的Binder名字转化成Client中对该Binder的应用，使得Client能通过Binder名字获得Server中Binder实体的引用。\n* Binder驱动 可以理解为路由器。Binder驱动负责进程之间Binder通信的建立，Binder在进程间的传递。Binder使用Client-Server通信方式，安全性好，简单高效。再加上其面向对象的设计思想，独特的接收缓存管理和线程池管理方式，成为Android进程间通信的中流砥柱。\n\n### 22、ListView 中图片错位的问题是如何产生的；\n错位原理： 如果我们只是简单的显示数据，没有convertView的复用和异步操作，就不会产生图片错位。重用convertView但没有异步操作也不会有错位现象。\n\n例如我们的listView中刚好显示7个item，当向下滑动时，显示出item8，而item8是重用的item1，如果此时异步网络请求item8的图片，比item1的图片慢，那么item8就会显示item1的图片。当item8下载完成，此时用户向上滑显示item1时，又复用的item8的image。这样就导致的图片错位。\n\n解决方法： 对imageview设置tag，并预设一张图片。\n\n### 23、在manifest 和代码中如何注册和使用BroadcastReceiver；\n```\n<receiver android:name=\"包名.自己扩展的广播接收者名\">\n   <intent-filter>\n      <action android:name=\"android.provider.Telephony.SMS_RECEIVED\"/>\n   </intent-filter>\n</receiver>\n```\n\n24、说说Activity、Intent、Service 是什么关系；\n\n### 25、ApplicationContext和ActivityContext的区别；\n>这是两种不同的context，也是最常见的两种.第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次.至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context\n\n26、一张Bitmap所占内存以及内存占用的计算；\n\n### 27、Serializable 和Parcelable 的区别；\n>在Android上应该尽量采用Parcelable，它效率更高。\nParcelabe代码比Serializable多一些。\nParcelabe比Serializable速度高十倍以上。\nSerializable只需要对某个类以及它的属性实现Serializable接口即可，无需实现方法。缺点是使用的反射，序列化的过程较慢，这种机制会在序列化的时候创建许多的临时对象。容易触发GC。\nParcable方法实现的原理是将一根完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能。\n\n28、请描述一下BroadcastReceiver；\n\n29、请描述一下Android 的事件分发机制；\n\n30、请介绍一下NDK；\n\n31、什么是NDK库，如何在jni中注册native函数，有几种注册方式；\n\n32、AsyncTask 如何使用；\n\n33、对于应用更新这块是如何做的？(灰度，强制更新，分区域更新)；\n\n34、混合开发，RN，weex，H5，小程序(做Android的了解一些前端js等还是很有好处的)；\n\n### 35、什么情况下会导致内存泄露；\n根本原因：长生命周期的对象持有短生命周期的对象。短周期对象就无法及时释放。\n* 静态集合类引起内存泄露\n* remove 方法无法删除set集  Objects.hash(firstName, lastName);\n* observer 我们在使用监听器的时候，往往是addxxxlistener，但是当我们不需要的时候，忘记removexxxlistener，就容易内存leak。广播没有unregisterrecevier\n* 各种数据链接没有关闭，数据库contentprovider，io，sokect等。cursor\n* 内部类\n* 单例\n  单例 是一个全局的静态对象，当持有某个复制的类A是，A无法被释放，内存leak。\n\n### 36、如何对Android 应用进行性能分析以及优化；\n>android 性能主要之响应速度 和UI刷新速度。\n* 首先从函数的耗时来说，有一个工具TraceView 这是androidsdk自带的工作，用于测量函数耗时的。\n\n* UI布局的分析，可以有2块，一块就是Hierarchy Viewer 可以看到View的布局层次，以及每个View刷新加载的时间。这样可以很快定位到那块layout & View 耗时最长。\n\n* 还有就是通过自定义View来减少view的层次。\n\n37、说一款你认为当前比较火的应用并设计(直播APP)；\n\n### 38、OOM的避免异常及解决方法；\n当前占用的内存加上app申请的内存资源超过了Dvlvik虚拟机的最大内存限制导致抛出Out of memory异常。\n\n\n### 39、屏幕适配的处理技巧都有哪些；\n屏幕适配的方式：xxxdpi， wrap_content,match_parent. 获取屏幕大小，做处理。\n\n* dp来适配屏幕，sp来确定字体大小\n\n* drawable-xxdpi, values-1280*1920等 这些就是资源的适配。\n\n* wrap_content,match_parent, 这些是view的自适应\n\n* weight，这是权重的适配。\n\n40、两个Activity 之间跳转时必然会执行的是哪几个方法？\n\n40、Okhttp原理\n\n41、Rxjava用法和原理\n\n42，热更新技术有哪些，知道的原理！\n\n43、Activity启动流程\n\n44、Android内存管理\n\n45、Android权限管理\n\n46、将一下7.0的新特性\n\n47、说下你你们项目的架构\n\n48、组件化的有点和具体实施方案\n\n49、内存泄露检测方法\n\n50、Http协议，SSL握手机制。\n\n## Java基础\n\n1、集合类以及集合框架；HashMap与HashTable实现原理，线程安全性，hash冲突及处理算法；ConcurrentHashMap；\n\n2、进程和线程的区别；\n\n3、Java的并发、多线程、线程模型；\n\n4、什么是线程池，如何使用?\n答：线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。\n\n5、数据一致性如何保证；Synchronized关键字，类锁，方法锁，重入锁；\n\n6、Java中实现多态的机制是什么；\n\n7、如何将一个Java对象序列化到文件里；\n\n8、说说你对Java反射的理解；\n答：Java 中的反射首先是能够获取到Java 中要反射类的字节码， 获取字节码有三种方法，\n* (1).Class.forName(className)\n* (2).类名.class\n* (3).this.getClass()。\n  \n然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor 等类，这些类提供了丰富的方法可以被我们所使用。\n\n9、同步的方法；多进程开发以及多进程应用场景；\n\n10、在Java中wait和seelp方法的不同；\n答：最大的不同是在等待时wait 会释放锁，而sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。\n\n11、synchronized 和volatile 关键字的作用；\n答：\n* 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n* 2）禁止进行指令重排序。\n\n12、volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\n   \n   * (1).volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的\n   * (2).volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性\n   * (3).volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n   * (4).volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化\n\n13、服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达；\n\n14、ThreadLocal原理，实现及如何保证Local属性；\n\n15、String StringBuilder StringBuffer对比；\n\n16、你所知道的设计模式有哪些；\n答：\nJava 中一般认为有23 种设计模式，我们不需要所有的都会，但是其中常用的几种设计模式应该去掌握。下面列出了所有的设计模式。需要掌握的设计模式我单独列出来了，当然能掌握的越多越好。\n总体来说设计模式分为三大类：\n创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n17、Java如何调用c、c++语言；\n\n18、接口与回调；回调的原理；写一个回调demo；\n\n19、泛型原理，举例说明；解析与分派；\n\n20、抽象类与接口的区别；应用场景；抽象类是否可以没有方法和属性；\n\n21、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？\n\n22、修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法；\n\n23、说说你对泛型的了解；\n\n24、Java的异常体系；\n\n25、如何控制某个方法允许并发访问线程的个数；\n\n26、动态代理的区别，什么场景使用；\n\n27、Dex加载过程和优化方式；\n\n28、Jvm和Gc机制；\n\n29、常用的设计模式。\n\n## 数据结构与算法\n\n1、堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)；\n\n2、最快的排序算法是哪个？给阿里2万多名员工按年龄排序应该选择哪个算法？堆和树的区别；写出快排代码；链表逆序代码；\n\n3、求1000以内的水仙花数以及40亿以内的水仙花数；\n\n4、子串包含问题(KMP 算法)写代码实现；\n\n5、万亿级别的两个URL文件A和B，如何求出A和B的差集C,(Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)\n\n6蚁群算法与蒙特卡洛算法；\n\n7、写出你所知道的排序算法及时空复杂度，稳定性；\n\n8、百度POI中如何试下查找最近的商家功能(坐标镜像+R树)。\n\n9、遍历二叉树\n\n10、自己集合实现一个队列\n\n11、自己实现线程安全类\n\n12、快速排序和冒泡的排序，怎么转换一下。\n\n## 其它\n\n1、死锁的四个必要条件；\n\n2、常见编码方式；utf-8编码中的中文占几个字节；int型几个字节；\n\n3、实现一个Json解析器(可以通过正则提高速度)；\n\n4、MVC MVP MVVM; 常见的设计模式；写出观察者模式的代码；\n\n5、TCP的3次握手和四次挥手；TCP与UDP的区别；\n\n6、HTTP协议；HTTP1.0与2.0的区别；HTTP报文结构；\n\n7、HTTP与HTTPS的区别以及如何实现安全性；\n\n8、都使用过哪些框架、平台；\n\n9、都使用过哪些自定义控件；\n\n10、介绍你做过的哪些项目；\n\n## 非技术问题汇总\n\n1、研究比较深入的领域有哪些；\n2、对业内信息的关注渠道有哪些；\n3、最近都读哪些书；\n4、自己最擅长的技术点，最感兴趣的技术领域和技术点；\n5、项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题；\n6、实习过程中做了什么，有什么产出；\n7、5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同；\n8、时针走一圈，时针分针重合几次；\n9、N * N的方格纸,里面有多少个正方形；\n10、现在下载速度很慢,试从网络协议的角度分析原因,并优化(网络的5层都可以涉及)。\n\n##  HR问题汇总\n1、您在前一家公司的离职原因是什么？\n2、讲一件你印象最深的一件事情；\n3、介绍一个你影响最深的项目；\n4、介绍你最热爱最擅长的专业领域；\n5、公司实习最大的收获是什么；\n6、与上级意见不一致时，你将怎么办；\n7、自己的优点和缺点是什么？并举例说明？\n8、你的学习方法是什么样的？实习过程中如何学习？实习项目中遇到的最9、大困难是什么以及如何解决的；\n10、说一件最能证明你能力的事情；\n11、针对你你申请的这个职位，你认为你还欠缺什么；\n12、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本13、不适合这个职位，你怎么办；\n14、项目中遇到最大的困难是什么？如何解决的；\n15、你的职业规划以及个人目标；未来发展路线及求职定位；\n16、如果你在这次面试中没有被录用，你怎么打算；\n17、评价下自己，评价下自己的技术水平，个人代码量如何；\n18、通过哪些渠道了解的招聘信息，其他同学都投了哪些公司；\n19、业余都有哪些爱好；\n20、你做过的哪件事最令自己感到骄傲；\n21、假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办；\n22、就你申请的这个职位，你认为你还欠缺什么；\n23、当前的offer状况；如果BATH都给了offer该如何选；\n24、你对一份工作更看重哪些方面？平台，技术，氛围，城市，money；\n25、理想薪资范围；杭州岗和北京岗选哪个；\n26、理想中的工作环境是什么；\n27、谈谈你对跳槽的看法；\n28、说说你对行业、技术发展趋势的看法；\n29、实习过程中周围同事/同学有哪些值得学习的地方；\n30、家人对你的工作期望及自己的工作期望；\n31、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办；\n32、若上司在公开会议上误会你了，该如何解决；\n32、是否可以实习，可以实习多久；\n33、在五年的时间内，你的职业规划；\n34、你看中公司的什么？或者公司的那些方面最吸引你。\n","tags":["面试"],"categories":["面试"]},{"title":"android retrofit End of input at line 1 column 1 path","url":"/2020/09/03/android-retrofit-End-of-input-at-line-1-column-1-path/","content":"在使用retrofit作为项目的网络请求库时，接口定义如下：\n```\n@GET(ACT_GET_NEW_STAFF)\nCall<TaskEn> reqGetNewStaff();\n```\n接口从服务端获取了数据，通过GsonConverterFactory将服务端相应内容解析成对应的实体类。在接口正常响应时（有数据返回），并没有什么异常发生，但当接口请求的数据为空，我们的服务端人员并不是返回理论意义上的空，null或者[]（数据集合空），而是返回没有响应体body，只有响应头header，content-length为0的Response\n\n这时候GsonConverterFactory就解析异常了，并抛出如下异常：\n<!-- more -->\n>java.io.EOFException:End of input at line 1 column 1 path \n\n一般来说，如果接口本身就是不需要处理body的，那么我们通常定义接口为\n```\n Call<Void>\n ```\n 这和上面的那两个接口是不一样的。\n\n ### 解决方案\n * 请服务端人员吃顿饭，让他们规范接口，当数据为空时，返回null或者[]\n * 自己动手丰衣足食\n  \n  自定义一个ConverterFactory\n```\npublic class NullOnEmptyConverterFactory extends Converter.Factory {\n\n    @Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        final Converter<ResponseBody, ?> delegate = retrofit.nextResponseBodyConverter(this, type, annotations);\n        return new Converter<ResponseBody,Object>() {\n            @Override\n            public Object convert(ResponseBody body) throws IOException {\n                if (body.contentLength() == 0) return null;\n                return delegate.convert(body);\n            }\n        };\n    }\n}\n```\n然后设置到retrofit\n```\nRetrofit retrofit = new Retrofit.Builder()\n    ....\n    .addConverterFactory(new NullOnEmptyConverterFactory())\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n```\n\n需要注意的是，NullOnEmptyConverterFactory必需在GsonConverterFactory之前addConverterFactory\n\n[原文连接](http://www.voidcn.com/article/p-xoiqdiuz-re.html)","tags":["Error","Retrofit"],"categories":["Android"]},{"title":"Glide添加请求头","url":"/2020/08/31/Glide添加请求头/","content":"[原文来自](https://www.jianshu.com/p/a425b5ca89dd)\n```\n GlideUrl glideUrl = new GlideUrl(url, new Headers() {\n            @Override\n            public Map<String, String> getHeaders() {\n                Map<String, String> header = new HashMap<>();\n                //不一定都要添加，具体看原站的请求信息\n                header.put(\"Referer\", \"http://www.baidu.com\");\n                return header;\n            }\n        });\n\n       Glide.with(context).load(url).into(imageView);\n```","tags":["Android","工具使用"],"categories":["Android"]},{"title":"vue基础使用-2","url":"/2020/08/25/vue基础使用-2/","tags":["vue"],"categories":["vue"]},{"title":"vue基础使用-1","url":"/2020/08/25/vue基础使用-1/","content":"### 安装vue\n***\n[官方文档](https://cn.vuejs.org/v2/guide/installation.html)\n我才用的是通过 ***npm*** 进行安装穿件vue项目的，首先切换到项目根目录下，终端先后执行如下：\n<!-- more -->\n```\nnpm init //如果你是第一次使用npm的话\n\nnpm install --yes //安装后会生成一个package.json的文件\n\nnpm install vue //执行完后会出现一个node_modules文件夹，这个便是我们vue.js的资源文件\n```\n### 如何开始使用\n* 1、在body中引包\n``` <script type=\"text/javascript\" src=\"./node_modules/vue/dist/vue.js\"></script>```\n       \n* 2、创建实例化对象\n> new Vue({\n\t\tel: '#app', //目的地\n\t    data: data,\n\t\ttemplate: ''\n\t});  \n\n\n[本节练习代码](https://github.com/MarkCHYL/BLOG/blob/master/marksource/01_vue基础使用.html)\n\n下一章[vue基础使用-2](http://markchyl.cn/2020/08/25/vue基础使用-2/)","tags":["vue"],"categories":["vue"]},{"title":"Mac 电脑如何卸载 node和npm","url":"/2020/08/25/Mac-电脑如何卸载-node和npm/","content":"记录下我自己重新安装npm，因为npm是和node.js安装一起的，也就是说是重新弄*node*\n<!-- more -->\n### 一、在终端依次输入以下命令\n```\n sudo npm uninstall npm -g\n sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n sudo rm -rf /usr/local/include/node /Users/$USER/.npm\n sudo rm /usr/local/bin/node\n sudo rm /usr/local/share/man/man1/node.1\n```\n### 二\n输入 npm -v 和node -v 验证是否卸载成功。","tags":["系统"],"categories":["工具使用"]},{"title":"Git之使用GitHub搭建远程仓库","url":"/2020/08/18/Git之使用GitHub搭建远程仓库/","content":"### 1.账号注册&仓库创建：\n不做记录，简单\n### 2.Clone代码库到本地\n<!-- more -->\n`git clone https://github.com/ZPJay/Garbage.git`\n### 3.分支管理\n①创建分支(后者创建同时会切换分支):\n> git branch v1.0.3 或 git checkout -b v1.0.4\n②查看版本库中所有分支：\n> git branch -a\n③切换到某一分支：\n> git checkout v1.0.3\n④删除某一分支：\n> git branch -D v1.0.4\n⑤合并分支\n> git merge v1.0.3\n\n### 4.本地仓库与远程仓库同步问题\n先对我们的本地仓库做一点点修改，接着git add和git commit本地准备后，然后：\n> git push origin master 或者直接 git push\n\n有同步到服务器，肯定有服务器同步到本地是吧，很简单，就一个\n> git pull","tags":["工具使用"],"categories":["工具使用"]},{"title":"Git使用教程之本地仓库的基本操","url":"/2020/08/17/Git使用教程之本地仓库的基本操/","content":"Git 的安装就不再次啰嗦了：\n`sudo apt-get install git`\n### 1.创建代码仓库\n#### Step 1：先配置下身份，这样在提交代码的时候Git就可以知道是谁提交的，命令如下：\n```\ngit config --global user.name \"MarkCHYL\"\ngit config --global user.email \"2285581945@qq.com\"\n```\n检查下配置是否成功：\n<!-- more -->\n```\nmark@Markxiansheng blog % git config --global user.name \nMarkCHYL\nmark@Markxiansheng blog % git config --global user.email\n2285581945@qq.com\n```\n#### Step 2：找个地方创建我们的代码仓库\n>git init\n\n继续输入：ls - al可以看到下目录下有个.git的文件夹就是他了\n\n### 2.提交本地代码\n创建完代码仓库，接下来说下如何提交代码.先用add命令把要提交的内容都加进来，然后commit才是真的去执行提交操作!\n\n> git add readme.md\n> \n> git commit -m \"First Commit\"\n\n不过如果我们改动的文件很多的话，我们可以`git add .`一次添加全部.\n\n### 3.查看修改内容\n使用`git status`可以查看 修改的部分\n但是还没有提交，如果我们想看下具体更改了什么，我们可以用到git diff命令，另外，按Q可以退回命令行输入！\n\n### 4.查看提交记录\n>git log\n```\ncommit 19fb3091a83d7d5cc463fa9df67964ab95a2a404 (HEAD -> master)\nAuthor: MarkCHYL <2285581945@qq.com>\nDate:   Mon Aug 17 15:57:11 2020 +0800\n\n    First Commit\n```\n依次是：\n* 此次提交对应的版本号\n* 提交人：姓名 邮箱\n* 提交的时间\n* 提交版本修改的内容：就是我们commit -m \"xxx\"里的xxx\n\n### 5.撤销未提交的修改\n比如我们刚提交了一个版本，然后又乱七八糟地写了一堆东西，突然发现不小心误删了一些东西，然后ctrl + s保存了，这个时候是不是欲哭无泪，不过有Git，只需一个checkout命令即可撤销更改，当然是你还没add的情况，比如我们在MainActivity里随便添加一条语句，然后ctrl + s保存代码！\n> git diff\n会得到输出结果\n```\ndiff --git a/readme.md b/readme.md\nindex e69de29..58940c4 100644\n--- a/readme.md\n+++ b/readme.md\n@@ -0,0 +1 @@\n+鄙人日常笔记记录\n\\ No newline at end of file\n```\n这里可以看到我们改的内容，我们可以回去把这句代码删掉，但是如果改的有上千行你怎么改， 于是乎这个时候我们可以使用\n\n> git checkout git checkout /Users/mark/Desktop/Document/blog/readme.md\n\n当然，如果我们已经add了的话，那么checkout是没任何作用的，我们要先取消添加才可以撤回提交，使用下述指令：\n> git reset HEAD /Users/mark/Desktop/Document/blog/readme.md\n\n>git checkout /Users/mark/Desktop/Document/blog/readme.md\n\n### 6.版本回退\n第五点我们教了大家撤销未提交的修改，但加入提交了，我们想回退到之前的某一个版本怎么办? 第四点中我们可以通过git log查看我们的提交记录，我们需要从这里获取一个版本号， 一般我们只需要前七位字符就够了；另外在Git中，用HEAD代表当前版本，上一个版本就是HEAD^， 再上一个版本就是HEAD^^依次类推！我们先Git Log看下版本历史先！\n\n我们回到前一个提交的版本吧，依次键入下述指令：\n> git reset --hard HEAD\n> \n >git reset --hard HEAD^\n >\n >git log\n\n 可以看到我们已经回退到了前一个版本了，当然你可以直接这样写：\n > git reset --hard ad2080c\n\n 就是这么简单！回退后，你突然后悔了，想回退回新的那个版本， 可是遗憾的是，你键入git log却发现没有了最新的那个版本号，这怎么办呢... 没事，Git中给你提供了这颗\"后悔药\"，Git记录着你输入的每一条指令呢！键入：\n >git reflog\n \n 你会发现，版本号就在这里：\n 然后执行：\n > git reset --hard ad2080c\n ","tags":["工具使用"],"categories":["工具使用"]},{"title":"Android 安装APP 失败 INSTALL_FAILED_TEST_ONLY","url":"/2020/08/07/Android-安装APP-失败-INSTALL-FAILED-TEST-ONLY/","content":"### android studio 进行真机安装时失败，报错：\n> Installation did not succeed.\nThe application could not be installed: INSTALL_FAILED_TEST_ONLY\nInstallation failed due to: 'null'\n\n### 解决办法\n在`gradle.properties 文件中`添加\n\n>android.injected.testOnly=false","tags":["Error"],"categories":["Android"]},{"title":"Android 通用流行框架大全","url":"/2020/08/07/Android-通用流行框架大全/","content":"\n>1.缓存\n\n\n|名称|\t描述|\n|--|----|\n|DiskLruCache|\tJava实现基于LRU的磁盘缓存|\n\n>2.图片加载\n\n|名称\t|描述|\n|--|----|\n|Android Universal Image Loader|\t一个强大的加载，缓存，展示图片的库|\n|Picasso\t|一个强大的图片下载与缓存的库|\n|Fresco\t|一个用于管理图像和他们使用的内存的库|\n|Glide\t|一个图片加载和缓存的库|\n\n<!-- more -->\n\n>3.图片处理\n\n|名称|\t描述|\n|--|----|\n|Picasso-transformations|\t一个为Picasso提供多种图片变换的库|\n|Glide-transformations\t|一个为Glide提供多种图片变换的库|\n|Android-gpuimage\t|基于OpenGL的Android过滤器|\n\n>4.网络请求\n\n|名称\t|描述|\n|--|----|\n|Android Async HTTP\t|Android异步HTTP库|\n|AndroidAsync\t|异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。|\n|OkHttp|\t一个Http与Http/2的客户端|\n|Retrofit\t|类型安全的Http客户端|\n|Volley\t|Google推出的Android异步网络请求框架和图片加载框架|\n\n>5.网络解析\n\n|名称|\t描述|\n|--|----|\n|Gson|\t一个Java序列化/反序列化库，可以将JSON和java对象互相转换|\n|Jackson\t|Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象|\n|Fastjson|\tJava上一个快速的JSON解析器/生成器|\n|HtmlPaser\t|一种用来解析单个独立html或嵌套html的方式|\n|Jsoup\t|一个以最好的DOM，CSS和jQuery解析html的库|\n\n>6.数据库\n\n|名称\t|描述|\n|--|----|\n|OrmLite\t|JDBC和Android的轻量级ORM java包|\n|Sugar\t|用超级简单的方法处理Android数据库|\n|GreenDAO\t|一种轻快地将对象映射到SQLite数据库的ORM解决方案|\n|ActiveAndroid\t|以活动记录方式为Android SQLite提供持久化|\n|SQLBrite\t|SQLiteOpenHelper 和ContentResolver的轻量级包装|\n|Realm\t|移动数据库：一个SQLite和ORM的替换品|\n\n>7.依赖注入\n\n|名称|\t描述|\n|--|----|\n|ButterKnife\t|将Android视图和回调方法绑定到字段和方法上|\n|Dagger2|\t一个Android和java快速依赖注射器。|\n|AndroidAnotations|\t快速安卓开发。易于维护|\n|RoboGuice\t|Android平台的Google Guice|\n\n>8.图表\n\n|名称|\t描述|\n|--|----|\n|WilliamChart\t|创建图表的Android库|\n|HelloCharts\t|兼容到API8的Android图表库|\n|MPAndroidChart\t|一个强大的Android图表视图/图形库|\n\n>9.后台处理\n\n|名称|\t描述|\n|--|----|\n|Tape\t|一个轻快的，事务性的，基于文件的FIFO的库|\n|Android Priority Job Queue\t|一个专门为Android轻松调度任务的工作队列|\n\n>10.事件总线\n\n|名称\t|描述|\n|--|----|\n|EventBus|\t安卓优化的事件总线，简化了活动、片段、线程、服务等的通信|\n|Otto\t|一个基于Guava的增强的事件总线|\n\n>11.响应式编程\n\n|名称|\t描述|\n|--|----|\n|RxJava\t|JVM上的响应式扩展|\n|RxJavaJoins\t|为RxJava提供Joins操作|\n|RxAndroid|\tAndroid上的响应式扩展，在RxJava基础上添加了Android线程调度|\n|RxBinding\t|提供用RxJava绑定Android UI的API|\n|Agera\t|Android上的响应式编程|\n\n>12.Log框架\n\n|名称|\t描述|\n|--|----|\n|Logger|\t简单，漂亮，强大的Android日志工具|\n|Hugo\t|在调试版本上注解的触发方法进行日志记录|\n|Timber\t|一个小的，可扩展的日志工具|\n\n>13.测试框架\n\n|名称\t|描述|\n|--|----|\n|Mockito\t|Java编写的Mocking单元测试框架|\n|Robotium\t|Android UI 测试|\n|Robolectric|\tAndroid单元测试框架|\nAndroid自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等\n\n>14.调试框架\n\n|名称\t|描述|\n|--|----|\n|Stetho\t|调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试|\n\n>15.性能优化\n\n| 名称 | 描述 |\n| -- | ---- |\n|LeakCanary\t|内存泄漏检测工具|\n|ACRA|\tAndroid应用程序崩溃报告|\n\n> [转自安卓开发中文站](http://www.androidchina.net/4920.html)","tags":["框架","图片"],"categories":["Android"]},{"title":"自定义控件实现（二）","url":"/2020/08/06/自定义控件实现（二）/","tags":["Android","自定义控件"],"categories":["Android"]},{"title":"Android ANR发生的原因总结和解决办法","url":"/2020/08/06/Android-ANR发生的原因总结和解决办法/","content":"### 什么是ANR？\n> ANR的全称是application not responding，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。一般地，这时往往会弹出一个提示框，告知用户当前xxx未响应，用户可选择继续等待或者Force Close。\n***\n### 官方指定的产生ANR一般有以下类型：\n1：KeyDispatchTimeout（5秒）–主要类型\n按键或触摸事件在特定时间无响应\n\n2：BroadcastTimeout（10秒）\nBroadcastReceiver在特定时间无法处理完成\n\n3：ServiceTimeout（ 20秒）–小概率类型\n服务在特定的时间无法处理完成\n\n***\n### 导致ANR的根本原因\n\n1.主线程执行了耗时操作，比如数据库操作或网络编程,I/O操作\n\n2.其他进程（就是其他程序）占用CPU导致本进程得不到CPU时间片，比如其他进程的频繁读写操作可能会导致这个问题。\n\n细分的话，导致ANR的原因有如下几点：\n   1.耗时的网络访问\n   2.大量的数据读写\n   3.数据库操作\n   4.硬件操作（比如camera)\n   5.调用thread的join()方法、sleep()方法、wait()方法或者等待线程锁的时候\n   6.service binder的数量达到上限\n   7.system server中发生WatchDog ANR\n   8.service忙导致超时无响应\n   9.其他线程持有锁，导致主线程等待超时\n   10.其它线程终止或崩溃导致主线程一直等待\n\n***\n### 调查并解决ANR\n* 1、首先分析log\n* 2、从trace.txt文件查看调用堆栈。-$ adb拉取data / anr / traces.txt。\n* 3、看代码\n* 4、仔细查看ANR的成因（iowait？block？memoryleak？）\n***\n### 如何避免ANR的发生\n1.避免在主线程执行耗时操作，所有耗时操作应新开一个子线程完成，然后再在主线程更新UI。\n\n2.BroadcastReceiver要执行耗时操作时应启动一个service，将耗时操作交给service来完成。\n\n3.避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广 播时需要向用户展示什么，你应该使用Notification Manager来实现。\n","tags":["基础理论","Error"],"categories":["Android"]},{"title":"自定义控件实现（一）","url":"/2020/08/05/自定义控件实现（一）/","content":"**被别人问题一愣一愣，骄傲的自己准备好好复习哈！**\n[几乎完全使用这位大佬的](https://www.jianshu.com/p/6572ebed0d99)\n***\n### 什么是自定义控件？\nAndroid中所有控件和布局的基本类都是View，自定控件就是继承View或者View的派生类，然后重写类中的内部方法。\n通常自定义控件分为三种：\n1、自定义View：继承View\n2、基于现有的组件：继承View的派生类\n3、组合的方式：自定义控件中包含了其他组件\n下图体现了各种控件的继承关系：\n![](https://github.com/MarkCHYL/BLOG/blob/master/marksource/images/ax2z2-cyxgm.jpg?raw=true)\n\n### 来实践一下组合自定义控件\n需要实现的效果如图：\n![](https://github.com/MarkCHYL/BLOG/blob/master/marksource/images/avr1u-cdm3a.jpg?raw=true)\n\n\n\n[自定义控件实现（二）](../../public/2020/08/06/自定义控件实现（二）/index.html)\n\n","tags":["Android","自定义控件"],"categories":["Android"]},{"title":"Mac 每次都要执行source ~/.bash_profile 配置的环境变量才生效","url":"/2020/07/28/Mac-每次都要执行source-bash-profile-配置的环境变量才生效/","content":"### 问题\n遇到一个问题，前段时间由于系统升级之后，做了一下用户群组的改动，在开发的时候发现之前在\n`.bash_profile`中设置的环境变量都不见了，还只能在终端中执行一次`source .bash_profile`,环境变量才能生效。\n### 解决办法\n在系统根目录下，在~/.zshrc文件最后，增加一行：\nsource ~/.bash_profile","tags":["系统"],"categories":["工具使用"]},{"title":"自定义Toat及其弹出时间控制","url":"/2020/07/21/自定义Toat及其弹出时间控制/","content":"效果就是实现Toast布局自定义，弹出的事件进行控制\n### 一、先自定义布局\n```\n  Toast toast = Toast.makeText(mContext, str, Toast.   LENGTH_SHORT);\n  View view = LayoutInflater.from(mContext).inflate(R.layout.item_toast, null);\n  TextView textView = view.findViewById(R.id.str_toast);\n        textView.setText(str);\n        toast.setView(view);\n        toast.setGravity(Gravity.CENTER, 0, 0);\n  Utils.showTimeToast(toast,500);\n```\n### 二、自定义弹出时间\n```\n /**\n     * Toast自定义时间\n     * Toast对象时间需要为Toast.LENGH_LONG\n     */\n    public static void showTimeToast(final Toast toast, final int time) {\n        final Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                toast.show();\n            }\n        }, 0, 3000);\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                toast.cancel();\n                timer.cancel();\n            }\n        }, time);\n    }\n```\n就是那么简单，利用Timer和schedule实现事件监听，控制toast的弹出时间。\n\n","tags":["Android"],"categories":["Android"]},{"title":"Monkey自动化压力测试","url":"/2020/06/22/Monkey自动化压力测试/","content":"## 第一部分 背景\n ### 1、为什么要开展压力测试？\n  * 提高产品的稳定性\n  * 提高产品的留存率\n  ### 2、什么时候开展压力测试？\n  * 首轮功能测试通过后开始\n  * 下班后的夜间进行\n## 第二部分 场景\n### 手工测试场景\n### 自动化测试场景\n1、 Monkey\nMonkey 就在手机里，安卓系统再带的\n\n2、 什么是ADB？\nAndroid Debug Bridge 安卓调试桥\n<!-- more -->\n3、 MonkeyScript\nMonkeyScript是一组可被monkey识别的命令集合。\nMonkeyScript可以完成重复固定的指令\n\n4、 MonkeyRunner\n提供一系列的API，可以模拟事件及截图操作。\n\n5、Monkey和MonkeyRunner的区别？\nMonkey：在adb shell中，生成用户或系统的伪随机事件。\nMonkeyRunner：通过API定义特定命令和事件控制设备。\n\nMonkeyRunner APIs\n*  MonkeyRunner:用来连接设备或者模拟器\n*  MonkeyDevice：提供安装、卸载应用，发送模拟事件\n*  MonkeyImage：完成图像保存，及对比操作。\n\n### 压力测试结果\ncrash和ANR\n\n崩溃和应用无响应\n\n## 第三部分：实践\n* 步骤一：打开手机USB调试功能\n* 步骤二：确认手机和电脑已经连接，执行`adb devices`\n```\nmark@Markxiansheng blog % adb devices\n* daemon not running; starting now at tcp:5037\n* daemon started successfully\nList of devices attached\nHCW0001811005556        device\n\n```\n* 步骤三：安装测试app，`adb install package.apk`\n* 步骤四：发送压测指令 `adb shell monkey 1000`执行1000次随机操作指令\n* 步骤五：获取app报名：执行`adb logcat | grep START`\n* 步骤六：给指定的包打压力；执行`adb shell monkey -p package 1000`\n\n## 第四部分：Monkey高级参数的应用\n### 1、throttle参数\n指定事件之间的间隔\n`adb shell monkey --throttle <milliseconds>`\n### 2、seed参数实践\n指定随机生成数的seed值 `adb shell monkey -s <seed> <event-count>`\n\n例如：`adb shell monkey -p com.android.calculator2 -s 100 50`\n每次执行结构都是一样，记住清理缓存记录再测试，复现问题\n### 3、触摸事件\n设定触摸事件百分比\n`adb shell monkey --pct-touch <percent>`\n\n例如：`adb shell monkey -v -p com.cares.rcs --pct-touch 100 100`，加上`-v`是为了看清具体执行的操作是什么\n\n### 4、动作事件\n设定动作事件百分比`adb shell monkey --pct-motion <percent>`\n例如：`adb shell monkey -v -p com.cares.rcs --pct-touch 50 --pct-motion 30 100`\n执行touch事件50%，motion事件30%，执行一百次事件\n\n### 5、轨迹球事件\n设定轨迹球事件百分比\n`adb shell monkey --pct-trackball <percent>`\n### 6、基本导航事件\n设定基本导航事件百分比，输入设备上的上、下、左、右\n`adb shell monkey --pct-nav <percent>`\n### 7、主要导航事件\n设定主要导航事件百分比，兼容中间键、返回键、菜单按键\n`adb shell monkey --pct-majornav <percent>`\n### 8、系统导航事件\n设定系统导航事件百分比，HOME、BACK、拨号及音量按键\n`adb shell monkey --pct-syskeys <percent>`\n### 9、启动Activity事件\n设定启动Activity的事件百分比\n`adb shell monkey --pct-appswitch <percent>`\n### 10、不常用事件\n`adb shell monkey --pct-anyevent <percent>`\n### 11、崩溃事件Crash事件\n忽略崩溃和异常\n`adb shell monkey --ignore-crashes <percent>`\n### 12、超时事件ANR事件\n忽略超时事件\n`adb shell monkey --ignore-timeouts <event-count>`\n\n## 第五部分：CRASH结果提取\n\n `adb shell monkey -p com.cares.rcs 1000`不断测试执行随机操作\n\n## 第六部分：ANR查看\n```\nMarkxiansheng:Desktop mark$ adb shell\nroot@vbox86p:/ #\nroot@vbox86p:/ # cd /data/anr\nroot@vbox86p:/data/anr # ls\ntraces.txt\n```\n## Monkey Script学习使用\n> 执行语句：`adb shell monkey -f <scriptfile> <event-count>`\n\n常用命令：\n\n1、**DispatchTrackball**轨迹球事件\n\n2、**DispatchPointer**点击事件\n\n3、**DispatchString**输入字符串事件\n`DispatchString(String text)`\n\n4、**LaunchActivity**启动应用事件\n`LaunchAtivity(package,Activity)`\n\n5、**UserWait**命令\n等待事件：`UserWait(millinsons)`\n\n6、**DispatchPress**命令\n按下键值：`DispatchPress(int keycode)` #keycode 66 回车键》\n\n模拟输入查询一千次\n* 1、启动App\n* 2、点击输入框\n* 3、输入查询词\n* 4、点击键盘的回车\n* 5、点击搜索按钮\n* 6、等待结果的出现\n* 7、点击clear按钮\nMark.script脚本\n```\ntyp = user\ncount = 10\nspeed = 1.0\nstart data >>\n\nLaunchActivity(com.android.browser,.BrowserActivity)\nUserWait(2000)\nDispatchPointer(10,10,0,200,200,1,1,-1,1,1,0,0)\nDispatchPointer(10,10,1,200,200,1,1,-1,1,1,0,0)\nDispatchString(Mark)\nUserWait(1000)\nDispatchPress(66)\nDispatchPointer(10,10,0,600,300,1,1,-1,1,1,0,0)\nDispatchPointer(10,10,1,600,300,1,1,-1,1,1,0,0)\nUserWait(3000)\n```\n\n小黑技术：SDK目录下tools文件中的bin目录下的 uiautomatorviewer.bat,双击启动，用来获取界面控件位置\n\n\n## Monkey Runner学习使用\n主要是利用python编写脚本文件进行测试，暂停学习","tags":["Android"],"categories":["Android"]},{"title":"Linux命令学习","url":"/2020/04/09/Linux命令远程管理命令学习/","content":"\n## 远程管理命令\n> ### **关机/重启**\n\n| 序号 | 命令 | 对应英文 | 作用 |\n|--|--|--|--|\n| 01 | shutdown 选项 时间 | shutdown | 关机/重新启动 |\n* shutdown 命令可以安全 **关闭** 或 **重启系统**\n\n|选项| 含义|\n|--|--|\n|-r|重新启动|\n\n> 提示：\n> * 不指定选项和参数，默认表示 1 分钟后关闭电脑\n> * 远程维护服务器时，最好不要关闭系统，而是应该重启系统\n\n```\n\n```\n\n### ssh客户端的简单实用\n> ssh [-p port] user@remote\n如果服务器端没有设置账号密码，或者是无密码登录，直接写`ssh -p 22 192.168.177.156`或`ssh -p 228 mark@192.168.177.156`\n\n关于ssh配置方法：\nubuntu下默认是不允许root通过密码的方式通过ssh远程登录服务器的，可以通过在\n```sudo vi /etc/ssh/sshd_config\n#增加以下配置允许通过ssh登录\n\n#PermitRootLogin prohibit-password\nPermitRootLogin yes\n\n#修改完成后需要重启ssh服务命令如下\nsudo service ssh restart\n```\n即可通过ssh的root用户登录服务器了。\n下面说下如何修改root密码\n\n```sudo passwd root\nEnter new UNIX password:\nRetype new UNIX password:\npasswd: password updated successfully\nsu root #即生效\n```\n此时若想验证看root密码是否更改成功，可以通过如下命令\n```\nsu - root\n#在下方输入修改后的密码，输入后回车\nPassword:\n```\n","tags":["Linux"],"categories":["Linux"]},{"title":"安全码SHA1如何获取","url":"/2020/01/15/安全码SHA1如何获取/","content":"\n在高德地图集成的时候遇到那玩意。\n[原文](https://blog.csdn.net/qq_33704095/article/details/80861146)\n### SHA1获取的几种方式\n* 1、通过Eclipse编译器获取SHA1\n\n使用 adt 22 以上版本，可以在 eclipse 中直接查看。\n\nWindows：依次在 eclipse 中打开 Window -> Preferances -> Android -> Build。\n\nMac：依次在 eclipse 中打开 Eclipse/ADT->Preferances -> Android -> Build。\n\n在弹出的 Build 对话框中 “SHA1 fingerprint” 中的值即为 Android 签名证书的 Sha1 值\n\n<!-- more -->\n* 2、通过Android Studio编译器获取SHA1\n\n第一步、打开Android Studio的Terminal工具\n\n第二步、输入命令：keytool -v -list -keystore keystore文件路径\n\n第三步、输入Keystore密码\n\n* 3、使用 keytool（jdk自带工具）获取SHA1\n\n第一步、运行进入控制台\n第二步、在弹出的控制台窗口中输入 cd .android 定位到 .android 文件夹\n第三步、继续在控制台输入命令\ndebug.keystore：命令为：keytool -list -v -keystore debug.keystore\n\n自定义的 keystore：命令为：keytool -list -v -keystore apk的keystore\n\n提示输入密钥库密码，编译器提供的debug keystore默认密码是 android，自定义签名文件的密码请自行填写。输入密钥后回车（如果没设置密码，可直接回车），此时可在控制台显示的信息中获取 SHA1 值\n\n* 4、代码中提取\npublicstatic String sHA1(Context context) {\n    try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n            context.getPackageName(), PackageManager.GET_SIGNATURES);\n        byte[] cert = info.signatures[0].toByteArray();\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        byte[] publicKey = md.digest(cert);\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < publicKey.length; i++) {\n            String appendString = Integer.toHexString(0xFF & publicKey[i])\n                .toUpperCase(Locale.US);\n            if (appendString.length() == 1)\n                hexString.append(\"0\");\n            hexString.append(appendString);\n        }\n        return hexString.toString();\n    } catch (NameNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\n* 5、apk中读取：\n第一步、将apk改为zip后缀文件，并解压；\n第二步、进入META-INF路径，执行keytool -printcert -file META-INF/CERT.RSA","tags":["Android"],"categories":["Android"]},{"title":"Android动态更换APP图标及名称","url":"/2020/01/13/Android动态更换APP图标及名称/","content":"实现之前觉得万分难，我查阅了很多博客.\n报错-----应用未安装\nStop，停下来我先抽支烟，喝杯茶，仔细看看别人的介绍。再次感谢这个博主的博客[倚栏静望](https://blog.csdn.net/ozhuimeng123/article/details/92734825)\n\n<!-- more -->\n**实现的目的和标题一样，动态的实现app的启动图标和应用的名字**\n### 下面我先贴出我的重要代码\n* 在*AndroidManifest.xml*文件中添加:\n  ```\n   <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"\n        tools:ignore=\"GoogleAppIndexingWarning\">\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n\n        <activity-alias\n            android:name=\".mark\"\n            android:enabled=\"false\"\n            android:icon=\"@mipmap/mark_launcher\"\n            android:label=\"@string/app_name1\"\n            android:roundIcon=\"@mipmap/mark_launcher_round\"\n            android:targetActivity=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity-alias>\n\n        <activity-alias\n            android:name=\".chyl\"\n            android:enabled=\"false\"\n            android:icon=\"@mipmap/chyl_launcher\"\n            android:label=\"@string/app_name2\"\n            android:roundIcon=\"@mipmap/chyl_launcher_round\"\n            android:targetActivity=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity-alias>\n    </application>\n    ```\n* 在 MainActivity中编写切换代码：\n  ```\n  /**\n     * =1、第一图标状态 =2 第二图标状态 =3、不换图标\n     */\n    fun changeAppName(tag: Int) {\n        val mark_tag = \"com.cares.appicon.mark\"\n        val chyl_tag = \"com.cares.appicon.chyl\"\n        \n        val pm: PackageManager = packageManager\n\n        when (tag) {\n            1 -> {\n                //取消掉默认的应用icon\n                pm.setComponentEnabledSetting(\n                    componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n                //然后执行\n                pm.setComponentEnabledSetting(\n                    ComponentName(\n                        baseContext,\n                        mark_tag\n                    ),\n                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n\n            }\n            2 -> {\n                pm.setComponentEnabledSetting(\n                    ComponentName(baseContext, mark_tag),\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n                pm.setComponentEnabledSetting(\n                    ComponentName(\n                        baseContext,\n                        packageName + \".MainActivity\"\n                    ),\n                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n            }\n            3 -> {\n                pm.setComponentEnabledSetting(\n                    componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n\n                pm.setComponentEnabledSetting(\n                    ComponentName(\n                        baseContext,\n                        chyl_tag\n                    ),\n                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n\n            }\n            4 -> {\n                pm.setComponentEnabledSetting(\n                    ComponentName(baseContext, chyl_tag),\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n                pm.setComponentEnabledSetting(\n                    ComponentName(\n                        baseContext,\n                        packageName + \".MainActivity\"\n                    ),\n                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                    PackageManager.DONT_KILL_APP\n                )\n            }\n        }\n\n    }\n    ```\n### 解释下里面的重要词：\nactivity-alias功能\n\nactivity-alias作为一个已存在Activity的别名，则应该可以通过该别名标签声明快速打开目标Activity。因此activity-alias可用来设置某个Activity的快捷入口，可以放在桌面上或者通过该别名被其他组件快速调起。该标签元素支持一些属性及intent-filter、meta-data等配置，因此可以触发一些跟目标Activity不同的功能逻辑，虽然打开的是同一个Activity。举个简单的例子，如之前需要先打开主界面，然后才能点击进入某个Activity，如果使用activity-alias为该Activity配置一个快捷入口，甚至可以为其在桌面生成一个图标，然后点击桌面图标可直接进入该Activity，该功能可满足某些需要快速到达功能界面的需求。\n\n语法：\n```\n<activity-alias android:enabled=[\"true\" | \"false\"]\n                android:exported=[\"true\" | \"false\"]\n                android:icon=\"drawable resource\"\n                android:label=\"string resource\"\n                android:name=\"string\"\n                android:permission=\"string\"\n                android:targetActivity=\"string\" >\n    . . .\n</activity-alias>\n```\n* android:enable\n该属性用来决定目标Activity可否通过别名被系统实例化，默认为true。需要注意的是application也有enable属性，只用当它们同时为true时，activity-alias的enable才生效。\n* android:exported\n该属性为true的话，则目标Activity可被其他应用调起，如为false则只能被应用自身调起。其默认值根据activity-alias是否包含intent-filter元素决定，如果有的话，则默认为true；没有的话则为false。其实也很好理解，如果有intent-filter，则目标Activity可以匹配隐式Intent，因此可被外部应用唤起；如果没有intent-filter，则目标Activity要被调起的话必须知道其精确类名，因为只有应用本身才知道精确类名，所以此时默认为false。\n* android:icon\n该属性就比较好玩了，允许自定义icon，可以不同于应用本身在桌面的icon。如果需要在桌面上创建快捷入口，也许产品会要求换个不同的icon。\n* android:label\n该属性类似于android:icon，图标都换了，换个名称也合情合理吧，此属性就是为此而生的。\n* android:name\n该属性可以为任意字符串，但最好符合类名命名规范。activity元素的name属性实质上都会指向一个具体的Activity类，而activity-alias的name属性仅作为一个唯一标识而已。\n* android:permission\n该属性指明了通过别名声明调起目标Activity所必需的权限。\n* android:targetActivity\n该属性指定了目标Activity，即通过activity-alias调起的Activity是哪个，此属性其实类似于activity标签中的name属性，需要规范的Activity包名类名。","tags":["Android"],"categories":["Android"]},{"title":"android:duplicateParentState属性解释","url":"/2019/12/31/android-duplicateParentState属性解释/","content":"\n**android:duplicateParentState指的是当前控件是否跟随父控件的(点击、焦点等)状态**\n>例：假设一Layout有两子View，对Layout进行监听点击事件；子ViewA一个设置duplicateParentState为true，子ViewB设置为false，当点击Layout后，子ViewA的点击态背景变色成功，子ViewB背景态变色无效，因为点击事件被Layout捕获。\n<!-- more -->\n\n————————————————\n\n原文链接：https://blog.csdn.net/fancylovejava/article/details/38039847","tags":["布局"],"categories":["Android"]},{"title":" Description : Could not find the specified file.  Suggestion : Check that the path you have specified is correct.","url":"/2019/12/27/Description-Could-not-find-the-specified-file-Suggestion-Check-that-the-path-you-have-specified-is-correct/","content":"记录下我使用 CornerStone 利用SVN 进行版本代码管理。我已经快两个月没提交代码啦，今天一提交发现好多问题，各种报错。\n譬如这类错误：\n```\n Description : Could not find the specified file.  Suggestion : Check that the path you have specified is correct.   Technical Information =====================        Error : V4FileNotFoundError   Exception : ZSVNNoSuchEntryException  Causal Information \n ```\n 解决办法：\n 我在missing选项中删除错误的就OK了，提交前全选 =>删除，重新手动编辑提交，重新提交前执行一下  clean。","tags":["Error"],"categories":["svn"]},{"title":"error: <item> inner element must either be a resource reference or empty.","url":"/2019/12/25/error-item-inner-element-must-either-be-a-resource-reference-or-empty/","content":"```\nFAQ:\n\nAndroid resource compilation failed\nOutput: /home/cmm/code/AndroidHttpCapture/app/build/intermediates/incremental/mergeDebugResources/merged.dir/values/values.xml:733: error: <item> inner element must either be a resource reference or empty.\n\nCommand: /home/cmm/.gradle/caches/transforms-1/files-1.1/aapt2-3.2.0-4818971-linux.jar/8e0275d065e63c2601af4fb5800833ab/aapt2-3.2.0-4818971-linux/aapt2 compile --legacy \\\n-o \\\n/home/cmm/code/AndroidHttpCapture/app/build/intermediates/res/merged/debug \\\n/home/cmm/code/AndroidHttpCapture/app/build/intermediates/incremental/mergeDebugResources/merged.dir/values/values.xml\nDaemon: AAPT2 aapt2-3.2.0-4818971-linux Daemon #1\n```\n\n\n如上错误原来是values.xm资源文件中，元素定义了id后，就不能在后面给值了\n\n\n发现 :\n`<item name=\"split\" type=\"id\">false</item>`\n\n改为 :\n`<item name=\"split\" type=\"id\"/>`\n即可.","tags":["Error"],"categories":["Android"]},{"title":"Charles抓包工具在mac上如何配置","url":"/2019/12/18/Charles抓包工具在mac上如何配置/","content":"#### 配置：\n* 电脑：MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports)\n* 手机：安卓手机4.4版本（是定制的）\n* Charles版本：v4.5.5\n* 手机与macbook需要连接同一网段的网络，macbook可以是有线，手机连wifi，也可以两者连接同一个wifi。\n\n***\n### 第一、电脑上安装Charles\n官网下载安装：[官网地址](https://www.charlesproxy.com/download/)\n下载后安装\n### 第二、设置charles代理\n打开charles/proxy/proxy-settings，设置一个端口号，默认的8888就可以。\n![](../img/accxv-s218u.jpg)\n\n### 第三、手机安装charles证书\n需要安装charles的证书。点击help/SSL proxying\n\n![](../img/aa1g5-ewu90.jpg)\n查询macbook的ip地址，并在手机连接的wifi上手动设置代理，代理主机名为ip地址，代理端口号为8888，会弹出一个框，显示的意思是手机上的wify需要设置代理。\n\n### 第三、手机设置代理\n\n查询macbook的ip地址，并在手机连接的wifi上手动设置代理，代理主机名为ip地址，代理端口号为8888，这时候用手机访问网页，charles会弹出下列框，说明charles已经开始对手机抓包了，点击允许。\n\n![](../img/a1evd-z9c3a.jpg)\n\n然后在手机浏览器中访问手机http://charlesproxy.com/getssl，安装即可，\n![](../img/a921v-hyhye.jpg)\n\n\n好了，现在就可以流畅的抓取手机上的各种http/https请求了，想要学习更多charles工具方法.\n\n\n本人不做推广，只是供自己即好友参考做的笔记\n感谢开发员：[小小的开发人员](https://www.jianshu.com/p/50f844c9beaf)","tags":["工具使用"],"categories":["工具使用"]},{"title":"Error:注: 某些输入文件使用或覆盖了已过时的 API。 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。","url":"/2019/12/12/Error-注-某些输入文件使用或覆盖了已过时的-API。-注-有关详细信息-请使用-Xlint-deprecation-重新编译。/","content":"[原文](https://blog.csdn.net/dong19900415/article/details/52882529?utm_source=blogxgwz3)\n\nError:注: 某些输入文件使用或覆盖了已过时的 API。\n注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。\n注: 某些输入文件使用了未经检查或不安全的操作。\n注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。\nFAILURE: Build failed with an exception.\n最近项目出现的一些问题可以在build中加入\n\n```\nallprojects {\n    gradle.projectsEvaluated {\n        tasks.withType(JavaCompile) {\n            options.compilerArgs << \"-Xlint:unchecked\" << \"-Xlint:deprecation\"\n        }\n    }\n}\n```","tags":["Error"],"categories":["Android"]},{"title":"如何打Jar工具包","url":"/2019/12/10/如何打Jar工具包/","content":"**打开Moudle包的build文件添加如下代码**\n```\ntask makeJar(type: Copy) {\n    def filename = projects.name + '-V'\n    delete \"build/libs/MarkZXing1.0.jar\"\n    from('build/intermediates/packaged-classes/release')\n    into('build/libs/')\n    include('classes.jar')\n    rename('classes.jar', 'MarkZXing1.0.jar')\n}\nmakeJar.dependsOn(build)\n```\n**点开我们右侧的Gradle，找到项目下的第一步新建的模块Module名称 ，点开 Tasks/other 文件 找到 makeJar， 双击即可，等待出现BUILD SUCCESSFUL， Task execution finished ‘makeJar’.==》编译完成，此时去Module目录下的libs/下找到的test.jar，便是制作的jar包。**","tags":["Android"],"categories":["Android"]},{"title":"Kotlin基础入门学习笔记","url":"/2019/12/03/Kotlin基础入门学习笔记/","content":"若不留下点啥笔记，感觉对不住自己一个星期半的学习加复习。\n### 一、如何实现单列模式？\n使用关键字 **object** 修饰的类,替换掉class关键字，便会在整套程序中生成一个且是唯一的对象实例。\n譬如如下代码：\n```\nobject BigHeadSon:IWash {\n    override fun wash() {\n        println(\"大头儿子洗完收费1元钱\")\n    }\n}\n```\n那样之后该类的实例变量整个项目中有且只有一个。\n<!-- more -->\n***\n### 二、如何实现枚举？\n实现枚举的代码如下：\n```\nenum class Week {\n    星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期日\n}\n\nfun main(args: Array<String>) {\n    println(Week.星期一.ordinal)\n}\n```\n使用关键字 enum 修饰类\n***\n### 三、如何实现印章类？\n举个例子一匹母驴、一屁公马和一匹公驴一碗酒后乱性，过了几天母驴怀孕了，不只是公马的还是公驴的。那么问题来了马和驴的后代是骡子，母驴和公驴的后代当然还是驴。\n就像盖了章一样，使用**sealed**关键字修饰类,可以指定子类和个数。\n```\n// 印章sealed类\n//指定子类种类和个数\n\nsealed class Son {\n    fun sayHello(){\n        println(\"大家好！！！\")\n    }\n    class smallBlackMule():Son()\n\n    class smallDonkey():Son()\n}\n\nfun main(args: Array<String>) {\n    var s1: Son = Son.smallBlackMule()\n\n    var s2: Son = Son.smallBlackMule()\n\n    var s3 = Son.smallDonkey()\n\n    var list = listOf<Son>( s1, s2, s3 )\n\n    for ( h in list){\n        if(h is Son.smallDonkey) {\n            h.sayHello()\n        }\n    }\n}\n```\n***\n### 四、如是实现委托和代理？\n利用关键字 **by** 实现，示例代码如下：\n```\nclass SmallHeadFather : IWash by BigHeadSon() {\n    override fun wash() {\n        println(\"小头爸爸洗完收费10块钱！！！\")\n        BigHeadSon().wash()\n        println(\"小头爸爸看见儿子把碗洗好了\")\n    }\n}\n```\n***\n### 五、如何实现多态和继承？\nkotlin是面向对象的语言，子类可以继承父类的方法和属性。\n**抽象类**：如父类，同一类具有同样基本属性和方法的类事物的描述，事物的本质描述。\n**接口**：指具有同样基本属性和方法的能力，事物的能力描述。\n```\n//抽象类\nabstract class Human(var name:String) {\n    abstract fun eat()\n\n    abstract fun pee()\n}\n\n//男人\nclass Man(name: String) : Human(name) {\n    override fun eat() {\n        println(\"${name}大口的吃饭,暴力\")\n    }\n\n    override fun pee() {\n        println(\"${name}站着尿尿---\")\n    }\n\n}\n//女人\nclass Woman(name: String) :Human(name) {\n    override fun pee() {\n        println(\"${name}蹲着尿尿---\")\n    }\n\n    override fun eat() {\n        println(\"${name}小口慢慢的吃饭，文雅\")\n    }\n}\n//测试\nfun main(args: Array<String>) {\n    var person1 = Man(\"金三胖\")\n    var person2 = Woman(\"波多野结衣\")\n    var person3 = Woman(\"貂蝉\")\n    var person4 = Man(\"吕布\")\n\n    var humanList = listOf<Human>(person1,person2,person3,person4)\n\n    for (h in humanList){\n        h.name\n//        h.eat()\n        h.pee()\n    }\n\n}\n```\n***\n### 六、when的表达式：\n```\n//考试成绩评级10分 9分A 8分B 7分C\n\nfun scoreMatch(score:Int):String{\n\twhen(score){\n\t\t10 -> return \"恭喜你拿了满分S\"\n\t\t9 -> return \"恭喜你拿了A\"\n\t\t8 -> return \"恭喜你拿了B\"\n\t\t7 -> return \"你拿了C，还需更加努力\"\n\t\telse -> return \"对不起你被OUT啦！\"\n\t}\n}\n\nfun main(agrs:Array<String>){\n\tprintln(scoreMatch(10))\n}\n```\n***\n### 七、空值判断：\n加上问好代表参数可以为空\n```\n//接收一个参数，参数为非空的String类型   \nfun heat(str:String?):String{\n\treturn \"热${str}\"\n}\n\nfun main(agrs:Array<String>){\n\tvar result1 = \"油\"\n\tprintln(heat(result1))\n\t\n\tvar result2 = null\n\tprintln(heat(result2))\n}\n```\n***\n### 八、函数表达式\n```\nfun main(args:Array<String>){\n\t//函数\n\tvar result = add(3,4)\n\tprintln(result)\n\t\n\t//函数表达式\n\tvar i = {x:Int,y:Int -> x+y}\n\tvar result2 = i(3,4)\n\tvar temp = result2==(7)\n\tprintln(\"${temp}\")\n\n}\n\nfun add(a:Int,b:Int):Int = a+b\n```\n***\n### 九、递归演示：\n**BigInteger**函数是Java数值运算大值时使用的属性，特殊的超级**Int**\n```\n//演示一\nimport java.math.BigInteger\n\n// 递归演示\n// 阶乘  5的阶乘：5*4*3*2*1\nfun main(args:Array<String>){\n\t///BigInteger是一个不可描述超大的数字\n\tprintln(\"请输入数字：\")\n\tvar a = readLine()\n    try{\n\t\tvar b:BigInteger = a!!.toBigInteger()\n\t\t//阶乘\n\t\tprintln(fact(b))\n\t}catch(e:Exception){\n\t\tprintln(\"输入数字有误！！\")\n\t}\n}\n\nfun fact(a:BigInteger):BigInteger{\n\tif(a==BigInteger.ONE)\n\t    return BigInteger.ONE\n\telse\n\t\treturn a*fact(a-BigInteger.ONE)\n}\n```\n尾递归 **tailrec**修饰方法,譬如超过电脑运算周期范围的计算\n```\n\nfun main(args:Array<String>){\n\tvar a = readLine()!!.toInt()\n\tvar num:Int = 0\n\tvar result:Int = 0\n\tprintln(add(a,num,result))\n}\n\n//尾递归 tailrec修饰方法\ntailrec fun add(nuk:Int,nn:Int,result:Int):Int{\n\tvar nns = nn+1\n\tvar results = result + nuk\n\tprintln(\"计算机第${nns}次运算,结果为：${results}\")\n\tif(nuk==1)\n\t\treturn results\n\telse\n\t\t\n\t\treturn add(nuk-1,nns,results)\n}\n```\n***\n### 十、List和Map\nList演示：\n```\n fun main(args:Array<String>){\n\t var lists = listOf(\"买鸡蛋\",\"买可乐\",\"买猪肉\",\"买大米\")\n\t \n\t for(a in lists){\n\t\t println(a)\n\t\t}\n\t \n\t for((i,e) in lists.withIndex())\n\t\t println(\"$i,$e\")\n\t\n}\n```\nMap演示：\n```\nimport java.util.TreeMap\n\nfun main(args:Array<String>){\n\t//TreeMap 同一key的value不能重复存在\n\tvar map = TreeMap<String,String>()\n\tvar list = listOf(\"好\",\"好\",\"学习\",\"天\",\"天\",\"向上\")\n\t\n\tmap[\"好\"] = \"Good\"\n\tmap[\"学习\"] = \"Study\"\n\tmap[\"天\"]  = \"Day\"\n\tmap[\"向上\"]  = \"Up\"\n\t\n\tfor(a in list){\n\t\tprint(\"${map[a]}  \")\n\t}\n}\n```\n***\n### 十一、人机交互\n```\nfun main(args:Array<String>){\n\tprintln(\"请输入第一个数字：\")\n\tvar c = readLine()\n\tprintln(\"请输入第二个数字：\")\n\tvar d = readLine()\n\t\n\ttry{\n\t\tvar a = c!!.toInt()\n\t    var b = d!!.toInt()\n\t\tprintln(\"${a} + ${b} = ${a + b}\")\n\t}catch(e:Exception){\n\t\tprintln(\"输入数据有误！，请重新输入\")\n\t}\n\t\n}\n```\n**!!.**确保不为空\n**?.**可为空\n\n","tags":["kotlin"],"categories":["Android"]},{"title":"kotlin学习笔记第一章","url":"/2019/11/19/kotlin学习笔记第一章/","content":"## 第一章 搭建 Kotlin 开发环境\n****\n### 一、Kotlin简介：\nKotlin是一种基于JVM的新型编程语言，它完全兼容Java语言。\n[慕课网电子书](https://songyubao.com/book/primary/lesson-summary.html)\n\n### Kotlin 优先意味着什么？\n在构建新的 Android 开发工具和内容（例如 Jetpack 库、示例、文档和培训内容）时，google会在设计层面考虑到 Kotlin 用户\n\n| |\tJava 语言\t|Kotlin|\n|-|-|-|\n|平台 SDK 支持|\t是\t|是|\n|Android Studio 支持|\t是\t|是|\n|Lint\t|是\t|是|\n|==引导式文档支持|\t是|\t是|\n|API 文档支持\t|是\t|是|\n|AndroidX 支持\t|是\t|是|\n|AndroidX Kotlin 特有 API（KTX、协程等）|\t无\t|是|\n|在线培训\t|尽力而为\t|是|\n|示例|\t尽力而为|\t是|\n|多平台项目|\t否\t|是|\n|Jetpack Compose|\t否\t|是|\n\n<!-- more -->\n\n### Kotlin能做什么?\n如果对 Kotlin 的能力仅仅停留在 JVM平 台，那是片面的。如今的 Kotlin 已经从当初的更好 Java 目标完成了它华丽的大变身，他们的目标已经瞄准了星辰大海。目前 Kotlin 可以适用于**移动端跨平台、原生 JVM、服务端开发、Web 开发、Android 开发、数据科学**等多个领域。此外近年来 Kotlin 团队已经将重心转移到了语言层面的跨平台，多平台的支持。\n![](https://songyubao.com/book/primary/kotlin/kotlin-ablility.png)\n\n### Kotlin与Java的异同\n**打印日志**\n> Java \n\n```java\nSystem.out.print(\"hello world\"); \nSystem.out.println(\"hello world\");\n```\n> Kotlin \n```kotlin\nprint(\"hello world\") println(\"hello world\") \n```\n\n**定义变量与常量常**\n> Java \n```java\nString name = \"hello world\";\nfinal String name = \"hello world\";\n```\n> Kotlin \n```kotlin\nvar name = \"hello world\" \nval name = \"hello world\" \n```\n**null声明**\n> Java \n```java\nString otherName; \notherName = null;\n```\n> Kotlin \n ```kotlin\n var otherName : String? \n otherName = null \n ```\n**空判断**\n> Java \n ```java\nif (text != null) { \n    int length = text.length();\n}\n```\n> Kotlin \n ```kotlin \ntext?.let { \n    val length = text.length\n} // \nor \nsimply val length = text?.length \n```\n**字符串拼接**\n> Java \n ```java \nString firstName = \"Android\"; \nString lastName = \"Architect\"; \nString message = \"My name is: \" + firstName + \" \" + lastName; \n```\n> Kotlin\n ```kotlin\n val firstName = \"Android\" \n val lastName = \"Architect\" \n val message = \"My name is: $firstName $lastName\" \n```\n**换行** \n> Java \n\n ```java \n String text = \"First Line\\n\" + \"Second Line\\n\" + \"Third Line\";\n ```\n> Kotlin \n\n ```Kotlin\n val text = \"\"\" |First Line |Second Line |Third Line \"\"\".trimMargin() \n ```\n**三元表达式**\n> Java \n\n```java\nString text = x > 5 ? \"x > 5\" : \"x <= 5\";\n ```\n> Kotlin \n```kotlin \nval text = if (x > 5) \"x > 5\" else \"x <= 5\" \n```\n**操作符**\n> java \n```\nfinal int andResult = a & b; \nfinal int orResult = a | b; \nfinal int xorResult = a ^ b; \nfinal int rightShift = a >> 2;\nfinal int leftShift = a << 2; \nfinal int unsignedRightShift = a >>> 2;\n```\n>  Kotlin \n```\nval andResult = a and b \nval orResult = a or b \nval xorResult = a xor b \nval rightShift = a shr 2 \nval leftShift = a shl 2 \nval unsignedRightShift = a ushr 2 \n```\n**类型判断和转换 (声明式)**\n> Java \n```\nCar car = (Car) object;\n```\n> Kotlin \n```\nvar car = object as Car \n```\n**类型判断和转换 (隐式)** \n> Java \n```java\nif (object instanceof Car) {\n    Car car = (Car) object; \n} \n```\n> Kotlin\n```kotlin\nif (object is Car) {\n    var car = object // 自动识别 \n}\n```\n**多重条件** \n> Java \n```java\nif (score >= 0 && score <= 300) { } \n```\n> Kotlin \n```\nif (score in 0..300) { } \n```\n**更灵活的case语句**\n> Java\n```java\nint score = // some score;String grade; \nswitch (score) { \n    case 10: \n    case 9: \n    grade = \"Excellent\"; \n    break; \n    case 8: \n    case 7: \n    case 6: \n    grade = \"Good\"; \n    break; \n    case 5: \n    case 4: \n    grade = \"OK\";\n    break; \n    case 3:\n    case 2:\n    case 1:\n    grade = \"Fail\";\n    break;\n    default:\n    grade = \"Fail\";\n} \n```\n> Kotlin\n```kotlin\nvar score = // some score \nvar grade = when (score) { \n    9, 10 -> \"Excellent\"\n    in 6..8 -> \"Good\" \n    4, 5 -> \"OK\" \n    in 1..3 -> \"Fail\"\n    else -> \"Fail\"\n}\n```\n\n**for循环**\n> Java\n ```java\n for (int i = 1; i <= 10 ; i++) { } \n for (int i = 1; i < 10 ; i++) { } \n for (int i = 10; i >= 0 ; i--) { } \n for (int i = 1; i <= 10 ; i+=2) { } \n for (int i = 10; i >= 0 ; i-=2) { } \n for (String item : collection) { }\n for (Map.Entry entry: map.entrySet()) { } \n ```\n> Kotlin\n ```lotlin\n for (i in 1..10) { }\n for (i in 1 until 10) { }\n for (i in 10 downTo 0) { }\n for (i in 1..10 step 2) { }\n for (i in 10 downTo 0 step 2) { }\n for (item in collection) { }\n for ((key, value) in map) { }\n ```\n**更方便的集合操作**\n> Java \n ```java\n final List listOfNumber = Arrays.asList(1, 2, 3, 4); \n final Map keyValue = new HashMap();\n map.put(1, \"Android\"); \n map.put(2, \"Ali\");\n map.put(3, \"Mindorks\"); // Java 9 \n final List listOfNumber = List.of(1, 2, 3, 4);\n final Map keyValue = Map.of(1, \"Android\", 2, \"Ali\", 3, \"Mindorks\");\n ```\n> Kotlin\n ```koltin\n val listOfNumber = listOf(1, 2, 3, 4)\n val keyValue = mapOf(1 to \"Android\", 2 to \"Ali\", 3 to \"Mindorks\")\n ```\n**遍历**\n> Java\n ```java\n // Java 7 and below \n for (Car car : cars) { \n     System.out.println(car.speed); \n }\n // Java 8+ \n cars.forEach(car -> System.out.println(car.speed)); \n // Java 7 and below \n for (Car car : cars) {\n     if (car.speed > 100) {\n         System.out.println(car.speed);\n     }\n }\n // Java 8+ \n cars.stream()\n     .filter(car -> car.speed > 100)\n     .forEach(car -> System.out.println(car.speed)); \n ```\n> Kotlin\n ```kotlin\n cars.forEach { println(it.speed) } \n cars.filter { it.speed > 100 } \n     .forEach { println(it.speed)} \n ```\n**方法定义**\n> Java \n ```java\n void doSomething() { \n    // logic here\n }\n void doSomething(int... numbers) { \n    // logic here \n }\n ```\n> Kotlin\n\n ```kotlin\n fun doSomething() { \n     // logic here \n } \n fun doSomething(vararg numbers: Int) {\n     // logic here \n }\n ```\n\n**带返回值的方法**\n\n> Java \n ```java\n int getScore() { \n    // logic here \n    return score; \n }\n ```\n> Kotlin\n ```kotlin\n fun getScore(): Int {\n    // logic here \n    return score \n }\n // as a single-expression function \n fun getScore(): Int = score\n ```\n**无结束符号**\n> Java \n ```java\n int getScore(int value) { \n    // logic here \n    return 2 * value; \n }\n ```\n > Kotlin\n ```kotlin\n fun getScore(value: Int): Int {\n    // logic here \n    return 2 * value \n } \n // as a single-expression function \n fun getScore(value: Int): Int = 2 * value \n ```\n**constructor 构造器** \n> Java \n ```java\n public class Utils { \n    private Utils() {\n         // This utility class is not publicly instantiable \n    } \n    public static int getScore(int value) {\n        return 2 * value; \n    } \n }\n ```\n> Kotlin\n ```kotlin\n class Utils private constructor() {\n    companion object {\n        fun getScore(value: Int): Int {\n            return 2 * value\n        }\n    }\n } \n // another way \n object Utils {\n    fun getScore(value: Int): Int {\n        return 2 * value\n    }\n }\n ```\n **Get Set 构造器**\n > Java \n  ```java\n  public class Developer {\n    private String name;\n    private int age;\n    public Developer(String name, int age) {\n        this.name = name; this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n }\n ```\n> Kotlin\n ```kotlin\n data class Developer(val name: String, val age: Int)\n ```","tags":["Android","Kotlin","学习笔记"],"categories":["Android"]},{"title":"Oracle数据库基础理论","url":"/2019/11/14/Oracle数据库基础理论/","content":"## **Oracle数据库是关系型数据库**\n### 一、什么是关系型数据库？\n***\n* 关系型数据理论最早是有E.F.Codd博士在1970年提出的。\n* Codd博士制定了一个数据库产品成为关系型数据库所必须符合的一些列相关的标准。\n* 它是RDBMS(关系型数据库管理系统)的基础。\n* 关系型数据库需包含下面三个方面：\n  - 对象或关系的集合\n  - 基于关系的操作集合\n  - 因数据的精确性和一致性而带来的数据的完整性\n* 关系型数据库是关系的集合或者是说是二维表的集合\n  \n### 二、Oracle数据库简介\n* 一个存储数据的地方\n* 能快速获取数据\n* 数据库安全性\n* 分布式数据库\n* 客户端和服务端的配置","tags":["Oracle"],"categories":["Oracle"]},{"title":"Flutter解决启动白屏","url":"/2019/11/14/Flutter解决启动白屏/","content":"### 为什么启动会出现白屏？\n由于Android启动的时候要进行一系列初始化，如检查权限，开启进程，绑定application，startActivity。\n这些初始化会稍微需要一点点时间，比如一秒钟。白屏持续的时间长短当然也和设备有关，设备越差白屏持续时间越长。\n<!--more-->\n### 如何解决？\n我这里使用第三方的插件进行解决。[flutter_splash_screen](https://pub.flutter-io.cn/packages/flutter_splash_screen).\n\n其使用方法看他的文档。\n\n### 记录下配置的时候遇到的问题？\n导包总是报错，先手敲代码，再导包。支持自定义启动布局。\n安卓的配置步骤多点。\n**下面是我安卓配置：**\n```\nimport org.devio.flutter.splashscreen.SplashScreen;\n\n\npublic class MainActivity extends FlutterActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    SplashScreen.show(this, true);// here\n    super.onCreate(savedInstanceState);\n    GeneratedPluginRegistrant.registerWith(this);\n\n    ///注册自己的 Plugin 插件\n    resisterSelfPlugin();\n  }\n```\n至于额为什么字体显示红色，别紧张，运行没得问题的。\n其他的配置看官方文档。\n添加\n`launch_screen.xml`\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <ImageView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:scaleType=\"centerCrop\"\n        android:src=\"@mipmap/screen_full\" />\n</RelativeLayout>\n```\n\n**下面是我 IOS 配置：**\n* 导入启动图片\n![](https://github.com/MarkCHYL/BLOG/blob/master/marksource/images/WechatIMG309.png?raw=true)\n* 配置启动图片\n![](https://github.com/MarkCHYL/BLOG/blob/master/marksource/images/WechatIMG310.png?raw=true)\n\n\n\n\n","tags":["Flutter"],"categories":["Flutter"]},{"title":"Flutter如何打包安卓apk包","url":"/2019/11/14/Flutter如何打包安卓apk包/","content":"\n作为安卓原生开发多年的我，也是第一次接触这种方式配置打包信息。原谅我的无知。\n### 一、在项目根目录下新建 key.properties 文件\n配置签名的基本信息\n<!--more-->\n```\nstorePassword=chenyunlin\nkeyPassword=chenyunlin\nkeyAlias=Mark\nstoreFile=/Users/mark/Desktop/Document/keyStore/MarkKey.jks\n```\n### 二、配置到app目录下的 build.gradle 文件\n在安卓目录下添加如下配置：导入配置 key.properties 的路径\n```\ndef keystorePropertiesFile = rootProject.file(\"key.properties\")\ndef keystoreProperties = new Properties()\nkeystoreProperties.load(new FileInputStream(keystorePropertiesFile))\nandroid{\n    ······\n}\n```\n配置签名的信息：\n```\nandroid {\n    ····\n      signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile file(keystoreProperties['storeFile'])\n            storePassword keystoreProperties['storePassword']\n        }\n        debug {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile file(keystoreProperties['storeFile'])\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n    ····\n}\n```\n\n这样下来安卓的配置信息配置完成。\n下面修改buildType是：\n```\n buildTypes {\n        release {\n            // Signing with the debug keys for now, so `flutter run --release` works.\n            signingConfig signingConfigs.release\n        }\n        debug {\n            // Signing with the debug keys for now, so `flutter run --release` works.\n            signingConfig signingConfigs.debug\n        }\n    }\n```\n### 三、切换到Terminal中\n输入 `Flutter build apk`,请静待程序运行完成。\n","tags":["Flutter"],"categories":["Flutter"]},{"title":"ping端口是否开放(macos)","url":"/2019/10/30/ping端口是否开放-macos/","content":"*简单的实用积累*\n\n[原文转自](https://blog.csdn.net/woodwindforward/article/details/89641636)\n### mac中：\n打开终端：\n\n* 输入 ping 域名：ping www.baidu.com\n  \n  ![](https://img2018.cnblogs.com/blog/1368523/201904/1368523-20190425193812807-428916356.png)\n\n* ping端口：nc -vz -w 2 www.baidu.com 8080\n  \n  ![](https://img2018.cnblogs.com/blog/1368523/201904/1368523-20190425193241938-258296742.png)\n  ","tags":["网络编程"],"categories":["网络编程"]},{"title":"Python实现批量生产二维码","url":"/2019/10/18/Python实现批量生产二维码/","content":"### 工具库：\n* pip3 install pillow\n* pip3 install qrcode\n* pip3 install xlrd\n具体是什呢？再次不做介绍，百度官网查询。\n<!--more-->\n### 记录编码：\n一、读取Excel表哥数据：\n```\ndef getInfo():\n    try:\n        data = xlrd.open_workbook(r\"/Users/mark/Desktop/carlistinfo.xlsx\")\n        sheetname = \"Sheet1\"\n        table = data.sheet_by_name(sheetname)\n        col_values = table.col_values(1)\n        return col_values\n    except Exception as e:\n        print(e)\n```\n二、生成二维码保存指定文件夹:\n```\n    matchList = getInfo()\n    for matchCode in matchList:\n        # 要放在循环里，否则 qr.add_data(filename) 会一直累加\n        qr = qrcode.QRCode(version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=1)\n        filename = matchCode\n        qr.add_data(filename)\n        qr.make(fit=True)\n        img = qr.make_image()\n        file = \"/Users/mark/Desktop/qrimg\"+\"/{0}.png\".format(matchCode)\n        img.save(file)\n```\n\n三、执行以上操作：\n\n*`getImage()`*\n\n### 全部源码：\n```\nimport qrcode\nimport xlrd\n\ndef getInfo():\n    try:\n        data = xlrd.open_workbook(r\"/Users/mark/Desktop/carlistinfo.xlsx\")\n        sheetname = \"Sheet1\"\n        table = data.sheet_by_name(sheetname)\n        col_values = table.col_values(1)\n        return col_values\n    except Exception as e:\n        print(e)\n\ndef getImage():\n    matchList = getInfo()\n    for matchCode in matchList:\n        # 要放在循环里，否则 qr.add_data(filename) 会一直累加\n        qr = qrcode.QRCode(version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=1)\n        filename = matchCode\n        qr.add_data(filename)\n        qr.make(fit=True)\n        img = qr.make_image()\n        file = \"/Users/mark/Desktop/qrimg\"+\"/{0}.png\".format(matchCode)\n        img.save(file)\n\ngetImage()\n```","tags":["Python"],"categories":["Python"]},{"title":"如何防止重新启动","url":"/2019/10/14/如何防止重新启动/","content":"我的问题描述：\n  >app需要登陆才能进入主页，每次退到后台或返回之后都会重新进入LoginActivity，我需要的效果是登陆后，每次都去跳MainActivity。\n\n<!--more-->\n说做就做，方法有很多种，我这记录的主要是利用回退栈 *moveTaskToBack(false)*来实现：\n* LoginActivity的onCreate()方法中添加：\n   \n   ``` \n   if (!isTaskRoot()) {\n        finish();\n        return;\n    }\n    ```\n    *注意添加再布局设置之前*\n* 再MainActivity中重写`onKeyDown`   和`onBackPressed`方法：\n  ```\n   @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK) {\n            moveTaskToBack(false);\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    @Override\n    public void onBackPressed() {\n        moveTaskToBack(false);\n        super.onBackPressed();\n    }\n  ```\n\n### moveTaskToBack(boolean  isToTask)这个方法的使用自己的理解就是不让Activity被系统主动回收。\n\n\n","tags":["Android"],"categories":["Android"]},{"title":"将项目迁移至androidx","url":"/2019/10/14/将项目迁移至androidx/","content":"## 自己的工具：\n* Android studio3.4.1\n* MacBook\n  \n## 迁移步骤：\n* 在gradle.properties添加如下内容：\n```\n  /**\n*android.useAndroidX=true 表示当前项目启用 androidx\n*android.enableJetifier=true 表示将依赖包也迁移到androidx 。如果取值为false,表示不迁移依赖包\n*到androidx，但在使用依赖包中的内容时可能会出现问题\n*/\nandroid.useAndroidX=true   \nandroid.enableJetifier=true \n```\n<!--more-->\n* 在AndroidStudio 3.2或更高（因为一个个去改太麻烦，这个版本有一键迁移的功能 Refactor -> Migrate to AndroidX  在执行该操作时会提醒我们是否将当前项目打包备份。如果你提前已经做好了备份，可以忽略；如果没有备份，则先备份。）\n![示意图](https://img-blog.csdnimg.cn/20190711092020175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzcxMjU4,size_16,color_FFFFFF,t_70)\n\n*gradle版本至少为3.2.0以上，以及compileSdkVersion为28以上。（否则点击Migrate to Androidx会出现如下错误）*\n\n![](https://img-blog.csdnimg.cn/2019071109224159.png)\n\n\n然后手动检查项目的并修改，先 build会报很多的错，慢慢改。\n### *没有或不能适配AndroidX的插件包，建议能删掉的就删掉*","tags":["Android"],"categories":["Android"]},{"title":"Android APK反编译 apktool使用教程","url":"/2019/09/26/Android-APK反编译-apktool使用教程/","content":"## 前言：\n\n时间久了之前在熟悉的东西也会渐疏，好记性不如乱笔头。\n\n## 工具介绍\n\n- apktool  \n\n​     作用：主要查看res文件下xml文件、AndroidManifest.xml和图片。（注意：如果直接解压.apk文件，xml文件打开全部是乱码）\n\n- dex2jar\n\n​     作用：将apk反编译成[Java](http://lib.csdn.net/base/javaee)源码（classes.dex转化成jar文件）\n\n- jd-gui\n\n​     作用：查看APK中classes.dex转化成出的jar文件，即源码文件\n<!--more-->\n\n## 新版本apktool用法：\n\n1、下载和安装方法：\n\nhttps://ibotpeaches.github.io/Apktool/install/\n\n![](https://img-blog.csdnimg.cn/20200326094455532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpcmtzbWFsbGVy,size_16,color_FFFFFF,t_70)\n\n**需要注意的是**\n步骤一种的脚步，另存为apktool后，一定要把下载的apktool_xxxx.jar重命名为apktool.jar ，并且要和apktool脚本放在同一级目录下。\n\n2、使用方法\n\nhttps://ibotpeaches.github.io/Apktool/documentation/\n\n`apktool d -f xxxx.apk`\n\n3、反编译开始\n\n反编译：\n\n```apktool d test.apk -o test```\n\n回编译\n\n```apktool b test -o new_test.apk```\n\n\n\n## 蚂蚁虽小也是肉，细心积累，慢慢提高自己，加油！\n","tags":["工具使用","反编译"],"categories":["Android"]},{"title":"Android 搜索 把软键盘上的回车键改为搜索","url":"/2019/09/25/Android-搜索-把软键盘上的回车键改为搜索/","content":"\n### 前言：\n> 项目中需要自定义一个搜做的功能，但是我通过更具UI的显示，完全没法使用V7包下的SearchView控件，于是我使用EditView自己写的。\n![](https://thumbnail0.baidupcs.com/thumbnail/cede3f055d8aeb66477c40eb3af2066a?fid=3761439320-250528-957214977420267&time=1569398400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-T%2FjYZusknxVB1gKzQcIJFFErJ%2FM%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=443423899171394619&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n\n<!--more-->\n### 具体实现如下：\n* 修改Editview属性：\n  \n  `android:imeOptions=\"actionSearch\"   `\n\n  在该Editview获得焦点的时候将“回车”键改为“搜索”\n\n  android:singleLine=\"true\"     \n\n  不然回车【搜索】会换行。\n\n* EditView编写监听按下控件监听，监听确认键的按下\n```\netSearchstr.setOnKeyListener(new View.OnKeyListener() {\n            @Override\n            public boolean onKey(View v, int keyCode, KeyEvent event) {\n                if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                    // 先隐藏键盘\n                    ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(GoodsListActivity.this.getCurrentFocus()\n                            .getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);\n                    //进行搜索操作的方法，在该方法中可以加入mEditSearchUser的非空判断\n                    refresh.autoRefresh();\n                }\n                return false;\n            }\n    } \n```\n","tags":["Android"],"categories":["Android"]},{"title":"界面为ScrollView时打开界面会自动滚动到底部之解决方法","url":"/2019/09/02/界面为ScrollView时打开界面会自动滚动到底部之解决方法/","content":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。\n本文链接：https://blog.csdn.net/u014449096/article/details/72885947\n\n**开发中遇到了这样的一个问题，界面最外层是ScrollView，然后里面有嵌套了一个ListView还有其他可以获取焦点的View，然后每次打开界面都会自动滚动到最底部，经过一番折腾，发现了一个简单的方法,\n获取ScrollView里面一个上层任意view，然后调用如下方法：**\n <!--more-->\n`view.setFocusable(true); \nview.setFocusableInTouchMode(true); \nview.requestFocus();`\n\n**或者将scrollview包裹的内容设置上以下两个属性 **\n`android:focusable=”true”\nandroid:focusableInTouchMode=”true”`\n\n例如：\n```\n<ScrollView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:scrollbars=\"none\"\n    >\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\"\n        android:focusable=\"true\"\n        android:focusableInTouchMode=\"true\" />\n        \n</ScrollView\n```","tags":["Android","冲突"],"categories":["Android"]},{"title":"ScrollView与RecyclerView解决滑动冲突","url":"/2019/09/02/ScrollView与RecyclerView解决滑动冲突/","content":"[原文](https://www.jianshu.com/p/3e0ad704bee5)\n\n**RecyclerView 嵌套RecyclerView是不存在冲突的 因为内部已经解决，ScrollVIew嵌套RecyclerView会存在现实不全的问题，滑动的时候会导致不流畅，所以我换用的是NestedScrollView嵌套RecyclerView不会存在显示不完全的现象，但是还会有一点的滑动冲突**\n\n <!--more-->\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.NestedScrollView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n        \n        <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"标题党\"/>\n\n        <android.support.v7.widget.RecyclerView\n            android:id=\"@+id/recyclerView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"/>\n      \n    </LinearLayout>\n\n</android.support.v4.widget.NestedScrollView>\n```\n\n**上面只是布局代码而已，滑动冲突还是没有解决，我们只要在recyclerView 设置一下这个属性就可以了**\n    `recyclerView.setNestedScrollingEnabled(false);`\n","tags":["Android","冲突"],"categories":["Android"]},{"title":"android 修改项目包名详解","url":"/2019/08/06/android-修改项目包名详解/","content":"再简单的东西也的记下来，不然容易忘记。\n此处原文地址来源：https://www.jianshu.com/p/1891d5a1a121\n>在android 平常项目开发中，修改项目包名是很常见的事，哪如何有限修改包名一步到位呢？经过几次痛苦的经历后，觉得有必要记录一番！\n <!--more-->\n对于修改包名，一般有两种情况：\n1）一个是包名目录结构不变，比如说，将包名“com.zlc.xuexi”，改成\"com.xuexi.zlc\"\n2）另一个是包名目录结构改变了，目录级数改变了，比如说，从\"com.xuexi.zlc\"，改变成\"com.xuexi.zlc.zlc\"，这里包名的目录结构就从3级改变成为了4级\n下面分别来讲解一下这两种情况\n1、第一种情况：包名目录结构不变\n针对第一种情况，其实特别好改，步骤截图如下：\n切换的Progject结构，查看java包名结构，一般是这样的\n\n![](https://upload-images.jianshu.io/upload_images/2108792-a0f6b84a3fcd681d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp)\n\n点击show options menu按钮\n\n![](https://upload-images.jianshu.io/upload_images/2108792-8e9f64f76dd666e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/534/format/webp)\n***\n\n![](https://upload-images.jianshu.io/upload_images/2108792-ca64b8ff27c0e2f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350/format/webp)\n\n去掉勾上的 Hide Empty Middle Packages  和 Show Members\n\n![](https://upload-images.jianshu.io/upload_images/2108792-245a095cfef4c8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/293/format/webp)\n\njava包的展示目录结构就改变了\n\n![](https://upload-images.jianshu.io/upload_images/2108792-b188356d6a454df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp)\n\n对于包名目录结构不改变的。就分别改各个层次对应的包名或者直接按快捷键 Shift + F6\n\n![](https://upload-images.jianshu.io/upload_images/2108792-5748e03a357ac8d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp)\n***\n![](https://upload-images.jianshu.io/upload_images/2108792-bbf9f6e3517de803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/629/format/webp)\n\n同理，假如是3级目录结构包名，每一个都要改变的话，就按照上图的做法一个个更改\n接着，去改app模块下的build.gradle文件\n\n![](https://upload-images.jianshu.io/upload_images/2108792-c2b0a1b594ceb7a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/531/format/webp)\n***\n\n![](https://upload-images.jianshu.io/upload_images/2108792-b50f2f39318e3a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp)\n\n然后去修改AndroidManifest.xml文件\n\n![](https://upload-images.jianshu.io/upload_images/2108792-f7573970e99b92ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp)\n\n最后，点击sync同步一下就大功告成了\n2、第二种情况：包名目录结构要改变的\n针对第二种情况，步骤截图如下：\n\n![](https://upload-images.jianshu.io/upload_images/2108792-a0f6b84a3fcd681d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp)\n点击show options menu按钮\n\n![](https://upload-images.jianshu.io/upload_images/2108792-8e9f64f76dd666e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/534/format/webp)\n\n***\n![](https://upload-images.jianshu.io/upload_images/2108792-ca64b8ff27c0e2f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350/format/webp)\n\n去掉勾上的 Hide Empty Middle Packages  和 Show Members\n\n![](https://upload-images.jianshu.io/upload_images/2108792-245a095cfef4c8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/293/format/webp)\n\njava包的展示目录结构就改变了\n\n![](https://upload-images.jianshu.io/upload_images/2108792-b188356d6a454df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp)\n\n对于包名目录结构不改变的。就分别改各个层次对应的包名或者直接按快捷键 Shift + F6\n\n![](https://upload-images.jianshu.io/upload_images/2108792-5748e03a357ac8d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp)\n***\n![](https://upload-images.jianshu.io/upload_images/2108792-bbf9f6e3517de803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/629/format/webp)\n\n假如是3级目录结构包名，改成4级包名目录机构，首先要新建包然后去移动其他的目录包\n\n![](https://upload-images.jianshu.io/upload_images/2108792-e43fefa7fb413d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692/format/webp)\n\n新建好多一级的目录包之后，需要移动启动文件夹到该目录包下\n\n![](https://upload-images.jianshu.io/upload_images/2108792-33d2a624c533d767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp)\n\n接着，去改app模块下的build.gradle文件\n\n![](https://upload-images.jianshu.io/upload_images/2108792-c2b0a1b594ceb7a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/531/format/webp)\n***\n\n![](https://upload-images.jianshu.io/upload_images/2108792-b50f2f39318e3a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp)\n\n然后去修改AndroidManifest.xml文件\n\n![](https://upload-images.jianshu.io/upload_images/2108792-f7573970e99b92ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp)\n\n最后，点击sync同步一下就大功告成了\n3、注意\n如果项目上用了DataBinding框架，特别是第二种情况，恭喜你，你肯能有得忙了。项目上有DataBinding框架的时候，当你按照上面的步骤修改了包名，就会报一个这样的错\n\n![](https://upload-images.jianshu.io/upload_images/2108792-534897b4744d5df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n***\n\n![](https://upload-images.jianshu.io/upload_images/2108792-feb5f5023ca50e8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n\n遇到这个情况，肯定是修改包名或者移动了包名结构，但是布局文件或者java文件的的dataBinding的引用没有改变\n\n![](https://upload-images.jianshu.io/upload_images/2108792-9a32a6931bffa51b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/631/format/webp)\n\n***\n![](https://upload-images.jianshu.io/upload_images/2108792-849db258b30d1aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650/format/webp)\n\n这里我没找到特别快速修改的方法，放在我是一个个去检查java文件的导包和xml布局文件的应用，看对不对，不对就要手动改过来了，呜呜。。。。。。\n\n![](https://upload-images.jianshu.io/upload_images/2108792-73e253453e85f5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp)\n\n如果，确定全部改完无误之后，重新Rebuild Project\n\n![](https://upload-images.jianshu.io/upload_images/2108792-8f5d3f454854f75c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/519/format/webp)\n\n万一，还是有刚才那个错误的话，记得再回头检查一遍java文件和布局文件，看看各自的引用对不对，如果全部都改对之后，还是有错误的话，哪就静下心来错误提示\n\n![](https://upload-images.jianshu.io/upload_images/2108792-77579a031568c1a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n\n如果不是DataBinding引起的话，一般都会找到比较明显的提示\n\n==========我是有分割线的：2019.04.15更新=================================\n如果真不好遇到第二种情况的话，面对databanding这种框架，那就只能使用全局替换的方法了\nctrl + Shift + R\n","tags":["Android"],"categories":["Android"]},{"title":"Android常见的三种弹框","url":"/2019/08/06/Android常见的三种弹框/","content":"再简单的东西时间长了，用的次数少了，会容易忘记。反之再复杂的东西其实也是由普普通通的东西实现的。\n**[感谢这位博主](https://blog.csdn.net/qq_35698774/article/details/79779238)总结**。\nAndroid在开发中经常会遇到有弹框的需求。经常使用的有Dialog 弹框，Window弹框，Activity伪弹框这三种。\n<!--more-->\n\n我这今天主要是记录下Dialog，简单的交互：\nDialog继承Object,异步调用，不会阻塞UI线程。以下是对他的整体框架：\n\n![图片来自网上](https://img-blog.csdn.net/2018040116510588 \"图片来自网上\")\n\n我今天使用的就是AlertDialog，以下其API方法：\n```\n setTitle ：为对话框设置标题\n setIcon ：为对话框设置图标\n setMessage：为对话框设置内容\n setView ： 给对话框设置自定义样式\n setItems ：设置对话框要显示的一个list，一般用于显示几个命令时\n setMultiChoiceItems ：用来设置对话框显示一系列的复选框\n setSingleChoiceItems ：用来设置对话框显示一系列的单选框\n setNeutralButton    ：普通按钮\n setPositiveButton   ：给对话框添加\"Yes\"按钮\n setNegativeButton ：对话框添加\"No\"按钮\n create ： 创建对话框\n show ：显示对话框\n ```\n\n 下面我贴一下我自己的代码：\n ```\n private void showDialog(SlibingMenuActivity mActivity, String message, int i) {\n        AlertDialog.Builder dialog = new AlertDialog.Builder(mActivity);\n        dialog.setTitle(\"温馨提示：\");\n        dialog.setMessage(message);\n        dialog.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                Toast.makeText(mActivity, \"您点击了取消\", Toast.LENGTH_SHORT).show();\n            }\n        });\n        dialog.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                if (i == 0) {\n                    ClockOn();//上班\n                } else if (i == 1) {\n                    ClockOff();\n                } else if (i == 2) {\n                    logout();\n                }\n            }\n        });\n        dialog.create();\n        dialog.show();\n    }\n\n```\n\n## 1.只显示标题和内容\n\n```\nAlertDialog alertDialog1 = new AlertDialog.Builder(this)\n        .setTitle(\"这是标题\")//标题\n        .setMessage(\"这是内容\")//内容\n        .setIcon(R.mipmap.ic_launcher)//图标\n        .create();\nalertDialog1.show();\n```\n\n![](https://img-blog.csdn.net/20180401170308265)\n\n## 2.有多个按钮\n\n>setPositiveButton  设置一个确定按钮\n\n>setNegativeButton  设置一个取消按钮\n\n>setNeutralButton   设置一个普通按钮\n```\n这三个按钮可以随意组合使用不冲突。\nAlertDialog alertDialog2 = new AlertDialog.Builder(this)\n        .setTitle(\"这是标题\")\n        .setMessage(\"有多个按钮\")\n        .setIcon(R.mipmap.ic_launcher)\n        .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {//添加\"Yes\"按钮\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"这是确定按钮\", Toast.LENGTH_SHORT).show();\n            }\n        })\n \n        .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {//添加取消\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"这是取消按钮\", Toast.LENGTH_SHORT).show();\n            }\n        })\n        .setNeutralButton(\"普通按钮\", new DialogInterface.OnClickListener() {//添加普通按钮\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"这是普通按钮按钮\", Toast.LENGTH_SHORT).show();\n            }\n        })\n        .create();\nalertDialog2.show();\n```\n\n![](https://img-blog.csdn.net/20180401170521672)\n \n\n## 3.一个列表\n\n>setItems  里面写列表数据\n```\nfinal String[] items3 = new String[]{\"苍老湿\", \"小泽老湿\", \"波多野结衣老湿\", \"吉泽明步老湿\"};//创建item\nAlertDialog alertDialog3 = new AlertDialog.Builder(this)\n        .setTitle(\"选择您喜欢的老湿\")\n        .setIcon(R.mipmap.ic_launcher)\n        .setItems(items3, new DialogInterface.OnClickListener() {//添加列表\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"点的是：\" + items3[i], Toast.LENGTH_SHORT).show();\n            }\n        })\n        .create();\nalertDialog3.show();\n```\n![](https://img-blog.csdn.net/20180401170703518)\n\n\n## 4.单选列表\n\n>setSingleChoiceItems  单选框列表\n```\nfinal String[] items4 = new String[]{\"苍老湿\", \"小泽老湿\", \"波多野结衣老湿\", \"吉泽明步老湿\"};//创建item\nAlertDialog alertDialog4 = new AlertDialog.Builder(this)\n        .setTitle(\"选择您喜欢的老湿\")\n        .setIcon(R.mipmap.ic_launcher)\n        .setSingleChoiceItems(items4, 0, new DialogInterface.OnClickListener() {//添加单选框\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                index = i;\n            }\n        })\n        .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {//添加\"Yes\"按钮\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"这是确定按钮\" + \"点的是：\" + items4[index], Toast.LENGTH_SHORT).show();\n            }\n        })\n \n        .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {//添加取消\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"这是取消按钮\", Toast.LENGTH_SHORT).show();\n            }\n        })\n        .create();\nalertDialog4.show();\n```\n \n## 5.多选列表\n> setMultiChoiceItems 多选框\n\n```\nfinal String[] items5 = new String[]{\"苍老湿\", \"小泽老湿\", \"波多野结衣老湿\", \"吉泽明步老湿\"};//创建item\nfinal boolean[] booleans = {true, true, false, false};\nAlertDialog alertDialog5 = new AlertDialog.Builder(this)\n        .setTitle(\"选择您喜欢的老湿\")\n        .setIcon(R.mipmap.ic_launcher)\n        .setMultiChoiceItems(items5, booleans, new DialogInterface.OnMultiChoiceClickListener() {//创建多选框\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i, boolean b) {\n                booleans[i] = b;\n            }\n        })\n        .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {//添加\"Yes\"按钮\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                StringBuilder stringBuilder = new StringBuilder();\n                for (int a = 0; a < booleans.length; a++) {\n                    if (booleans[a]) {\n                        stringBuilder.append(items5[a] + \" \");\n                    }\n                }\n                Toast.makeText(AlertDialogActivity.this, \"这是确定按钮\" + \"点的是：\" + stringBuilder.toString(), Toast.LENGTH_SHORT).show();\n            }\n        })\n \n        .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {//添加取消\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"这是取消按钮\", Toast.LENGTH_SHORT).show();\n            }\n        })\n        .create();\nalertDialog5.show();\n```\n\n![](https://img-blog.csdn.net/20180401170947418)\n \n\n### 6.setAdapter的用法\n\n```\nfinal String[] items6 = new String[]{\"苍老湿\", \"小泽老湿\", \"波多野结衣老湿\", \"吉泽明步老湿\"};//创建item\nAlertDialog alertDialog6 = new AlertDialog.Builder(this)\n        .setTitle(\"选择您喜欢的老湿\")\n        .setIcon(R.mipmap.ic_launcher)\n        .setAdapter(new ArrayAdapter<String>(AlertDialogActivity.this, R.layout.item, R.id.tv, items6), new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                Toast.makeText(AlertDialogActivity.this, \"点的是：\" + items6[i], Toast.LENGTH_SHORT).show();\n            }\n        })\n        .create();\nalertDialog6.show();\n```\n\n![](https://img-blog.csdn.net/20180401171051313)\n \n\n## 7.自定义view的用法\n\n```\nfinal AlertDialog.Builder alertDialog7 = new AlertDialog.Builder(this);\nView view1 = View.inflate(this, R.layout.activity_alter_dialog_setview, null);\nfinal EditText et = view1.findViewById(R.id.et);\nButton bu = view1.findViewById(R.id.button);\nalertDialog7\n        .setTitle(\"Login\")\n        .setIcon(R.mipmap.ic_launcher)\n        .setView(view1)\n        .create();\nfinal AlertDialog show = alertDialog7.show();\nbu.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View view) {\n        Toast.makeText(AlertDialogActivity.this, \"电话\" + et.getText().toString(), Toast.LENGTH_SHORT).show();\n        show.dismiss();\n    }\n});\n```\n\n![](https://img-blog.csdn.net/20180401211644887)\n\n[原文链接：](https://blog.csdn.net/qq_35698774/article/details/79779238)","tags":["Android"],"categories":["Android"]},{"title":"Flutter项目实战目录","url":"/2019/07/29/Flutter项目实战目录/","content":"\n# Flutter 实战项目源码目录\n\n* 携程App项目实战 [源码地址](https://github.com/MarkCHYL/flutter_mark_trip)","tags":["Flutter实战"],"categories":["Flutter"]},{"title":"Hexo yilia 主题添加 widgetpack 评论系统","url":"/2019/07/21/Hexo-yilia-主题添加-widgetpack-评论系统/","content":"## 前言：\n---\n> 记得这周都在忙着给我的博客添加评论功能，脑子都懵逼啦！开始起初是想利用GitHub的gitment和gittalk进行集成，按照的网上的套路也弄了，总是报错，对于我只是安卓原生的小码农来说，我完全抓瞎。\n<!--more-->\n**下面的分析来自**[阿甘的博客](https://blog.csdn.net/ganzhilin520/article/details/79048010 )\n\n目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。\n\n可用的评论系统大概有：  \n- HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）\n\n- 来必力：https://livere.com （来自韩国，使用邮箱注册。）\n\n- 畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。）\n\n- Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）\n\n- Valine: https://github.com/xCss/Valine (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）\n\n综上，我开始采用了来必力。\n**可能是来必力来自韩国，我没调查资料，是看上面的文字时韩国的瞎说的，功能我到是实现了，界面渲染有点卡顿，最终放弃了。\n\n# widgetpack 评论系统\n这是我这次笔记的重点，此刻是周末晚上，明早就要上班啦！给自己定的任务计划没完成，Mark我有点睡不着，无聊的我打开了电脑发现了这个**widgetpack**，在此感谢博主的贡献[貌似掉线](https://blog.csdn.net/maosidiaoxian/article/details/94651023),\n\n- 免费的\n- 哪儿的？国外的，放心没被强，我是科学守法的好公民\n- 还没调查，貌似是欧洲的，[介绍地址](https://widgetpack.com/comment-system)\n- 邮箱注册便可\n\n下面是[貌似掉线](https://blog.csdn.net/maosidiaoxian/article/details/94651023)的原文：\n## 集成步骤：\n### 1. 主题配置添加 widgetpack\n修改 hexo 博客目录的 theme/yilia 中的 _config.yml 文件，增加如下配置：\n```\n# widgetpack。将 false 改为 widgetpack 上的 id 则启用该评论系统。\nwidgetpack: false\n```\n\n### 2. 新增 widgetpack 代码文件\n在 yilia 中的 layout/_partial/post 下新增 widgetpack.ejs文件，内容如下：\n这段代码，在你注册 widgetpack 之后也会有\n```\n<div id=\"wpac-comment\"></div>\n<script type=\"text/javascript\">\nwpac_init = window.wpac_init || [];\nwpac_init.push({widget: 'Comment', id: <%=theme.widgetpack%>});\n(function() {\n    if ('WIDGETPACK_LOADED' in window) return;\n    WIDGETPACK_LOADED = true;\n    var mc = document.createElement('script');\n    mc.type = 'text/javascript';\n    mc.async = true;\n    mc.src = 'https://embed.widgetpack.com/widget.js';\n    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);\n})();\n</script>\n<a href=\"https://widgetpack.com\" class=\"wpac-cr\">Comments System WIDGET PACK</a>\n\n```\n### 3. 修改 article.ejs\n由于我使用的 yilia 主题没有自带 widgetpack 的代码，修改 yilia 中的 layout/_partial/article.ejs 文件，在 <% if (!index && post.comments){ %> 后的任意一个评论代码前或后插入如下代码：\n```\n    <%if (theme.widgetpack) { %>\n      <%- partial('post/widgetpack') %>\n    <% } %>\n```\n这段代码加在哪儿？打开之后好好的看编辑器上的代码。\n\n----\n**如上三步，修改完成。如果要启用，修改主题的 _config.yml 文件，将 widgetpack 的值改为 widgetpack 上的 id 即可，注意冒号之后有空格**","tags":["Hexo","工具搭建"],"categories":["工具使用"]},{"title":"flutter入门之常见的flutter问题汇总","url":"/2019/07/11/flutter入门之常见的flutter问题汇总/","content":"[csdn上原博文](https://blog.csdn.net/email_jade/article/details/85317859###)\n\n【原创不易，转载请注明出处：https://blog.csdn.net/email_jade/article/details/85317859】\n<!--more-->\n1. 使用AppBar后如何去掉左边的返回箭头。左边的图标对应的是leading，源代码如下（吐槽一下，CSDN暂不支持dart语言）：\n\n    Widget leading = widget.leading;\n    if (leading == null && widget.automaticallyImplyLeading) {\n      if (hasDrawer) {\n        leading = IconButton(\n          icon: const Icon(Icons.menu),\n          onPressed: _handleDrawerButton,\n          tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip,\n        );\n      } else {\n        if (canPop)\n          leading = useCloseButton ? const CloseButton() : const BackButton();\n      }\n    }\n    if (leading != null) {\n      leading = ConstrainedBox(\n        constraints: const BoxConstraints.tightFor(width: _kLeadingWidth),\n        child: leading,\n      );\n    }\n修改方式为， leading为null，automaticallyImplyLeading为false：\n\nappBar: AppBar(\n        leading: null,\n        automaticallyImplyLeading: false,)\n2. 使用flutter的canvas做文字绘制的时候用到的api为TextPainter\n\n3. 使用flutter绘制控件的时候想做到控件超出屏幕范围后自动换行，那么请参考Wrap，可以轻松实现如下的布局：\n\n\n\n4. 要实现类似安卓原生ViewPager的UI，请使用PageView，注意定义自己的PageController，然后可以利用PageController的jumpToPage（int）实现自定义的Page页的跳转\n\n5. 要实现类似顶部和底部导航栏，请参考TabBar，适当的时候可以和AppBar结合使用\n\n6. flutter is a SingleTickerProviderStateMixin but multiple tickers were created. 报错，原因是多个地方调用setState请求重绘，但是state使用的是SingleTickerProviderStateMixin ，将其改成TickerProviderStateMixin即可。\n\n7. 解决类冲突的问题，比如，我自定义一个Banner.dart类，这个类跟系统的Banner冲突，那么我们可以这样解决。\n\nimport 'package:flutter/material.dart';\nimport 'package:myproject/Banner.dart' as myproject;\n \n//这样使用我们自己的Banner\nmyproject.Banner _myBanner;\n//系统的Banner\nBanner _banner;\n8. 解决Android手机布局浸入到状态栏的问题，用一个SafeArea进行包装即可，如下：\n\nSafeArea(top: true,\n      child: MaterialApp(\n        home: ,\n      ),);\n9. 在切换tabbar或者pageview的时候要保存上一个tab widget的状态，参考AutomaticKeepAliveClientMixin既可，如下：\n\n//假如PageView有四个子页面\n \n @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        body: PageView(\n          controller: pageController,\n          children: <Widget>[\n            ArticlesPage(),\n            ProjectPage(),\n            NavigationPage(),\n            CollectionArticlesPage(),\n          ],\n          onPageChanged: changePage,\n        ),\n        bottomNavigationBar: Navigations(_page, changePage));\n  }\n \n \n \n//然后在子Page的State分别实现with AutomaticKeepAliveClientMixin，wantkeepAlive返回true\n \nclass ArticlesPageState extends State<ArticlesPage> with AutomaticKeepAliveClientMixin{\n  @override\n  bool get wantKeepAlive => true;\n}\n \nclass ProjectPageState extends State<ProjectPage> with AutomaticKeepAliveClientMixin{\n  @override\n  bool get wantKeepAlive => true;\n}\n \nclass NavigationPageState extends State<NavigationPage> with AutomaticKeepAliveClientMixin{\n  @override\n  bool get wantKeepAlive => true;\n}\n \nclass CollectionArticlesPageState extends State<CollectionArticlesPage> with AutomaticKeepAliveClientMixin{\n  @override\n  bool get wantKeepAlive => true;\n}\n10. Android手机启动时候白屏的问题解决，android/app/src/main/res/drawable/launch_background.xml中定义了自定义splash的方法：\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Modify this file to customize your launch splash screen -->\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@android:color/white\" />\n \n    <!-- You can insert your own image assets here -->\n    <!-- <item>\n        <bitmap\n            android:gravity=\"center\"\n            android:src=\"@mipmap/launch_image\" />\n    </item> -->\n</layer-list>\n将<item>注释去掉，替换为自己的launcher_image即可 。\n\n11.  界面存在输入框的时候，点击后软键盘将页面顶起来导致页面重绘的问题（Android fitsystem），可以通过将Scaffold的resizeToAvoidBottomPadding属性设置为false来关闭重绘，如下：\n\nreturn Scaffold(\n      resizeToAvoidBottomPadding: false,\n);\n12. 修改TextFiled的边界宽度，可以通过decoration的contentPadding属性进行修改，如下：\n\nreturn TextField(\n        decoration: InputDecoration(\n          contentPadding: EdgeInsets.all(8),\n        ),\n);\n13. 如果想实现一个布局，在某些条件下显示，可以采用Offstage布局，动态控制其offstage属性值即可\n\n14. 如果出现弹出输入法的时候导致Overflow错误，可以将布局镶嵌到SingleChildScrollView中，比如：\n\n return Scaffold(\n      body: SingleChildScrollView(\n        child: Container(\n          constraints: BoxConstraints(\n            maxHeight: MediaQuery.of(context).size.height,\n            maxWidth: MediaQuery.of(context).size.width,\n          ),\n        ),\n    ),\n);\n15. GridView的item宽高默认是1:1，可以通过修改childAspectRatio的值来进行宽高的修改，该值代表宽：高\n\n16. flutter中绘制虚线，使用path_drawing\n\n17. flutter 中禁用GridView的滚动，可以使用physics属性，取值为NeverScrollableScrollPhysics()，如下：\n\nGridView.count(\n      physics: NeverScrollableScrollPhysics(),\n);\n18. flutter隐藏状态栏，使用：\n\nSystemChrome.setEnabledSystemUIOverlays([]);\n19. 监听某个widget是否已经渲染完成，使用WidgetsBinding，方法是在initstate或者build中注册回调，如下：\n\n    WidgetsBinding.instance.addPostFrameCallback((callback){\n      print(\"complete\");\n    });\n20. flutter设置屏幕支持的方向：\n\n   以下设置为设置整个项目运行到时候只允许横屏，如果需要其他方向，可以参考设置。\n\n  SystemChrome.setPreferredOrientations([DeviceOrientation.landscapeLeft, DeviceOrientation.landscapeRight]).then((_){\n    runApp(MyApp());\n  });\n对于IOS来说，可能我们设置只允许横屏了，但是效果确依旧可以竖屏，记得修改xcode的General--Deployment Info--Device Orientation属性，自己勾选对应的方向，如下。\n\n\n\n设置屏幕显示方向，由于flutter中有bug，在IOS端可能不生效，需要插件支持，见 https://github.com/jadennn/flutter_orientation \n\n21. flutter设置多语言支持的时候发现在IOS端只显示英语的bug，是由于xcode中默认没有添加中文（其他语言类似）的选择，解决办法，在Info--Locallzations中选择需要的语言，如下：\n\n\n\n22. flutter中禁止控件复用，可以使用不同的key，比如说，如果我们有一个stateful的控件，在initstate中进行了一些值的初始计算，在页面中需要展示多个这样的控件，不想多个控件公用同一套参数（换句话说，initstate只会在第一次初始化的时候调用），那么可以设置不同的key。\n\n23. 裁剪图片的方法：\n\nimport 'dart:ui' as DartUi;\n  \n///根据src和dst裁剪图片\n  static DartUi.Image getCroppedImage(DartUi.Image image, Rect src, Rect dst) {\n    var pictureRecorder = new DartUi.PictureRecorder();\n    Canvas canvas = new Canvas(pictureRecorder);\n    canvas.drawImageRect(image, src, dst, Paint());\n    return pictureRecorder\n        .endRecording()\n        .toImage(dst.width.floor(), dst.height.floor());\n  }\n24. 在不使用BuildContext的情况下进行页面跳转：\n\n    a. 创建一个global的key\n\nstatic GlobalKey<NavigatorState> gNavigatorKey = new GlobalKey<NavigatorState>();\n    b. 在MaterialApp初始化的时候使用\n\nreturn MaterialApp(\n      navigatorKey: Global.gNavigatorKey,\n      routes: <String, WidgetBuilder> {\n        '/login': (BuildContext context) => new LoginPage(),\n      },\n      //....代码省略\n    c. 需要的地方使用：\n\nGlobal.gNavigatorKey.currentState.pushNamedAndRemoveUntil('/login',(_) => false);\n    注意的是这种方法代价比较大，除非特殊情况，否则不建议使用。使用的时候根据不同的场景调用不同的push方法\n--------------------- \n作者：Hirabbit_jaden \n来源：CSDN \n原文：https://blog.csdn.net/email_jade/article/details/85317859 \n版权声明：本文为博主原创文章，转载请附上博文链接！","tags":["Flutter","Flutter问题"],"categories":["Flutter"]},{"title":"防止页面重绘制，实现AutomaticKeepAliveClientMixin","url":"/2019/07/10/防止页面重绘制，实现AutomaticKeepAliveClientMixin/","content":"[原文](https://blog.csdn.net/weixin_34320159/article/details/87566116 )\n\n### 参考 \nhttps://www.colabug.com/3162835.html\nhttps://stackoverflow.com/questions/53011686/flutter-automatickeepaliveclientmixin-is-not-working-with-bottomnavigationbar62835.html\n\n*Flutter切换tab后保留tab状态 概述 Flutter中为了节约内存不会保存widget的状态,widget都是临时变量。当我们使用TabBar,TabBarView是我们就会发现,切换tab，initState又会被调用一次。\n怎么为了让tab一直保存在内存中，不被销毁？\n添加AutomaticKeepAliveClientMixin，并设置为true,这样就能一直保持当前不被initState了。*\n <!--more-->\n```\nclass TicketListViewState extends State<TicketListView>\n    with AutomaticKeepAliveClientMixin {\n  @override\n  void initState() {\n    super.initState();\n  }\n \n  @override\n  Widget build(BuildContext context) {\n    super.build(context);\n    return new SmartRefresher(\n        enablePullDown: true,\n        enablePullUp: true,\n        onRefresh: _onRefresh,\n        controller: refreshController,\n        child: ListView.builder(\n          itemCount: _result.length,\n          itemBuilder: (context, index) {\n            return getItem(_result[index]);\n          },\n        ));\n  }\n  //不会被销毁,占内存中\n  @override\n  bool get wantKeepAlive => true;\n}\n```\n**如果不起作用:**\n```\n  @override\n  Widget build(BuildContext context) {\n    super.build(context);//必须添加\n   .....\n        ));\n```\n官方解释\n```\n/// A mixin with convenience methods for clients of [AutomaticKeepAlive]. Used\n/// with [State] subclasses.\n///\n/// Subclasses must implement [wantKeepAlive], and their [build] methods must\n/// call `super.build` (the return value will always return null, and should be\n/// ignored).\n```","tags":["Flutter","Flutter问题"],"categories":["Flutter"]},{"title":"flutter开发插件和包","url":"/2019/07/02/flutter开发插件和包/","content":"\n## cmd 命令创建开发插件包\n `flutter create --org com.mark --template markplugin`\n  使用该--org选项以反向域名表示法指定您的组织。此值用于生成的Android和iOS代码中的各种包和包标识符。\n  其中 com.mark 就是我的组织名，markplugin 就是我的插件项目名字\n  生成如下：\n<!--more-->\n![\"插件包生成内容\"](https://img-blog.csdnimg.cn/20190702095035265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70  )\n\n***默认情况下，插件项目使用Objective-C for iOS代码和Java for Android代码。如果您更喜欢Swift或Kotlin，您可以使用-i和/或使用Android语言指定iOS语言-a.***\n\n例如：\n` flutter create --org com.mark --template=plugin -i swift -a kotlin markkotlinpugin`\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190702101606454.png)\n\n## 如何通过命令创建Flutter包\n要创建Dart包，请使用以下--template=package标志flutter create：\n `flutter create --org com.mark --template=package hello`\n\n这将在hello/文件夹中创建一个包项目，其中包含以下专门内容：\n\n`\nlib/hello.dart：包的Dart代码。\n\ntest/hello_test.dart：该单元测试包装。`\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190702102101747.png)\n\n## 配置好pubspec.paml上的信息,添加开源协议，编写使用说明\n```\nname: flutter_tools\ndescription: A new Flutter Tools package. it works on ios and android\nversion: 0.0.1\nauthor: MarkCHYL <2285581945@qq.com>\nhomepage: https://github.com/MarkCHYL/flutter_tools\n```\n## 发布包\n[参考地址](https://flutter.dev/docs/development/packages-and-plugins/developing-packages)\n首先我们执行：\n`flutter pub pub publish --dry-run`\n会检查发布包时是否准备好，是否有错误。\n`flutter packages pub publish`发布包，\n但是我因网络原因，没上传成功过。首次大包上传需要登陆谷歌的网站，谷歌账号登陆便好。","tags":["Flutter"],"categories":["Flutter"]},{"title":"Mac上搭建apktool反编译工具","url":"/2019/06/13/Mac上搭建apktool反编译工具/","content":"apktool下载地址：\n`https://ibotpeaches.github.io/Apktool/install/`\n<!--more-->\n### 1.在Chrome中，打开网址，找到图中所示Mac相关部分\n![](https://img-blog.csdnimg.cn/20191226175801984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70)\n### 2.在Chrome中，打开网址，在“ wrapper script”上点击鼠标右键，选择“链接存储为”\n![](https://upload-images.jianshu.io/upload_images/13001414-fb0faffd01c74a08.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n存储时，必须选择格式为“所有文件”，文件名为“apktool”，没有后缀(貌似有些浏览器不能选择格式，我在Chrome浏览器可以选择文件格式)\n ![](https://upload-images.jianshu.io/upload_images/13001414-217bcc315f02b99f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n### 3.点击“find newest here”进入下载页面，选择合适的版本，下载.jar文件，下载后文件名要改为“apktool.jar”\n ![](https://upload-images.jianshu.io/upload_images/13001414-16b2c8e8c0b1dc31.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n ![](https://upload-images.jianshu.io/upload_images/13001414-ae3dbce397cce0b3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n\n### 4.把apktool和apktool.jar文件移动到\"/usr/local/bin\"目录下，并使用终端命令为两个文件增加执行权限\n命令如下：\n`chmod +x apktool.jar apktool`\n### 5.验证是否安装成功\n在终端输入命令：apktool\n打印如下信息：\n\n![\"安装成功的打印新信息\"](https://img-blog.csdnimg.cn/20191226185747298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1YWlndWFpXzIwMTU=,size_16,color_FFFFFF,t_70 '安装成功的打印新信息')","tags":["反编译","工具搭建"],"categories":["工具使用"]},{"title":"Mac上实现SVN代码管理","url":"/2019/05/30/Mac上实现SVN代码管理/","content":"### 参考地址：\n* [Cornerstone 参考地址1](https://www.jianshu.com/p/99145ee591c8)\n* [Cornerstone 参考地址1](https://blog.csdn.net/dangbai01_/article/details/79413692)\n* [Android Studio 实现SVN项目管理](https://blog.csdn.net/heisejiuhuche/article/details/47394407)\n* [配置时我遇到的问题参考地址](https://blog.csdn.net/zf18234031156/article/details/88895122)\n  <!--more-->\n### 我的工具：\n* Mac电脑、\n* ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529164521582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70)\n***\n\n### 添加SVN上的工作目录：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529164803263.png)\n接着填写SVN的服务器信息和你的账号密码：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529164954758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70)\n最后点击`add`按钮，完成接下来的一步，仅仅等待就好：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052916554583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70)\n### 本地代码的上传到SVN：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529165634203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70)\n静静等候**上传完毕**。\n***\n### 拉取SVN上的项目\n前提是SVN上有你想要拉的项目：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529170253362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70)\n耐心等待拉取完成。","tags":["工具使用"],"categories":["工具使用"]},{"title":"上传本地代码到指定的Git仓库","url":"/2019/05/29/上传本地代码到指定的Git仓库/","content":"\n### 1、本地安装git环境\n下载安装包安装即可，在这里不加记录。\n***\n### 2、初始化git项目，生成 .git 配置目录\n进入项目根目录,右键 git bash here打开控制台 ，输入git init即可完成。\n <!--more-->\n***\n### 3、将项目加入本地git仓库\ngit add . （此处add后面有空格 和点号）\ngit status\ntouch README.md （可不要\ngit add README.md （可不要\ngit commit -m \"first commit\"\n***\n### 4、在git、码云建好云端项目，生成git url\n建好项目，在项目的克隆下载处复制url即可\n***\n### 5、连接云端仓库,将本地仓库代码提交到云端仓库\n连接云端仓库\n*git remote add origin https://gitee.com/xxx/xxx.git\n*git push origin master\n为解决本地与云端版本冲突，加上-f参数，push文件\ngit push --set-upstream origin master -f\n之后会提示输入云端仓库的用户名，密码，验证成功开始上传并完成，实测码云可通过。*\n***\n不加f会提示错误：\n```\n! [rejected] master -> master (non-fast-forward)\nerror: failed to push some refs to 'https://gitee.com/xxx/xxx.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n\n到此就完成了目的。\n以后每次提交是先提交到本地仓库，需重新运行 \n```\ngit push --set-upstream origin master -f\n```\n更新到云端\n或是`commit `后 `push`\ngit 修改用户名，邮箱：\n当前 project：\n直接修改 .git目录下 config文件的\n```\n[user]\nname =xxx\nemail = xxx\n```\n或\n```\ngit config user.name 用户名;\ngit config user.email 邮箱;\n```\n全局：\n```\ngit config  --global user.name 用户名；\ngit config  --global user.email 邮箱名;\n```\n### 6、`git` 删除 项目`remote`\n终端执行`git remote remove origin`,origin为项目`remote`的名字\n\n添加远程仓库(远程仓库引用)命令：\n> 使用命令：**git remove add 远程仓库到本地的名称  远程仓库的路径**\n[更多指令学习参考](https://blog.csdn.net/weixin_44703358/article/details/100514085)","tags":["工具使用"],"categories":["Git"]},{"title":"Flutter中使用Banner 图","url":"/2019/04/10/Flutter中使用Banner-图/","content":"## 实现效果\n![\"效果图\"](https://img-blog.csdnimg.cn/20190410142106370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfQ0hZTA==,size_16,color_FFFFFF,t_70 \"效果图\")\n <!--more-->\n## 首先导入flutter_swiper插件：\n```\ndependencies:\n  flutter_swiper: ^1.1.6\n```\n[配置文件的链接地址](https://pub.dartlang.org/packages/flutter_swiper#-installing-tab-)\n## 使用swiper插件\n需要在使用的dart页面添加：\n```\nimport 'package:flutter_swiper/flutter_swiper.dart';\n```\n然后才能在页面中使用轮播插件：\n```\nbody:  new Swiper(\n        itemBuilder: (BuildContext context,int index){\n          return new Image.network(\"http://via.placeholder.com/350x150\",fit: BoxFit.fill,);\n        },\n        itemCount: 3,\n        pagination: new SwiperPagination(),\n        control: new SwiperControl(),\n      ),\n    );\n ```\n ","tags":["Flutter"],"categories":["Flutter"]},{"title":"图片加水印","url":"/2019/03/05/图片加水印/","content":"# 我尝试了两种实现水印的方式\n## 1、[一个轻量级是我文字和图片水印框架](https://github.com/MarkCHYL/MarkImage_Watermark)\n## 2、[通过Canvas绘制水印](https://github.com/MarkCHYL/MarkBingCheng)\n\n#### 轻量级的我就不做笔记了，因为很简单就能实现你想要的水印，留意内存溢出就好。\n <!--more-->\n下面主要记录下第二种方式加水印。\n效果图如下：\n![\"扫码前\"](https://note.youdao.com/yws/api/personal/file/WEBdb77376deaca765aa7a3e6edb0356506?method=download&shareKey=562be4884a22b72841f3ecd26d15c5c2 \"扫码前\")\n\n![拍照后](https://note.youdao.com/yws/api/personal/file/WEB88deb0577afd1cc96101d6982ecc978d?method=download&shareKey=3f220832549b9ac09e08d302731a8dc3 \"拍照后\")\n\n### 正文\n \n```\n   //打开相机\n    openCamera(this);\n   /**\n     * 打开相机\n     */\n    private void openCamera(Activity activity) {\n        //獲取系統版本\n        int currentapiVersion = android.os.Build.VERSION.SDK_INT;\n        if (tvResult.getText().toString().length() > 0) {\n            //执行拍照前，应该先判断SD卡是否存在\n            String SDState = Environment.getExternalStorageState();\n            Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//\"android.media.action.IMAGE_CAPTURE\"\n            if (SDState.equals(Environment.MEDIA_MOUNTED)) {\n\n                File file = new File(FileUtil.getInstance().getImageFile( tvResult.getText().toString()));\n                if (!file.exists()) {\n                    file.mkdirs();\n                }\n                // 从文件中创建uri\n                imageUri = Uri.fromFile(file);\n                if (currentapiVersion < 24) {\n                    intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);\n                    intent.putExtra(FILE_PATH, file.getAbsoluteFile());\n                } else {\n                    //兼容android7.0 使用共享文件的形式\n                    ContentValues contentValues = new ContentValues(1);\n                    contentValues.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());\n                    imageUri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues);\n                    intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);\n                }\n                startActivityForResult(intent, TAKE_PICTURE);\n                Log.d(\"tag\", \"filepath = \" + file.getAbsoluteFile());\n\n            } else {\n                Toast.makeText(this, getString(R.string.no_sd_card), Toast.LENGTH_LONG).show();\n            }\n\n        } else {\n\n            Toast.makeText(this, \"请先进行扫描或输入条形码\", Toast.LENGTH_SHORT).show();\n        }\n\n    }\n```\n有人会说打开相机需要这么繁琐的代码吗？其实不需要，只是我的业务需要获取图片的路径，安卓碎片重，高版本的注重用户隐私的保护，相片就是用户隐私，所以需要区别对待。\n\n获取图片路径：\n\n```\n /**\n     * 选择图片后，获取图片的路径\n     *\n     * @param requestCode\n     * @param data\n     */\n    private void doPhoto(int requestCode, Intent data) {\n\n        /**\n         * 获取到的图片路径\n         */\n        String picPath = null;\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");// HH:mm:ss\n        // 获取当前时间\n        Date date = new Date(System.currentTimeMillis());\n        String dateStr = simpleDateFormat.format(date).toString();\n\n        if (requestCode == TAKE_PICTURE) {\n            String[] pojo = {MediaStore.Images.Media.DATA};\n            Cursor cursor = getContentResolver().query(imageUri, pojo, null, null, null);\n            if (cursor != null) {\n                int columnIndex = cursor.getColumnIndexOrThrow(pojo[0]);\n                cursor.moveToFirst();\n                picPath = cursor.getString(columnIndex);\n                cursor.close();\n            } else {   //小米4上取不到图片路径\n                try {\n                    String[] strPaths = imageUri.toString().split(\"//\");\n                    picPath = strPaths[1];\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (picPath != null && (picPath.toLowerCase().endsWith(\".png\") || picPath.toLowerCase().endsWith(\".jpg\"))) {\n                if (picPath == null || picPath.equals(\"\")) {\n                    Toast.makeText(this, \"请重新拍照\", Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                Toast.makeText(this, \"pic = \" + picPath, Toast.LENGTH_SHORT).show();\n                Bitmap bm = null;\n                try {\n                    bm = FileUtil.getInstance().getImage(picPath, btnOpenCamera.getWidth(), btnOpenCamera.getHeight()); //获取限定宽高的bitmap，不限定则容易占用内存过大及OOM\n                    if (bm == null) {\n                        Toast.makeText(this, \"请重新拍照\", Toast.LENGTH_SHORT).show();\n                    } else {\n                        if (addWatermarkBitmap(bm, dateStr, btnOpenCamera.getWidth(), btnOpenCamera.getHeight())) {\n                            Toast.makeText(this, \"水印生成成功，文件已保存在 \" + FileUtil.getInstance().IMAGE_PATH, Toast.LENGTH_SHORT).show();\n                        }\n                    }\n                } catch (OutOfMemoryError e) {\n                    e.printStackTrace();\n                    if (bm != null) {\n                        bm.recycle();\n                    }\n                    System.gc();\n                }\n            } else {\n                Toast.makeText(this, \"请重新拍照\", Toast.LENGTH_LONG).show();\n            }\n\n        }\n    }\n```\n\n然后调用加水印并保存\n\n```\n private boolean addWatermarkBitmap(Bitmap bitmap, String str, int w, int h) {\n        int destWidth = w;   //此处的bitmap已经限定好宽高\n        int destHeight = h;\n        Log.v(\"tag\", \"width = \" + destWidth + \" height = \" + destHeight);\n\n        Bitmap icon = Bitmap.createBitmap(destWidth, destHeight, Bitmap.Config.ARGB_8888); //定好宽高的全彩bitmap\n        Canvas canvas = new Canvas(icon);//初始化画布绘制的图像到icon上\n\n        Paint photoPaint = new Paint(); //建立画笔\n        photoPaint.setDither(true); //获取跟清晰的图像采样\n        photoPaint.setFilterBitmap(true);//过滤一些\n\n        Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());//创建一个指定的新矩形的坐标\n        Rect dst = new Rect(0, 0, destWidth, destHeight);//创建一个指定的新矩形的坐标\n        canvas.drawBitmap(bitmap, src, dst, photoPaint);//将photo 缩放或则扩大到 dst使用的填充区photoPaint\n\n        Paint textPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);//设置画笔\n        textPaint.setTextSize(destWidth / 20);//字体大小\n        textPaint.setTextAlign(Paint.Align.CENTER);\n        textPaint.setTypeface(Typeface.DEFAULT_BOLD);//采用默认的宽度\n        textPaint.setAntiAlias(true);  //抗锯齿\n        textPaint.setStrokeWidth(1);\n        textPaint.setAlpha(30);\n//        textPaint.setStyle(Paint.Style.STROKE); //空心\n        textPaint.setColor(Color.WHITE);//采用的颜色\n//        textPaint.setShadowLayer(1f, 0f, 3f, Color.LTGRAY);\n//        textPaint.setShadowLayer(3f, 1, 1,getResources().getColor(android.R.color.white));//影音的设置\n        canvas.drawText(str, destWidth / 2, destHeight - 45, textPaint);//绘制上去字，开始未知x,y采用那只笔绘制\n//        canvas.save(Canvas.ALL_SAVE_FLAG);\n        canvas.save();\n        canvas.restore();\n        bitmap.recycle();\n        btnOpenCamera.setImageBitmap(icon);\n        return FileUtil.getInstance().saveMyBitmap(icon, tvResult.getText().toString()); //保存至文件\n//        return true;\n    }\n\n```\n\n\n我在这个重点是实现功能。over，完成。返回显示不难，难在难在加水印，然后保存，代码中也可以看出，添加的水印是自己在控件上方画中来的，然后更具控件的大小新生成一张图保存。主要是其中的一句话：\n\n```\n  Rect src = new Rect(0, 0, bitmap.getWidth(),    bitmap.getHeight());//创建一个指定的新矩形的坐标\n  Rect dst = new Rect(0, 0, destWidth, destHeight);//创建一个指定的新矩形的坐标\n  canvas.drawBitmap(bitmap, src, dst, photoPaint);//将photo 缩放或则扩大到 dst使用的填充区photoPaint\n\n```\n那样先拍照的图片就在Canvas上面了，然后通过画笔Paint 在上面写字，保存图片：\n```\n   Bitmap icon = Bitmap.createBitmap(destWidth, destHeight, Bitmap.Config.ARGB_8888); //定好宽高的全彩bitmap\n   Canvas canvas = new Canvas(icon);//初始化画布绘制的图像到icon上\n        \n```\n\n\n\n\n","tags":["Android"],"categories":["Android"]},{"title":"Mark的架构学习笔记— Android_MVP(二)","url":"/2019/01/25/Mark的架构学习笔记—-Android-MVP-二/","content":"### 前言\n之前我写的一个笔记，没有结合网络请求，现在我想记录下我这次结合网络请求Retrofit的MVP编程。\n我上一篇的笔记：[马克的架构学习笔记— Android_MVP](https://markchyl.github.io/2018/12/17/Mark%E7%9A%84%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Android-MVP/),代码笔记中有链接。\n\n根据慕课网上的学习的代码链接：[根据手机号查询号码信息](https://github.com/MarkCHYL/MarkTellNumInfo_mvp)\n\n这篇笔记我不贴代码，制作个笔记记录，项目代码不能外泄。\n<!--more-->\n### 老话重提，啥事MVP模式？\n这个问题是真的很重要，MVP就是一个编程思想，让代码具有层次感，逻辑鲜明。\n\n在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，即重用！ 不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试--而不需要使用自动化的测试工具。\n\n* ### 优点\n  * 模型与视图完全分离，我们可以修改视图而不影响模型\n  * 可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部\n  * 我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。\n  * 如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）\n  *  (1)降低耦合度\n\n     (2)模块职责划分明显\n\n     (3)利于测试驱动开发\n\n     (4)代码复用\n\n     (5)隐藏数据\n\n     (6)代码灵活性\n     \n     \n* ### 缺点\n  由于对视图的渲染放在了Presenter中,所以视图和Presenter的交互会过于频繁。还有一点需要明白,如果Presenter过多地渲染了视图,往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更,那么Presenter也需要变更了\n\n### 大白话\n* View层就是用于自己显示的，你需要什么样的显示接口，就可以在View层中定义。\n* Presenter层就是协调View和Model层的，可以将网络请求和接 main 显示的方法调用放在P层，然后调用model层的方法，我这一般就是保存数据和获取数据。\n* model其实就是数据管理类\n\n![image](https://note.youdao.com/yws/api/personal/file/WEB3a6a0577e5958e93f8a25e14eade5b77?method=download&shareKey=f7d60e8b528af13a443d9b56d1d4a6ab)","tags":["Android","架构"],"categories":["Android"]},{"title":"占位符 Broccoli 的使用","url":"/2019/01/18/占位符-Broccoli-的使用/","content":"![Broccoli](https://github.com/samlss/Broccoli/raw/master/screenshots/Broccoli.png)\n\n在预加载时显示view的占位符效果\n\n### 截图\n#### 默认效果:\n\n![Broccoli](https://github.com/samlss/Broccoli/raw/master/screenshots/screenshot1.gif)\n\n <!--more-->\n#### 自定义动画效果:\n![Broccoli](https://github.com/samlss/Broccoli/raw/master/screenshots/screenshot2.gif)\n\n#### 在RecyclerView使用\n![Broccoli](https://github.com/samlss/Broccoli/raw/master/screenshots/screenshot3.gif)\n\n\n#### 钉钉考勤\n![Broccoli](https://github.com/samlss/Broccoli/raw/master/screenshots/screenshot4.png) \n\n![Broccoli](https://github.com/samlss/Broccoli/raw/master/screenshots/screenshot5.png)\n------\n### 依赖\n\n#### Gradle\n将其添加到你的module的build.gradle中： \n\n  ```java\n  dependencies {\n      implementation 'me.samlss:broccoli:1.0.0'\n  }\n  ```\n\n#### Maven\n```java\n<dependency>\n  <groupId>me.samlss</groupId>\n  <artifactId>broccoli</artifactId>\n  <version>1.0.0</version>\n  <type>pom</type>\n</dependency>\n```\n\n### 代码使用\n\n```java\nBroccoli broccoli = new Broccoli();\n\n//添加默认的占位符\nbroccoli.addPlaceholders('activity', 'view_id', 'view_id'); \n\nor \n//添加默认的占位符\nbroccoli.addPlaceholders('view1', 'view2', 'view3'); \n\nor \n\n//添加自定义的占位符\nbroccoli.addPlaceholder(new PlaceholderParameter.Builder()\n                        .setView('view')\n                        .setAnimation('scaleAnimation');\n                        .setDrawable(DrawableUtils.createRectangleDrawable(placeHolderColor, 0))\n                        .build()); \n\nor\n//添加带渐变动画的占位符\nbroccoli.addPlaceholder(new PlaceholderParameter.Builder()\n                        .setView('view')\n                        .setDrawable(new BroccoliGradientDrawable(Color.parseColor(\"#DDDDDD\"),\n                            Color.parseColor(\"#CCCCCC\"), 0, 1000, new LinearInterpolator())\n                        .build()); \nbroccoli.show();\n```\n\n[源码demo地址](https://github.com/MarkCHYL/Mark_Broccoli_demo)","tags":["Android","自定义控件"],"categories":["Android"]},{"title":"Markdown 入门指南一","url":"/2019/01/04/Markdown-入门指南一/","content":"### **一、Markdown 是什么？**\n***\nMarkdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。\n<!--more-->\n另外，印象笔记 Markdown 支持 CommonMark 和 GFM (GitHub Flavored Markdown) 标准。\n\n\n### **二、印象笔记里 Markdown 有什么特点？** \n***\n* **一键创建**：支持 Markdown 独立的一键新建入口，为深度 Markdown 用户提供更好的效率体验；\n* **支持丰富的主流 Markdown 语法**：支持文字相关样式、序号列表、任务列表、表格、TOC 目录、多种图表、数学公式、流程图、时序图、甘特图等；\n* **支持插入图片**：可插入网络图片 或 直接拖动本地图片、复制剪贴板中的图片到 Markdown 笔记中；\n* **支持多种模式切换**：编辑与预览模式、纯编辑模式以及纯预览模式；\n* **支持多种编辑主题**：预置了白色、黑色、深空灰和印象绿主题，默认为印象绿，未来会有更多主题提供；\n* **跨平台同步**：创建的 Markdown 笔记可在登录了印象笔记帐户的各端查看，未来更多端会支持创建和编辑 Markdown 笔记；\n演示模式：Markdown 笔记支持演示模式查看；\n* **支持其他印象笔记特点功能**：笔记标注、导出 PDF、设置提醒、工作群聊共享-查看&amp;编辑笔记等。\n![](https://list.yinxiang.com/media/images/6f6fbdf5d5880bba878cccdb6fde7dc2.png)\n### **三、如何创建 Markdown 笔记？**\n***\n1. 点击左上角「新建 Markdown 笔记」来创建新的 Markdown 笔记，另外，也支持配置隐藏「新建 Markdown 笔记」按钮，Windows 用户直接右单击「新建 Markdown 笔记」按钮，即可隐藏，Mac 用户可以右单击左侧边栏空白处，取消勾选「新建 Markdown 笔记」来完成隐藏此按钮\n2. 点击菜单栏-文件-新建笔记-新建 Markdown 笔记（Mac 上为顶部菜单栏-文件-新建 Markdown笔记）\n3. 使用快捷键 Ctrl+alt+D（Mac 上 CMD+D）来快速创建 Markdown 笔记\n### **四、印象笔记 Markdown 笔记支持哪些语法？**\n***\n—— 以下语法均支持在编辑工具栏直接操作 —— \n#### 1. 设置分级标题语法示例：\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n![](https://list.yinxiang.com/media/images/4d01db13595e47a605bdcee58863bcc9.png)\n***\n#### 2. 加粗文本\n语法示例：\n```\n**印象笔记**\n```\n![](https://list.yinxiang.com/media/images/c6bdf4f7243a65e9d265f8354a985133.png)\n***\n#### 3. 斜体\n语法示例：\n```\n*印象笔记*\n```\n![](https://list.yinxiang.com/media/images/013f1b9f886759dd2881a90594505be7.png)\n***\n#### 4. 下划线\n语法示例：\n\n&lt;u&gt;印象笔记&lt;/u&gt;\n\n![](https://list.yinxiang.com/media/images/e9dfb2393770d6b3f9797251828fc64a.png)\n***\n#### 5. 删除线\n语法示例：\n```\n~~印象笔记不支持Markdown~~\n```\n![](https://list.yinxiang.com/media/images/801daebf96b7c608324f653b8919d20b.png)\n***\n#### 6. 添加分隔线\n语法示例：\n```\n* * *\n```\n![](https://list.yinxiang.com/media/images/17e2f842833974e024ddbfe8601db88a.png)\n***\n#### 7. 引用文本语法示例：\n```\n>近日，印象笔记宣布完成重组。作为Evernote已在中国独立运营近6年的品牌，印象笔记将成为由中方控股的中美合资独立运营实体，并获得红杉宽带跨境数字产业基金首轮数亿元人民币投资。\n```\n![](https://list.yinxiang.com/media/images/5e7bc153735b23aa620131c3b53c4bbe.png)\n***\n#### 8. 添加符号列表或者数字列表\n语法示例：\n```\n使用 iOS 版本印象笔记如何快速保存内容？\n1. 启用印象笔记 Widget ——印象笔记·剪贴板\n2. 复制粘贴任意内容     \n      * 微信\n3. 滑动到 Widget 插件区域即可完成保存\n印象笔记·剪贴板有什么特点？\n* 快：开启自动模式，可以自动保存剪贴板的任意内容\n* 一切：只要可以复制粘贴就可以保存\n* 有序：全部保存在「我的剪贴板」笔记本并以时间来命名\n```\n![](https://list.yinxiang.com/media/images/50ffb8685cde14d6f94ba56d048eb484.png)\n***\n#### 9. 添加待办事项\n语法示例：\n```\n三只青蛙\n* [x] 第一只青蛙\n* [ ] 第二只青蛙\n* [ ] 第三只青蛙\n```\n![](https://list.yinxiang.com/media/images/aeec9223706ba3fc5ff64649a1026b4a.png)\n***\n#### 10. 插入链接\n语法示例：\n```\n[印象笔记官网](https://www.yinxiang.com/)\n```\n![](https://list.yinxiang.com/media/images/262a54f32549f26feb2a8ca094ebd7e2.png)\n***\n#### 11. 插入图片\n印象笔记支持嵌入网络图片或者直接拖入本地图片，其中本地图片格式支持 jpg、png 和 gif。\n语法示例：\n```\n![image](https://www.yinxiang.com/blog/wp-content/uploads/2018/07/%E5%94%AE%E7%A5%A8%E5%BE%AE%E4%BF%A1%E5%B0%81%E9%9D%A22.png)\n```\n![image](https://www.yinxiang.com/blog/wp-content/uploads/2018/07/%E5%94%AE%E7%A5%A8%E5%BE%AE%E4%BF%A1%E5%B0%81%E9%9D%A22.png)\n\n另外，针对插入的本地图片可以控制图片大小，在拖拽、拷贝或者点击插入本地图片之后，直接在图片名称后面（无需空格）添加以下语法均可以按照以下要求控制图片大小：\n@w=300\n@h=150\n@w=200h=100\n@h=100w=200\n示例笔记\n782d277a1dbc7dea8480267cf5f87ebd.png@w=300\n![](https://list.yinxiang.com/media/images/fb2dde021cec7c807b177af6956664b6.png)\n***\n#### 12. 插入表格\n语法示例：\n```\n| 帐户类型 | 免费帐户 | 标准帐户 | 高级帐户 |\n| --- | --- | --- | --- |\n| 帐户流量 | 60M | 1GB | 10GB |\n| 设备数目 | 2台 | 无限制 | 无限制 |\n| 当前价格 | 免费 | ￥8.17/月 | ￥12.33/月| \n```\n![](https://list.yinxiang.com/media/images/42bec0bb39317b0a5d7cbf799a079c11.png)\n***\n#### 13. 插入图表\n目前支持饼状图、折线图、柱状图和条形图，只需将 type 改为对应的pie、line、column 和 bar。\n \n```\n```chart\n,预算,收入,花费,债务\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: 每月收益\nx.title: Amount\ny.title: Month\ny.suffix: $```\n```\n![](https://list.yinxiang.com/media/images/8e02032f85f6612a4c2bb85797251f23.png)\n***\n#### 14. 插入行内代码或代码块\n印象笔记 Markdown 语法支持几十种编程语言的高亮的显示。\n语法示例：\n```\npython\n#!/usr/bin/python\nimport re\n\nline = \"Cats are smarter than dogs\"\n\nmatchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)\n\nif matchObj:   \n    print \"matchObj.group() : \", matchObj.group()    \n    print \"matchObj.group(1) : \", matchObj.group(1)    \n    print \"matchObj.group(2) : \", matchObj.group(2)\nelse:    \n    print \"No match!!\"\n```\n***\n#### 15. 插入数学公式印象笔记 Markdown 支持绝大多数的 LaTeX 数学公式\n语法示例：\n```\nmathe^{i\\pi} + 1 = 0\n```\n更多数学公式的输入可以参考：https://khan.github.io/KaTeX/docs/supported.html\n![](https://list.yinxiang.com/media/images/c93e418911efa9fef085f5cf5fef5ccb.png)\n***\n#### 16. 插入流程图\n语法示例：\n```\nmermaid\ngraph TD\nA[模块A] -->;|A1| B(模块B)\nB -->; C{判断条件C}\nC -->;|条件C1|D[模块D]\nC -->;|条件C2|E[模块E]\nC -->;|条件C3|F[模块F]\n```\n![](https://list.yinxiang.com/media/images/3f18e5911a3342af4871115ba519f544.png)\n***\n#### 17.  插入时序图\n语法示例：\n```\nmermaid\nsequenceDiagram\nA->>B: 是否已收到消息？B-->>A: 已收到消息\n```\n![](https://list.yinxiang.com/media/images/c54a131fbcbc0167c0a2ffa6e1c53a9b.png)\n***\n#### 18. 插入甘特图语法示例：\n```\nmermaid\ngantt\ntitle甘特图\ndateFormat YYYY-MM-DD\nsection 项目A\n任务1 :a1, 2018-06-06, 30d\n任务2 :after a1 , 20d\nsection 项目B\n任务3 :2018-06-12 , 12d\n任务4 : 24d\n```\n![](https://list.yinxiang.com/media/images/cb24dc3b1004d6f07119e60fcb86f5a8.png)\n***\n#### 19. 设置目录\n设置之后可以自动根据设置的分级标题来自动生成目录。\n语法示例[TOC]：\n\n---\n[[TOC]]\n\n![](https://list.yinxiang.com/media/images/3caad079bbafbb2f7ba3dbd59fbdc057.png)\n \n","tags":["工具使用"],"categories":["工具使用"]},{"title":"Python基础学习","url":"/2018/12/29/Python基础学习/","content":"### Python3的基础练习代码\n\n[这是Python基础练习的代码](https://github.com/MarkPythonWorld/MarkPython)","tags":["Python"],"categories":["Python"]},{"title":"环信easeUI的集成","url":"/2018/12/19/环信easeUI的集成/","content":"关于环信easeUI的集成\n环信的集成，网上有许多的demo，看的每个人有点眼花缭乱，对于官方的文档的吐槽也有许多，确实在集成第三方的那些玩意时，不管怎样我们必须先得看看她们的官方介绍。前段时我遇到的项目需要集成环信的聊天功能，一个会话列表和聊天界面，网上搜了很多，由于版本不一样后来还是选择结合官方的demo和开发文档写了个demo。\n我们建议先看一下环信的官方文档，地址：\n点击打开链接\n<!--more-->\n至于基础的集成和导入SDK我在这就不造次啦！环信官方上的文档介绍的很好，看不懂的可以看上面的视频介绍；\n下面我直接说说我的步骤，后面也会贴上源码的地址，望大家不嫌弃，喜欢就给个 start\n\n\n一、首先是初始化环信easeui：\n\n\n  /**\n     * 初始化环信SDK\n     */\n    private void initEasemob() {\n\n        if (EaseUI.getInstance().init(mContext, initOptions())) {\n\n            // 设置开启debug模式\n            EMClient.getInstance().setDebugMode(true);\n\n            // 设置初始化已经完成\n            isInit = true;\n        }\n    }\n\n关于sdk的一些配置初始化，请看demo源码\n\n\n\n\n\n二、登陆和注册的：\n\n登陆：\n\n\n\n /**\n     * 登录方法\n     */\n    private void signIn() {\n        final String username = mUsernameEdit.getText().toString().trim();\n        final String password = mPasswordEdit.getText().toString().trim();\n        if (TextUtils.isEmpty(username) || TextUtils.isEmpty(password)) {\n            Toast.makeText(LoginRegisterActivity.this, \"用户名和密码不能为空\", Toast.LENGTH_LONG).show();\n            return;\n        }\n        EMClient.getInstance().login(username, password, new EMCallBack() {\n            /**\n             * 登陆成功的回调\n             */\n            @Override\n            public void onSuccess() {\n                mDialog.dismiss();\n                Message msg=new Message();\n                msg.what=2;\n                mHandler.sendMessage(msg);\n                // 加载所有会话到内存\n                EMClient.getInstance().chatManager().loadAllConversations();\n                // 登录成功跳转界面\n                Intent intent = new Intent(LoginRegisterActivity.this, MainActivity.class);\n                intent.putExtra(\"userName\",username);\n                startActivity(intent);\n                finish();\n            }\n\n            /**\n             * 登陆错误的回调\n             * @param i\n             * @param s\n             */\n            @Override\n            public void onError(final int i, final String s) {\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        mDialog.dismiss();\n                        Log.d(\"lzan13\", \"登录失败 Error code:\" + i + \", message:\" + s);\n                        /**\n                         * 关于错误码可以参考官方api详细说明\n                         * http://www.easemob.com/apidoc/android/chat3.0/classcom_1_1hyphenate_1_1_e_m_error.html\n                         */\n                        switch (i) {\n                        // 网络异常 2\n                        case EMError.NETWORK_ERROR:\n                            Toast.makeText(LoginRegisterActivity.this, \"网络错误 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 无效的用户名 101\n                        case EMError.INVALID_USER_NAME:\n                            Toast.makeText(LoginRegisterActivity.this, \"无效的用户名 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 无效的密码 102\n                        case EMError.INVALID_PASSWORD:\n                            Toast.makeText(LoginRegisterActivity.this, \"无效的密码 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 用户认证失败，用户名或密码错误 202\n                        case EMError.USER_AUTHENTICATION_FAILED:\n                            Toast.makeText(LoginRegisterActivity.this, \"用户认证失败，用户名或密码错误 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 用户不存在 204\n                        case EMError.USER_NOT_FOUND:\n                            Toast.makeText(LoginRegisterActivity.this, \"用户不存在 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 无法访问到服务器 300\n                        case EMError.SERVER_NOT_REACHABLE:\n                            Toast.makeText(LoginRegisterActivity.this, \"无法访问到服务器 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 等待服务器响应超时 301\n                        case EMError.SERVER_TIMEOUT:\n                            Toast.makeText(LoginRegisterActivity.this, \"等待服务器响应超时 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 服务器繁忙 302\n                        case EMError.SERVER_BUSY:\n                            Toast.makeText(LoginRegisterActivity.this, \"服务器繁忙 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        // 未知 Server 异常 303 一般断网会出现这个错误\n                        case EMError.SERVER_UNKNOWN_ERROR:\n                            Toast.makeText(LoginRegisterActivity.this, \"未知的服务器异常 code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        default:\n                            Toast.makeText(LoginRegisterActivity.this, \"ml_sign_in_failed code: \" + i + \", message:\" + s, Toast.LENGTH_LONG).show();\n                            break;\n                        }\n                    }\n                });\n            }\n\n            @Override\n            public void onProgress(int i, String s) {\n                mDialog.show(LoginRegisterActivity.this,\"登录\", \"正在登录中\");\n            }\n        });\n    }\n\n\n\n\n\n\n\n注册：\n\n\n\nprivate void signUp() {\n    // 注册是耗时过程，所以要显示一个dialog来提示下用户\n    mDialog.setMessage(\"注册中，请稍后...\");\n    mDialog.show();\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                String username = mUsernameEdit.getText().toString().trim();\n                String password = mPasswordEdit.getText().toString().trim();\n                EMClient.getInstance().createAccount(username, password);\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (!LoginRegisterActivity.this.isFinishing()) {\n                            mDialog.dismiss();\n                        }\n                        Toast.makeText(LoginRegisterActivity.this, \"注册成功\", Toast.LENGTH_LONG).show();\n                    }\n                });\n            } catch (final HyphenateException e) {\n                e.printStackTrace();\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (!LoginRegisterActivity.this.isFinishing()) {\n                            mDialog.dismiss();\n                        }\n                        /**\n                         * 关于错误码可以参考官方api详细说明\n                         * http://www.easemob.com/apidoc/android/chat3.0/classcom_1_1hyphenate_1_1_e_m_error.html\n                         */\n                        int errorCode = e.getErrorCode();\n                        String message = e.getMessage();\n                        Log.d(\"lzan13\", String.format(\"sign up - errorCode:%d, errorMsg:%s\", errorCode, e.getMessage()));\n                        switch (errorCode) {\n                        // 网络错误\n                        case EMError.NETWORK_ERROR:\n                            Toast.makeText(LoginRegisterActivity.this, \"网络错误 code: \" + errorCode + \", message:\" + message, Toast.LENGTH_LONG).show();\n                            break;\n                        // 用户已存在\n                        case EMError.USER_ALREADY_EXIST:\n                            Toast.makeText(LoginRegisterActivity.this, \"用户已存在 code: \" + errorCode + \", message:\" + message, Toast.LENGTH_LONG).show();\n                            break;\n                        // 参数不合法，一般情况是username 使用了uuid导致，不能使用uuid注册\n                        case EMError.USER_ILLEGAL_ARGUMENT:\n                            Toast.makeText(LoginRegisterActivity.this, \"参数不合法，一般情况是username 使用了uuid导致，不能使用uuid注册 code: \" + errorCode + \", message:\" + message, Toast.LENGTH_LONG).show();\n                            break;\n                        // 服务器未知错误\n                        case EMError.SERVER_UNKNOWN_ERROR:\n                            Toast.makeText(LoginRegisterActivity.this, \"服务器未知错误 code: \" + errorCode + \", message:\" + message, Toast.LENGTH_LONG).show();\n                            break;\n                        case EMError.USER_REG_FAILED:\n                            Toast.makeText(LoginRegisterActivity.this, \"账户注册失败 code: \" + errorCode + \", message:\" + message, Toast.LENGTH_LONG).show();\n                            break;\n                        default:\n                            Toast.makeText(LoginRegisterActivity.this, \"ml_sign_up_failed code: \" + errorCode + \", message:\" + message, Toast.LENGTH_LONG).show();\n                            break;\n                        }\n                    }\n                });\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }).start();\n}\n\n三、ChatActivity聊天界面。 我用的原生\n\n\n\n\n\n   // 这里直接使用EaseUI封装好的聊天界面\n        chatFragment = new ChatFragment();\n        // 将参数传递给聊天界面\n        chatFragment.setArguments(getIntent().getExtras());\n        getSupportFragmentManager().beginTransaction().add(R.id.layout_chat, chatFragment).commit();\n\n四、会话列表\n\n\n\n\n\n\n   //直接用环信的会话列表\n        conversationListFragment = new EaseConversationListFragment();\n        conversationListFragment.setArguments(getIntent().getExtras());\n        conversationListFragment.setConversationListItemClickListener(\n                new EaseConversationListFragment.EaseConversationListItemClickListener() {\n                    @Override\n                    public void onListItemClicked(EMConversation conversation) {\n                        startActivity(new Intent(ConversationListActivity.this, ChatActivity.class)\n                                .putExtra(EaseConstant.EXTRA_USER_ID, conversation.conversationId()));\n                    }\n\n                });\n        getSupportFragmentManager().beginTransaction().add(R.id.ec_layout_list, conversationListFragment).commit();\n\n第一次写博客 ，还望兄弟们没嫌弃，我在源码中的注释很详细\nDemo源码链接\n","tags":["Android","第三方集成"],"categories":["Android"]},{"title":"自定义日历控件","url":"/2018/12/19/自定义日历控件/","content":"### 这里主要记录下控件自定义的步骤\n![](../assests/img/MarkCalendar.jpg)\n<!--more-->\n### 一、自定义控价大致分类：\n·集成系统控件\n·组合系统控件\n·自定义绘制控件\n### 二、添加Attribute\n在res/value下新建attrs.xml文件，自定义需要声明的属性：\n```\n <declare-styleable name=\"MarkCalendar\">\n        <attr name=\"dateFormat\" format=\"string\"/>\n    </declare-styleable>\n```\n然后在自定义控件中，初始化的时候进行声明：\n```\n//声明自定义属性\nTypedArray ta = getContext().obtainStyledAttributes(attrs, R.styleable.MarkCalendar);\n        try {\n            String format = ta.getString(R.styleable.MarkCalendar_dateFormat);\n            disPlayFormat = format;\n            if (disPlayFormat == null) {\n                disPlayFormat = \"MMM yyyy\";\n            }\n\n        } finally {\n            ta.recycle();\n        }\n```\n记住声明完后一定要回收  ta.recycle()。\n\n### 三、添加事件\n```\n   /**\n     * 添加点击事件\n     */\n    public interface MarkClendarListener{\n        void onItemLongPress(Date day);\n    }\n```\n然后初始化调用： \n```\npublic MarkClendarListener markClendarListener;\n\n\ngvDays.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {\n            @Override\n            public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {\n                if (markClendarListener == null) {\n                    return false;\n                }else {\n                    markClendarListener.onItemLongPress((Date) parent.getItemAtPosition(position));\n                    return true;\n                }\n            }\n        });\n```\n最后activity中调用：\n实现MarkClendarListener接口，并实现其方法。\n```\n     MarkCalendar markcalendar = findViewById(R.id.markcalendar);\n        markcalendar.markClendarListener = this;\n    }\n\n    @Override\n    public void onItemLongPress(Date day) {\n        DateFormat df = SimpleDateFormat.getDateInstance();\n        Toast.makeText(this,df.format(day),Toast.LENGTH_SHORT).show();\n    }\n```\n### \b[Demo\b链接](https://github.com/MarkCHYL/MarkCustomCalendar)","tags":["Android","自定义控件"],"categories":["Android"]},{"title":"Mark的架构学习笔记---Android_MVP","url":"/2018/12/17/Mark的架构学习笔记-Android-MVP/","content":"# 前言：\n   我是名安卓程序员。当我第一次接触到架构这个概念时，说实话我一头雾水。我现实了解了MVC模式，当我开始接触MVP模式时，我啊真的彻底被搞懵了！怎么把一个activity拆成了四个或五者，如果分装过后会更多，想象下，一下子猛的看那么复杂的对我来说无益处。这边文章呢我实现只是一个加你简单单的Demo练习，参考代码和资料来源于网上（备注于文底部）。\n   记录只是让自己加深理解。\n<!--more-->\n![这是我的Demo代码架构](https://user-gold-cdn.xitu.io/2018/7/30/164e8dc7b3e27bb6?w=696&h=812&f=png&s=257193 \"这是我的Demo代码架构\")\n****\n+ ## 跟着大佬学习下MVP模式：\n   MVP是模型（Model）、视图（View）、主持人（Presenter）的缩写，分别代表项目中3个不同的模块。\n\n![](https://user-gold-cdn.xitu.io/2018/7/30/164e9021bf594592?w=728&h=618&f=png&s=38130 \"MVP模式示意图\")\n说明：\n   *   步骤1：UI实现View方法，引用Presenter\n   *   步骤2：Presenter调用Model，走Model具体逻辑\n   *   步骤3：Model逻辑实现，回调Presenter方法\n   *   步骤4：Presenter回调View，即回到UI，回调View方法\n   ***                          \n## 首先我们定义下View层\n   定义接口 **IUserView**\n```\npublic interface IUserView {\n    UserBean getUser();\n    void setUser(UserBean bean);\n}\n```\n  一个是拿到数据，一个是把数据给别人，\n  我们需要让我们的Activity去实现这个接口里面的方法，\n  然后去做一些数据的显示或者获取。 Presenter与View交互是通过接口。所以我们这里需要定义一个IUserView，\n  难点就在于应该有哪些方法，我们看一眼效果图会发现一个是保存，一个是载入，\n  所以我们就创建两个方法，分别是：getUser和setUser；\n  然后再MainActivity中与实现这个View层的接口\n  如图所示：\n  ```\n  public class MainActivity extends AppCompatActivity implements IUserView {\n    private UserPresenter presenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        presenter = new UserPresenter(this);\n        initEvent();\n    }\n    private void initEvent() {\n        findViewById(R.id.btn_load).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                presenter.loadUser();\n            }\n        });\n        findViewById(R.id.btn_save).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                presenter.saveUser();\n            }\n        });\n    }\n    @Override\n    public UserBean getUser() {\n        int id = Integer.valueOf(et_id.getText().toString().trim());\n        String name = et_name.getText().toString().trim();\n        if (name != null) {\n            UserBean bean = new UserBean();\n            bean.setId(id);\n            bean.setName(name);\n            return bean;\n        }\n        return null;\n    }\n    @Override\n    public void setUser(UserBean bean) {\n        if (bean!=null){\n            tv_data_show.setText(bean.toString());\n        }\n    }\n}\n//省略了部分控件的初始化代码\n  ```\n  是不是觉得曾在某个文章中看见过，哈哈哈，自己敲一边你会得到自己的理解。\n***\n## 定义下Model层\n   * 首先我们的更具接口或者你的业务代码去定义自己的实体类 **UserBean**\n   ```\n   public class UserBean {\n    private int id;\n    private String name;\n    \n    ...getter and setter 方法\n    \n    @Override\n    public String toString() {\n        return \"UserBean{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n```\n   * 实体类的接口 IUser\n>这里大家要注意一下，IUser里面主要是接口，首先，我们要想好，在Presenter中要实现哪些逻辑，要用到哪些方法，然后就在这里定义哪些方法。User主要是IUser的实现，返回一些数据，具体返回那些数据，就有大家自己去根据实际情况而定。\n   ```\n   public interface IUser {\n    void savaUserInfo(UserBean user);\n    UserBean loadUserInfo();\n}\n   ```\n   * 实体类的业务实现类 **User**\n>这里主要是实现**IUser**接口里面定义的业务实现方法，你想干啥干就可以在里面自己凿凿\n   ```\n   public class User implements IUser {\n    private UserBean bean;\n    @Override\n    public void savaUserInfo(UserBean user) {\n        this.bean = user;\n    }\n    @Override\n    public UserBean loadUserInfo() {\n        if (bean != null) {\n            return bean;\n        }\n        return null;\n    }\n}\n   ```\n## 定义最重要的Presenter层\n>是连接Activity(在这可以理解为就是View层，因为Activity实现了 **IUserView** 接口)和Model的重要桥梁，所有的业务逻辑都在它里面完成：\n```\npublic class UserPresenter {\n    private IUser user;\n    private IUserView userView;\n    public UserPresenter(IUserView userView) {\n        this.userView = userView;\n        user = new User();\n    }\n    public void saveUser(){\n        user.savaUserInfo(userView.getUser());\n    }\n    public void loadUser(){\n        userView.setUser(user.loadUserInfo());\n    }\n}\n```\n[源码地址](https://github.com/MarkCHYL/Mark_MVP_Sample \"源码地址\")\n\n下一篇我会结合自己封装的retrofit写一个网络请求的demo笔记，加油⛽️\n","tags":["Android","架构"],"categories":["Android"]},{"title":"GreenDao数据库框架的基础学习","url":"/2018/12/17/GreenDao数据库框架的基础学习/","content":"GreenDao很早就想看看了，最近由于业务需求的变化，我就开始学习下简单的增、删、改、查。\n***\n## 资料参考：\n   - 首先这是官网地址：https://github.com/greenrobot/greendao\n   - 参考博客为：https://www.cnblogs.com/wjtaigwh/p/6394288.html\n   - 慕课网上的视频教程（有点老了，个人觉得）\n***\n<!--more-->\n### 一、咱们先来学习下GreenDao的Api属性：\n> **GreenDao是使用ORM（Object RelationShop Mapping）对象关系映射，就是通过GreenDao将数据库和Bean关联起来有以下优点：**\n\n- 存取速度快\n- 支持数据库加密\n- 轻量级\n- 激活实体\n- 支持缓存\n- 代码自动生成\n### 二、代码的接入配置\n -  app项目目录下build文件中添加\n```\napply plugin: 'org.greenrobot.greendao'\nAndroid{\n   //greendao配置\n    greendao{\n       //版本号，升级时可配置\n       schemaVersion 1\n    }\n}\n\ndependencies {\n    implementation 'org.greenrobot:greendao:3.2.2' // add library\n    implementation 'org.greenrobot:greendao-generator:3.2.2'\n}\n\n```\n- 在更目录中build文件中需要添加\n```\ndependencies {\n   classpath 'org.greenrobot:greendao-gradle-plugin:3.2.2'\n}\n```\n#### 预览效果：\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651c88d14c0e067?w=1036&h=1598&f=png&s=492342 \"是不是很丑\")\n\n- ### Bean 对象注释的解释\n```\n@Entity：告诉GreenDao该对象为实体，只有被@Entity注释的Bean类才能被dao类操作\n@Id：对象的Id，使用Long类型作为EntityId，否则会报错。(autoincrement = true)表示主键会自增，如果false就会使用旧值\n@Property：可以自定义字段名，注意外键不能使用该属性\n@NotNull：属性不能为空\n@Transient：使用该注释的属性不会被存入数据库的字段中\n@Unique：该属性值必须在数据库中是唯一值\n@Generated：编译后自动生成的构造函数、方法等的注释，提示构造函数、方法等不能被修改\n```\n- ### 在Application中初始化自己的数据库\n```\n    /**\n     * 配置数据库\n     */\n    private void setupDatabase() {\n        //创建数据库shop.db\n        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this,\"shop.db\",null);\n        //获取可写数据库\n        SQLiteDatabase db = helper.getWritableDatabase();\n        //获取数据库对象\n        DaoMaster daoMaster = new DaoMaster(db);\n        //获取dao对象管理者\n        daoSession = daoMaster.newSession();\n    }\n    public static DaoSession getDaoInstant(){\n        return daoSession;\n    }\n```\n- ### 在使用前我们海的封装一个数据库的操作类，提供简单的Shop对象的增删该查的简单方法\n```\n * 使用GreenDao 实现简单的增删改查，下面是基本方法\n   * 增加单个数据\n * getShopDao().insert(shop);\n * getShopDao().insertOrReplace(shop);\n * 增加多个数据\n * getShopDao().insertInTx(shopList);\n * getShopDao().insertOrReplaceInTx(shopList);\n * 查询全部\n * List< Shop> list = getShopDao().loadAll();\n * List< Shop> list = getShopDao().queryBuilder().list();\n * 查询附加单个条件\n * .where()\n * .whereOr()\n * 查询附加多个条件\n * .where(, , ,)\n * .whereOr(, , ,)\n * 查询附加排序\n * .orderDesc()\n * .orderAsc()\n * 查询限制当页个数\n * .limit()\n * 查询总个数\n * .count()\n * 修改单个数据\n * getShopDao().update(shop);\n * 修改多个数据\n * getShopDao().updateInTx(shopList);\n * 删除单个数据\n * getTABUserDao().delete(user);\n * 删除多个数据\n * getUserDao().deleteInTx(userList);\n * 删除数据ByKey\n * getTABUserDao().deleteByKey();\n```\n*****我的代码和网上大佬的一样，其实就是自己平时封装的工具类！累。。。。。\n那么那么久*****\n\n最后附上自己的练习代码：[Coding](https://coding.net/u/Mark_Chen/p/MarkGreenDaoDemo/git)\n在大佬的基础上学习就是快！！！\n\n大佬的博客为：http://www.cnblogs.com/wjtaigwh/\n\n","tags":["Android","数据库"],"categories":["Android"]},{"title":"Dart的基础知识学习","url":"/2018/12/17/Dart的基础知识学习/","content":"### 简介：\n        Google和其他地方的开发人员使用Dart为iOS，Android和网络创建高质量，关键任务的应用程序。Dart具有针对客户端开发的功能，非常适合移动和Web应用程序。\n        Dart对于许多现有的开发人员来说都很熟悉，这要归功于它不出异的面向对象和语法。如果您已经了解C ++，C＃或Java，那么只需几天就可以使用Dart。\n        Dart编译为ARM和x86代码，因此Dart移动应用程序可以在iOS，Android及更高版本上本机运行。对于Web应用程序，Dart会转换为JavaScript。\n        Dart提供优化的提前编译，以在移动设备和Web上实现可预测的高性能和快速启动。\n\n* * *\n <!--more-->\n### 工具：\n![https://note.youdao.com/yws/api/personal/file/WEB2e99b7c66fa25ec939b46b986618bc0e?method=download&shareKey=6e3cd2073bc556b731b1d3a68a1c6acf](https://note.youdao.com/yws/api/personal/file/WEB2e99b7c66fa25ec939b46b986618bc0e?method=download&shareKey=6e3cd2073bc556b731b1d3a68a1c6acf)\n##### 无需安装就可以验证编译代码运行。 \nDartPad是一种很好的，无需下载的方法来学习Dart语法和试验Dart语言功能。它支持Dart的核心库，但dart：io等VM库除外。[链接](https://dartpad.dartlang.org/)\nIDE和编辑器\n这些常用的IDE存在Dart插件。\n![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1105042996,1878674339&fm=58&bpow=496&bpoh=405)\n Android Studio\n ![3aaf76a25ee53fd2b4c50db1cc857576.svg+xml](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=330314814,3181569317&fm=58&bpow=310&bpoh=270)\n  IntelliJ IDEA （和其他JetBrains IDE）\n  ![](http://cms-bucket.nosdn.127.net/catchpic/9/9a/9aa087361923a8896e8c0f5f6dd22b05.jpg?imageView&thumbnail=550x0)\n   Visual Studio代码\n* * *\n### HelloWorld：\n```\nvoid main() {\n  print('Hello, World!');\n}\n```\n### 默认值\n        未初始化的变量默认值是 null。即使变量是数字 类型默认值也是 null，因为在 Dart 中一切都是对象，数字类型 也不例外\n\n\n\n","tags":["Flutter"],"categories":["Flutter"]},{"title":"Mark的Flutter的安装和环境配置","url":"/2018/12/17/Mark的Flutter的安装和环境配置/","content":"## 前言：\n        我是一名Android原生开发程序员，目前熟练掌握Java语言和kotlin语言去编写安卓。RN出来的时候我没去学习，现在我想赶上Flutter这列火车。\n<!--more-->\n* * *\n\n   ### 我的配置：\n\n*    Mac笔记本\n*    Android Studio 3.2.0 版本\n*    准备了翻墙的软件，貌似没怎么用上\n\n* * *\n\n\n### 第一步：获取Flutter代码\n\n1. 我先选择了一个存储Flutter的文件夹：\n\n    ![56a74cdc0cf7522961022dcd31a0f3ca.png](evernotecid://3DE7A385-FFCA-4630-91A9-F88E73A63AF0/appyinxiangcom/22109192/ENResource/p1)\n名字跟随自己的命名习惯。\n2. 克隆Flutter代码到本地目录：\n两种方式：自己在GitHub 上面把SDK下下来放到文件中，或者通过终端输入：\n```\ngit clone  https://github.com/flutter/flutter.git\n```\n    最后就是一样的配置：open .bash_profile打开添加以下路径：\n```\nexport PATH=本地目录/flutter/bin:$PATH\n```\n        配置完了后，应该可以运行Flutter命令了！可以使用下面命令flutter doctor来检查依赖环境是否正常。如果下载有问题的话，可能是网络受限，如果你没有翻墙软件的话，在终端输入如下两条命令：\n```\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n官方也给出了方法，就是使用国内的镜像节点下载，在运行flutter doctor之前先运行下面两个命令即可。\n![a51a64a974501d1bf53d7f4cd5f82ab2.png](evernotecid://3DE7A385-FFCA-4630-91A9-F88E73A63AF0/appyinxiangcom/22109192/ENResource/p2)\n\n* * *\n### 第二步：配置IOS环境\n我在 App Store下载安装好了Xcode，然后自己安装了Homebrew：\n[Homebrew配置方法地址：](https://brew.sh/)\n接下来我就是执行如下的命令：\nopen -a Simulator -- 测试成功打开模拟器\n\n###### 安装用于将Flutter应用部署到iOS设备的工具\n$ brew update\n$ brew install --HEAD libimobiledevice\n$ brew install ideviceinstaller ios-deploy cocoapods\n$ pod setup\n此处我就是无耻的copy的别人的文章，那位大佬的文章地址：[Flutter轻松入门（一） -- MAC环境搭建](https://www.jianshu.com/p/0b73cc2af65f)\n* * *\n### 第三步：在Android Studio上配置Android开发环境\n插件怎么安装就不废话啦，直接截图，它会自动安装Flutter和Dart语言插件，Dart有时候可能会安装失败，请耐心点，也可以单独搜Dart进行安装。\n![cd5198371c3b49034b3de9a8c41ecf19.png](evernotecid://3DE7A385-FFCA-4630-91A9-F88E73A63AF0/appyinxiangcom/22109192/ENResource/p3)\n### 最后终端运行 Flutter Doctor\n检查Flutter开发环境是否配置完成，我的如下图：\n![586b6df21a8997dcfeb10164a1e39ec4.png](evernotecid://3DE7A385-FFCA-4630-91A9-F88E73A63AF0/appyinxiangcom/22109192/ENResource/p4)\n* * *\n笔记收尾处我还得为微我参考的文章打个广告：[Flutter轻松入门（一） -- MAC环境搭建](https://www.jianshu.com/p/0b73cc2af65f)\n","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"MAC搭建基于RTMP的本地Nginx服务器","url":"/2018/12/17/MAC搭建基于RTMP的本地Nginx服务器/","content":"### MAC搭建基于RTMP的本地Nginx服务器，实现电脑上视频推流。\n# 1、先安装homeView\n<!--more-->\n```\n//安装命令\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n//移除命令\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n# 2、安装Nginx服务器\n### 增加对nginx的扩展;也就是从github上下载,home-brew对ngixnx的扩展\n### homebrew/nginx的git路径变了(貌似是2018年3月更新)\n```\n brew tap homebrew/nginx\n```\n# 3、安装Nginx服务器和rtmp模块\n```\nbrew install nginx-full --with-rtmp-module\n```\n![image](https://upload-images.jianshu.io/upload_images/1027569-1480f7cb0be838e2.png?imageMogr2/auto-orient/)\n\n# 4、查看nginx的信息\n```\nbrew info nginx-full\n```\n### 结果显示\n![](https://upload-images.jianshu.io/upload_images/1027569-da39e4efd3bf35f4.jpeg?imageMogr2/auto-orient/)\n\n```\nnginx的安装位置\n/usr/local/Cellar/nginx-full/1.10.1/bin/nginx\nnginx配置文件所在位置\n/usr/local/etc/nginx/nginx.conf\nnginx服务器根目录所在位置 \n /usr/local/var/www\n```\n#### 在浏览器中输入 [http://localhost:8080 ](http://localhost:8080 )（若是安装成功就会出现如下图所示）\n\n![](https://upload-images.jianshu.io/upload_images/1027569-8f0712d428c40368.png?imageMogr2/auto-orient  \"安装成功\")\n\n# 5、配置rtmp和支持http协议拉流\n#### 在终端中输入\n```\nopen /usr/local/etc/nginx\n```\n#### 打开niginx的文件夹，找到nginx.conf文件,用xcode打开。添加下面配置\n```\n#在http节点下面(也就是文件的尾部)加上rtmp配置：\nrtmp {//协议名称\n   server {//说明内部中是服务器相关配置\n        listen 1992;// 监听的端口号, rtmp协议的默认端口号是1935\n        application Mark {//访问的应用路径是 Mark\n              live on; //开启实时\n              record off;// 不记录数据\n        }\n    }\n}\n\nlocation /hls {\n        #Serve HLS config\n        types {\n            application/vnd.apple.mpegurl    m3u8;\n            video/mp2t ts;\n        }\n        root /usr/local/var/www;\n        add_header Cache-Control    no-cache;\n    }\n```\n#  6、保存文件后，重新加载nginx的配置文件\n```\nnginx -s reload\n```\n#### 配置好的样子如下：\n![](https://upload-images.jianshu.io/upload_images/1027569-3a79f914d42877ae.png?imageMogr2/auto-orient/)\n\n# 7、安装ffmepg工具\n```\nbrew install ffmpeg\n```\n# 8、通过ffmepg命令进行推流测试\n-  ####  推流至RTMP到服务器\n     \n    -  ####   生成地址： rtmp://localhost:1992/Mark/room\n```\nffmpeg -re -i 你的视频文件的绝对路径(如/Users/lideshan/Downloads/test.mp4) -vcodec copy -f flv rtmp://localhost:1992/Mark/room//\n 如：我把测试视频放在桌面\nffmpeg -re -i  /Users/Mark/Desktop/test.mp4 -vcodec copy -f flv rtmp://localhost:1992/Mark/room\n\n```\n#### 这里Mark是上面的配置文件中,配置的应用的路径名称;后面的room可以随便写\n\n-   #### 推流至HLS到服务器\n    - 生成地址: http://localhost:8080/hls/test.m3u8\n    \n```\n    ffmpeg -re -i /Users/apple/Desktop/ffmepg/story.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://localhost:1935/hls/demo\n```","tags":["Android","视频直播"],"categories":["Android"]},{"title":"python的爬虫学习实战笔记一","url":"/2018/12/17/python的爬虫学习实战笔记一/","content":"### 前言：\n#### Python3的爬虫基础学习，编写URL管理器、网页下载器、网页分析器、数据输出器、如何连接到MySQL。网上能搜到许多的库，在这我只是开始我的基础学起，瞎猫死猫能运行就可以。\n---\n<!--more-->\n#### 编写的环境：\nMac电脑、MySQL数据库、pymysql库、urllib库、bs4库、Python3、PyCharm编辑器\n\n[学习网址](http://www.runoob.com/python3/python3-dictionary.html)\n\n### 定义：\n网络爬虫（Web Spider），又被称为网页蜘蛛，是一种按照一定的规则，自动地抓取网站信息的程序或者脚本。\n\n### 简介：\n网络蜘蛛是一个很形象的名字。如果把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。网络蜘蛛是通过网页的链接地址来寻找网页，从 网站某一个页面开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，这样一直循环下去，直到把这个网站所有的网页都抓取完为止\n\n### 爬虫流程：\n```\n①先由urllib的request打开Url得到网页html文档\n——②浏览器打开网页源代码分析元素节点\n——③通过BeautifulSoup或则正则表达式提取想要的数据\n——④存储数据到本地磁盘或数据库（抓取，分析，存储）\n```\n## 上代码\n爬虫程序入口：Spider_Main\n爬虫目标URL：http://www.hbooker.com/book/10007188\n\n```\nfrom hbooker_spider import html_downloader\nfrom hbooker_spider import html_outputer\nfrom hbooker_spider import html_parser\nfrom hbooker_spider import url_manager\n\n\nclass SpiderMain(object):\n    def __init__(self):\n        # 初始化 URL 管理器\n        self.urls = url_manager.UrlManager()\n        # 初始化 html 下载器\n        self.downloader = html_downloader.HtmlDownLoader()\n        # 初始化 html 解析器\n        self.parser = html_parser.HtmlParser()\n        # 初始化 数据 输出管理器\n        self.outputer = html_outputer.HtmlOutputer()\n\n    def craw(self, root_url):\n        count = 1\n        self.urls.add_new_url(root_url)\n        while self.urls.has_new_url():\n            try:\n                new_url = self.urls.get_new_url()\n                html_cont = self.downloader.downloader(new_url)\n                new_urls, new_datas = self.parser.parse(new_url, html_cont)\n                self.urls.add_new_urls(new_urls)\n                print('craw %d : %s' % (count, new_datas))\n                self.outputer.collect_data(new_datas)\n\n                if count == 100:\n                    break\n                count += 1\n            except:\n                print('craw failed')\n        self.outputer.output_html()\n        self.outputer.output_mysql()\n\n\nif __name__ == '__main__':\n    root_url = 'http://www.hbooker.com/book/100071888'\n    obj_spider = SpiderMain()\n    obj_spider.craw(root_url)\n```\n\n### 网页下载器 html_downloader\n\n```\n# URL下载器\nfrom urllib import request\n\n\nclass HtmlDownLoader(object):\n    def downloader(self, new_url):\n        if new_url is None:\n            return\n\n        response = request.urlopen(new_url)\n        if response.getcode() != 200:\n            return None\n        return response.read()\n```\n### 网页解析器 html_parser\n\n```\n# html 解析器\nimport re\nfrom bs4 import BeautifulSoup\n\n\nclass HtmlParser(object):\n    def _get_new_datas(self, url, soup):\n        res_data = {}\n        res_data['url'] = url\n        # <div class=\"book-title\"><h1>假紫剑圣与B套奶妈</h1>\n        title_nodes = soup.find('div', class_='book-title').find('h1')\n        res_data['title'] = title_nodes.get_text()\n        return res_data\n\n    def _get_new_urls(self, url, soup):\n        new_urls = set()\n        # <a class=\"img\" href=\"http://www.hbooker.com/book/100075809\" target=\"_blank\">\n        links = soup.find_all('a', class_='img')\n        for link in links:\n            new_d_url = link['href']\n            new_urls.add(new_d_url)\n        return new_urls\n\n    def parse(self, url, html_cont):\n        if url is None or html_cont is None:\n            return\n\n        soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')\n        new_urls = self._get_new_urls(url, soup)\n        new_html_cont = self._get_new_datas(url, soup)\n        return new_urls, new_html_cont\n\n```\n\n### 输出起 html_outputer\n```\n# 数据输出\nimport pymysql\n\n#格式化字符串把字典\ndef dic2sql(sql, data):\n    sql2 = sql % (str(data['url']), str(data['title']))\n    return sql2\n\n\nclass HtmlOutputer(object):\n    def __init__(self):\n        self.datas = []\n\n    def collect_data(self, new_datas):\n        if new_datas is None:\n            return\n        self.datas.append(new_datas)\n\n    def output_html(self):\n        fout = open('output.html', 'w')\n        fout.write('<html>')\n        fout.write('<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />')\n        fout.write('<body>')\n        fout.write('<table>')\n\n        for data in self.datas:\n            fout.write('<tr>')\n            fout.write('<td>%s</td>' % data['url'])\n            fout.write('<td>%s</td>' % data['title'])\n            fout.write('</tr>')\n\n        fout.write('</table>')\n        fout.write('</body>')\n        fout.write('</html>')\n        fout.close()\n\n    def output_mysql(self):\n\n        # 打开数据库连接\n        db = pymysql.connect(\"localhost\", \"root\", \"MarkCHYL\", \"TESTDB\")\n\n        # 使用 cursor() 方法创建一个游标对象 cursor\n        cursor = db.cursor()\n\n        # 使用 execute() 方法执行 SQL，如果表存在则删除\n        cursor.execute(\"DROP TABLE IF EXISTS HBOOKER\")\n\n        # # 使用预处理语句创建表\n        sql = \"\"\"CREATE TABLE HBOOKER (\n         TITLE  VARCHAR (200) NOT NULL,\n         URL  VARCHAR (200))\"\"\"\n        print(sql)\n\n        cursor.execute(sql)\n        #\n        for data in self.datas:\n            # SQL 插入语句\n            # sql = \"INSERT INTO HBOOKER(TITLE, URL) VALUES (\\'\" + str(data['title']) + \"','\" + str(data['url']) + \"')\"\n            sql = \"INSERT INTO HBOOKER(URL,TITLE) VALUES ('%s','%s')\"\n            sql1 = dic2sql(sql, data)\n            print(sql1)\n            try:\n                # 执行sql语句\n                cursor.execute(sql1)\n                # 提交到数据库执行\n                db.commit()\n            except:\n                # 如果发生错误则回滚\n                db.rollback()\n\n        # 关闭数据库连接\n        db.close()\n\n```\n后记：代码可能比较多  我只是为了更好的了解整个爬虫的过程","tags":["Python","爬虫"],"categories":["Python"]},{"title":"Android7.0至Android8.0适配记录","url":"/2018/12/17/Android7-0至Android8-0适配记录/","content":"## Android7.0至Android8.0适配记录\n#### 一五年的老项目，里面存在过时的API众多，导致高版本的编译时运行时报错，而我这次做的适配遇到的困难重要有三个\n###    \n<!--more-->\n* ### 广播接收者（BroadCastReceiver）无法正常己收到广播去发起通知。\n* ### 8.0系统的手机上，全面的界面不能填充完整。\n* ### 由于项目里用到的网络框架jar是XUtils，许久没做维护的第三方的jar包，HttpClient 和 HttpConnection 已在高版本的API直接和我们拜拜了。\n\n### 下面我真对上面自己的问题记录下我的处理：\n##  第一、 8.0系统的手机上，全面的界面不能填充完整\n```\n     <meta-data\n            android:name=\"android.max_aspect\"\n            android:value=\"2.4\" />\n```\n## 第二、 广播接收者（BroadCastReceiver）无法正常己收到广播去发起通知\n\n[关于Android 8.0后notification通知声音无法关闭或开启的问题](https://blog.csdn.net/fzkf9225/article/details/81119780)\n## 第三、 HttpClient 和 HttpConnection的强制使用Utils的低版本API\n\n#### 这个我在网上找到一个配置方法，但是还是编译失败，所以弃用，起码现在编译成功\n\n在app中的build文件中添加：\n```\n  useLibrary 'org.apache.http.legacy'\n```\n","tags":["适配"],"categories":["Android"]},{"title":"Mark的Retrofit学习第一篇","url":"/2018/12/17/Mark的Retrofit学习第一篇/","content":"## Retrofit介绍 :\n改造将您的HTTP API变成一个Java界面。Square公司针对Android和Java的类型安全HTTP客户端\n       Retrofit是Square公司开发的一款针对Android网络请求的框架，Retrofit2底层基于OkHttp实现的，OkHttp现在已经得到Google官方认可，大量的app都采用OkHttp做网络请求，其源码详见OkHttp Github。\n\n       每个方法都必须有一个提供请求方法和相对URL的HTTP注释。有五个内置注释：GET，POST，PUT，DELETE，和HEAD。资源的相对URL在注释中指定。\n<!--more-->\n## 一、声明接口\npublic interface GitHubService {\n  @GET(\"users/{user}/repos\")\n  Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n\n///Retrofit turns your HTTP API into a Java interface.\n\neg：例子：\n如果链接是http://ip.taobao.com/service/getIpInfo.php?ip=202.202.33.33\n @GET(\"http://ip.taobao.com/service/getIpInfo.php\")\n    Call getWeather(@Query(\"ip\") String ip);\n\n注意：这里强调一点：Call get();必须是这种形式,这是2.0之后的新形式\n * 如果不需要转换成Json数据,可以用了ResponseBody;\n * 你也可以使用Call get();这样的话,需要添加Gson转换器\n\n## 二、接口调用\nRetrofit retrofit = new Retrofit.Builder()\n //这里建议：- Base URL: 总是以/结尾；- @Url: 不要以/开头\n    .baseUrl(\"https://api.github.com/\")\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n\nCall<List<Repo>> repos = service.listRepos(\"octocat\");\n\n//The Retrofit class generates an implementation of the GitHubService interface.\n强调一点：如果你的@GET后面的URL地址是全拼的地址，那么baseurl就会设置的没有必要，留意哦！！！\n\n## 三、同步调用\n  try {\n            Response bodyResponse = call.execute();\n            String body = bodyResponse.body().string();//获取返回体的字符串\n            Log.i(\"wxl\", \"body=\" + body);\n        } catch (IOException e) {\n            e.printStackTrace();\n注意：同步需要处理android.os.NetworkOnMainThreadException\n\n## 四、异步调用\ncall.enqueue(new Callback() {\n            @Override\n            public void onResponse(Response response) {\n                try {\n                    Log.i(\"wxl\", \"response=\" + response.body().string());\n                } catch (IOException e) {\n                    e.printStackTrace();\n            @Override\n            public void onFailure(Throwable t) {\n                Log.i(\"wxl\", \"onFailure=\" + t.getMessage());\n        });\n\n注意这里看不懂的可以参考我的GitHub代码地址：https://github.com/MarkCHYL/MarkRetrofitDemo\n项目中添加了简单的使用方法，只做到如何获取网络接口的数据。\n\n## 五、移除请求\ncall.cancel();\n\n## 六、添加gson依赖\n implementation 'com.squareup.retrofit2:converter-gson:2.3.0'\n这里我选择的是与retrofit统一版本的，我怕报错\n\n后续我会进一步封装！！！\n\n## 七、Retrofit2打印 网络请求日志\n添加依赖：\n implementation 'com.squareup.okhttp3:logging-interceptor:3.8.1'\n## 然后就是你初始化拦截器加配置；这个很简单我参考了以下两篇文章\nhttps://blog.csdn.net/u011511368/article/details/51753315\nhttps://blog.csdn.net/Picasso_L/article/details/53200926\n\n### 最后附上自己的[Github的Demo](https://github.com/MarkCHYL/MarkRetrofitDemo)","tags":["Android","网络框架"],"categories":["Android"]},{"title":"Activity的生命周期","url":"/2018/12/17/Activity的生命周期/","content":"![image](http://hi.csdn.net/attachment/201109/1/0_1314838777He6C.gif)\n#### 1.启动Activity：系统会先调用onCreate方法，这是生命周期第一个方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。\n<!--more-->\nonCreate方法：一般做一些初始化工作，比如setContentView去加载布局资源，初始化Activity所需的数据。\n\nonStart方法：表示Activity正在启动，已经可见，但是无法和用户交互。\n/Users/mark/Downloads/Activity的生命周期.md\nonResume方法：Activity已经可见并且开始活动，已经出现在前台。\n\n#### 2.当前Activity被其他Activity覆盖其上或被锁屏：\n\n（可以理解为没有完全遮挡界面的）\n\n系统会调用onPause方法，暂停当前Activity的执行。\n\n#### 3.当前Activity由被覆盖状态回到前台或解锁屏：\n\n系统会调用onResume方法，再次进入运行状态。\n\n#### 4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：\n\n系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。\n\n#### 5.用户后退回到此Activity：\n\n系统会先调用onRestart方法，\n\n然后调用onStart方法，\n\n最后调用onResume方法，\n\n再次进入运行状态。\n\n#### 6.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。\n\n但是知道这些还不够，我们必须亲自试验一下才能深刻体会，融会贯通。\n\n***\nActivity四种启动模式的区别：standard    singleTop  singleTask   singleInstance\n\nstandard：每次激活Activity时(startActivity)，都创建Activity实例，并放入任务栈； \n\nsingleTop：如果某个Activity自己激活自己并且Activity处于栈顶，则不需要创 建，其余情况都要创建Activity实例；\n \nsingleTask：如果要激活的那个Activity在任务栈中存在该实例，则不需要创建，只需要把 此Activity放入栈顶，即把该Activity以上的Activity实例都pop，并调用其onNewIntent；\n \nsingleInstance：应用1的任务栈中创建了MainActivity实例，如果应用2也要激活 MainActivity，则不需要创建，两应用共享该Activity实例。\n***\nonSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的 activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一 个机会让你保存的数据。\n至于onRestoreInstanceState方法，需要注意的是， onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用 的。 \n\nonRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅 是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时 候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下 activity A一般不会因为内存的原因被系统销毁\n故activity A的onRestoreInstanceState方 法不会被执行。\n\n 另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择 在onCreate方法中做数据还原。\n\n切换横竖屏的生命周期：\n\n\n1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，\n切横屏时会执行一次，切竖屏时会执行两次\n\n2、设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调\n用各个生命周期，切横、竖屏时只会执行一次\n\n3、设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，\n切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法\n\n\n\n\n#### Activity运行时按下HOME键(跟被完全覆盖是一样的)：\n---\n--> onPause--> onPauseonSaveInstanceState--> onStop  --> onRestart-->onStart--->onResume\n---\n#### Activity未被完全覆盖只是失去焦点：onPause--->onResume（我没复现过这个，待考证）\n\n#### A跳转到B，然后按 back回退到A，A的生命周期：\n---\n-->onCreate -->onStart -->onResume -->onPause -->onSaveInstanceState -->onStop 然后回退-->onRestart -->onStart -->onResume \n---\n","tags":["基础理论"],"categories":["Android"]},{"title":"安卓的启动模式详解","url":"/2018/12/16/安卓的启动模式详解/","content":"\n#### 安卓开发者基本都知道Activity的四大启动模式，但是一到被问到之间区别的时候，再问深一点的时候，往往都会回答的不是很让面试官满意，鄙人就是，嘴皮子笨不懂得如何表达清楚。\n## **简介**\n#### 我们在创建一个Activity后，都知道要在清单文件中去注册，在程序员创建该Activity实例时，系统会按照先进先出的原则，创建一个任务栈将其实例放入其中，然后按back键时或finish时，系统就会将栈顶的Activity移除栈，我们可以在清单文件中指明该Activity的启动模式，系统默认的Activity的启动模式是standard模式。\n***\n<!--more-->\n### Activity的启动模式：\n#### ***standard、singleTask、singleTop、singleInstance***\n#### 1. standard(标准模式)\n***不管这个Activity的实例是否存在于任务栈中或者和启动它的Activity是否在相同的任务栈中，每次启动Activity都会创建一个新的实例。谁启动了它，它就属于启动它的Activity的任务栈中，***\n### ***无论核实启动哪个Activity，都会重新创建页面实例并收入栈尾***\n#### 2. singleTask(栈内复用模式)\n***在这个模式下，如果栈内存在该Activity的实例，不管是否存在于栈顶都不会再创建实例，而是会将该实例前的Activity清出栈顶（cleanTop），并且会回调onNewIntent方法。其实在这个过程中，首先是会进行任务栈的匹配，这个任务栈就是通过taskAffinity属性指定，如果不存在这个任务栈，就会创建一个任务栈，并将该Activity放入栈中。流程图比较清晰，如下所见：***\n![image](https://user-gold-cdn.xitu.io/2017/5/17/490fd5b297a2a07d60d1ffdad58e6cc3)\n### ***启动activity时，判断栈中存在activity的实例，就重新利用，并清除位于该实例上面的所有实例，否则情况和standard一样***\n#### 3. singleTop(栈顶复用模式)\n***这个模式下，如果Activity的实例已经存在在栈顶，启动它就不会再创建新的实例，而是会调用onNewIntent，通过此方法的参数我们可以去除当前请求的信息。随后会调用onResume方法，不再调用onCreate、onStart方法，因为它没有变化。如果没有存在的话，就会如同standard模式一样。这种模式可以用来防止多次打开同一个Activity。***\n### ***启动activity时，判断栈顶正好时该activity的实例，就重新使用，否则就会创建新的实例放入栈顶，否则的情况和standard类似***\n#### 4、singleInstance（全局唯一模式）\n***该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。***\n\n### ***启动activity时，将该Activity的实例放入一个新的栈中，原栈中的实例保持不变***\n\n#### ps：[adb shell dumpsys activity],查看adb运行日志\n","tags":["Android"],"categories":["Android"]},{"title":"Mark的个人博客搭建","url":"/2018/12/14/Mark的第一篇博客/","content":"***\n# **标题: Mark的个人博客搭建**\n***\n### **一、前言**\n> 大家好，我是Mark，一个Android程序员，目前从事软件应用开发，\b其实我很早就像想很多的大佬们一样拥有自己的博客，在下在网上搜了一波，发现可以通过 GitHub + Hexo 搭建自己个人的博客，这次我就想彻底好好的把这个弄好，主要是可以方便自己把自己的笔记\b记录在上面，方便自己的以后的只是复习。我的脑子不太好使，记东西过了不久就会忘记，好记性不容烂笔头，对于一个程序员如果还在用笔记本自己\b手写笔记\b确实让我自己感到惭愧，程序的代码量和知识点很多，若是每个自己的笔记都去用手写，那样我的工作效率就会很低。在此我想大家推荐，\n<!--more-->\n### **二、记录下我搭建此博客方法**\n\b利用GitHub + Hexo 搭建个人的博客，网上有很多的大佬的文章，这里我想大家推荐一个博客文章[JackyRoc的文章链接](https://www.cnblogs.com/jackyroc/p/7681938.html)，至于怎么利用Hexo在下推荐先看看此文章[小茗同学的博客园](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html).\n\n好了！现在开始记录我自己的搭建步骤：\n\n#### 首先：我们的搭建环境\b是 MacBook Pro，准备的编写博客的编辑器 **[Visual Studio Code](https://code.visualstudio.com/?wt.mc_id=DX_841432)**,**GitHub**，以及重要的安装好 **git**，再就是很重要的是耐心和百折不挠的信息。Start！！！\n\n   ### 1. 创建仓库（https://markchyl.github.io/）\n   仓库的名字是这个格式 XXXXX.github.io，XXXXX 就是你的自己可以定义的，后面的 .github.io 一定要这样，当然如果你有自己的个人域名地址也是可以在后面的步骤中绑定的。创建仓库的步骤我就不啰嗦了！简单。\n\n   ### 2. Hexo的安装\n   要使用Hexo,需要安装Nodejs以及Git，\n   [参考:安装Node.js](http://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n   在你需要安装Hexo的目录下(新建一个文件夹)右键选择 Git Bash\n\nnpm install hexo-cli -g   \nhexo init #初始化网站   \nnpm install   \nhexo g #生成或 hexo generate   \nhexo s #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000  查看了\n详细命令请参考Hexo文档\n\n这里介绍一下怎么创建一篇文章\n\nhexo new \"文章名\" #新建文章\nhexo new page \"页面名\" #新建页面   \n常用简写\n\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n新建一篇文章后就可以预览了,在hexo new之后执行一次生成hexo g再执行hexo s启动本地服务器,如果之前还在hexo s 按Ctrl + C 结束.\n\n\n### 3.添加主题\n安装主题(yilia主题):\nhexo clean\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia   \n启动主题\n找到目录下的_config.yml 文件,打开找到 theme：属性并设置为yilia\n\n更新主题\ncd themes/yilia\ngit pull\nhexo g\nhexo s\n此时刷新http://localhost:4000/页面就能看到新的主题了.\n\n### 4. 部署到Github\n1.检查SSH keys的设置\n\n以下命令均是在Git bash里输入\n```\ncd ~/.ssh\nls\n```\n#此时会显示一些文件\n```\nmkdir key_backup\ncp id_rsa* key_backup\nrm id_rsa* \n```\n\n#以上三步为备份和移除原来的SSH key设置\n> ssh-keygen -t rsa -C \"邮件地址@youremail.com\" #生成新的key文件,\n\n**邮箱地址填你的Github地址**\n***\n#Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):<回车就好>\n#接下来会让你输入密码\n之后就可以看到成功的界面。\n***\n\n2.添加SSH Key到Github\n进入github首页在设置洁面\n![](https://images2017.cnblogs.com/blog/1250458/201710/1250458-20171017153636849-294935886.png)\n***\n#### 添加SSH Key\n![](https://images2017.cnblogs.com/blog/1250458/201710/1250458-20171017153642521-647884655.png)\n找到系统当前用户目录下(开启查看隐藏文件) C:\\Users\\用户名\\ .ssh id_rsa.pub文件以文本方式打开。打开之后全部复制到key中\n![](https://images2017.cnblogs.com/blog/1250458/201710/1250458-20171017153648631-441574444.png)\n到了这就可以测试一下是否成功了:\n\nssh -T git@github.com\n#之后会要你输入yes/no,输入yes就好了。\n设置你的账号信息:\n\ngit config --global user.name \"你的名字\"     #真实名字不是github用户名\ngit config --global user.email \"邮箱@邮箱.com\"    #github邮箱\n3.部署到github\nhexo d\n这时再刷新 username.github.io 就可以看到你的博客了。\n\n到了这你以为就结束了吗？没有，还有坑没有给你们填好。\n\n\n如果你的SSH配置的时候哪找的.ssh文件的化，\b可以参照[mac 上传本地代码到 Github 教程](https://www.cnblogs.com/ailiailan/p/8577411.html),我就是参照上面的步骤配置的。\n\n\n","tags":["Hexo","工具搭建"],"categories":["工具使用"]}]